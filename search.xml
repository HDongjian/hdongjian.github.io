<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用命令]]></title>
    <url>%2F2019%2F08%2F05%2Flinux_command%2F</url>
    <content type="text"><![CDATA[linux cd / 是跳转到根目录 根目录是所有用户共享的目录 cd ~ 是跳转到当前用户的家目录 如果是root用户，cd ~ 相当于 cd /root 如果是普通用户，cd ~ 相当于cd /home/当前用户名 cd /home 相当于查看有多少普通用户的家目录 因为所有的普通用户的父目录都是home目录 pwd 查看路径 ll 查看所有文件 wget 下载 sudo passwd root 重置密码 su 管理员 tar -zxvf apache-tomcat-9.0.22.tar.gz 解压tar文件 vim server.xml 打开文件 mkdir 创建文件夹 java -version 检查java版本 vim编辑 按o进行编辑 ESC键跳到命令模式 :w保存文件但不退出vi 编辑 :w! 强制保存，不退出vi 编辑 :w file将修改另存到file中，不退出vi 编辑 :wq保存文件并退出vi 编辑 :wq!强制保存文件并退出vi 编辑 q:不保存文件并退出vi 编辑 :q!不保存文件并强制退出vi 编辑 :e!放弃所有修改，从上次保存文件开始在编辑 scp wenjianming root@192.168.0.11:/home文件传输 sudo service ssh restart 重启ssh服务 sudo bash 切换管理员权限 mysql -uroot -p 进入mysql编辑模式 exit 退出 nginx ./nginx -c /usr/local/nginx/conf/nginx.conf 启动nginx ps -ef|grep nginx 查看启动状态 node node server.js 查看服务 pm2 pm2 start app.js # 启动app.js应用程序 pm2 start app.js -i 4 # cluster mode 模式启动4个app.js的应用实例 # 4个应用程序会自动进行负载均衡 pm2 start app.js --name=&quot;api&quot; # 启动应用程序并命名为 “api” pm2 start app.js --watch # 当文件变化时自动重启应用 pm2 start script.sh # 启动 bash 脚本 pm2 list # 列表 PM2 启动的所有的应用程序 pm2 monit # 显示每个应用程序的CPU和内存占用情况 pm2 show [app-name] # 显示应用程序的所有信息 pm2 logs # 显示所有应用程序的日志 pm2 logs [app-name] # 显示指定应用程序的日志 pm2 flush pm2 stop all # 停止所有的应用程序 pm2 stop 0 # 停止 id为 0的指定应用程序 pm2 restart all # 重启所有应用 pm2 reload all # 重启 cluster mode下的所有应用 pm2 gracefulReload all # Graceful reload all apps in cluster mode pm2 delete all # 关闭并删除所有应用 pm2 delete 0 # 删除指定应用 id 0 pm2 scale api 10 # 把名字叫api的应用扩展到10个实例 pm2 reset [app-name] # 重置重启数量 pm2 startup # 创建开机自启动命令 pm2 save # 保存当前应用列表 pm2 resurrect # 重新加载保存的应用列表 mysqllinux下查看mysql服务的两种方式：ps -ef|grep mysqlnetstat -nlp linux下启动mysql服务的两种方式：命令行方式：cd /usr/bin./mysqld_safe &amp;service mysql start 如果服务在启动状态，直接重启服务用以下命令：service mysql restart linux下关闭mysql服务的两种方式：命令行方式：[root@localhost ~]mysqladmin -u root shutdown 服务方式：[root@localhost ~]service mysql stop]]></content>
      <categories>
        <category>Surround</category>
      </categories>
      <tags>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-navigation]]></title>
    <url>%2F2019%2F07%2F08%2Fvue-navigation%2F</url>
    <content type="text"><![CDATA[关于vue-navigation A page navigation library, record routes and cache pages, like native app navigation. 一个页面导航库，记录路由并缓存页面，像原生APP导航一样。 github——zack24q 目录结构1234567|-- src //根路径 |-- components |-- Navigation.js //组件 |-- index.js //入口 |-- navigator.js //方法 |-- routes.js //缓存 |-- utils.js //工具 文件初始化初始化index.jsmain.js 12import Navigation from 'vue-navigation'Vue.use(Navigation, &#123;router, store, 'moduleName', 'keyName'&#125;) 源码： 1install: (Vue, &#123; router, store, moduleName = 'navigation', keyName = 'VNK' &#125; = &#123;&#125;) =&gt; &#123;&#125; moduleName默认参数navigation：store中缓存的路由名称 keyName默认参数VNK：路径中query的key 初始化navigation.js初始化index.js之后，随即就会初始化bus以及navigation.js bus主要是在触发navigation中的前进、后退等方法的时候通知触发回调事件 12345678910// app.vuethis.$navigation.on('forward', (to, from) =&gt; &#123; console.log('forward to', to, 'from ', from)&#125;)this.$navigation.on('back', (to, from) =&gt; &#123; console.log('back to', to, 'from ', from)&#125;)this.$navigation.on('replace', (to, from) =&gt; &#123; console.log('replace to', to, 'from ', from)&#125;) navigation中主要是对前进，后退等方法的封装，其中会涉及到通过store以及sessionStorage做的路由缓存和bus方法的调用 初始化组件components/Navigation.jsapp.vue(根路径) 123&lt;navigation&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/navigation&gt; 实现逻辑全局前置守卫beforeEach123456789101112131415161718// index.js router.beforeEach((to, from, next) =&gt; &#123; if (!to.query[keyName]) &#123; const query = &#123; ...to.query &#125; // go to the same route will be set the same key if (to.path === from.path &amp;&amp; isObjEqual( &#123; ...to.query, [keyName]: null &#125;, &#123; ...from.query, [keyName]: null &#125;, ) &amp;&amp; from.query[keyName]) &#123; query[keyName] = from.query[keyName] &#125; else &#123; query[keyName] = genKey() &#125; next(&#123; name: to.name, params: to.params, query, replace: replaceFlag || !from.query[keyName] &#125;) &#125; else &#123; next() &#125; &#125;) 判断前后路由是否一致，如果一直，获取from的路由版本号，不进行版本更新 如果不一致，获取新的keyName并且放置到新的路由地址中 全局后置钩子afterEach12345// index.js router.afterEach((to, from) =&gt; &#123; navigator.record(to, from, replaceFlag) replaceFlag = false &#125;) 12345678910111213141516// navigation.jsconst record = (toRoute, fromRoute, replaceFlag) =&gt; &#123; const name = getKey(toRoute, keyName) if (replaceFlag) &#123; replace(name, toRoute, fromRoute) &#125; else &#123; const toIndex = Routes.lastIndexOf(name) if (toIndex === -1) &#123; forward(name, toRoute, fromRoute) &#125; else if (toIndex === Routes.length - 1) &#123; refresh(toRoute, fromRoute) &#125; else &#123; back(Routes.length - 1 - toIndex, toRoute, fromRoute) &#125; &#125;&#125; 触发路由后置函数 afterEach,调用navigator的record方法 Routes为store以及sessionStorage做的路由缓存 根据Routes中缓存判断是前进，还是后退，还是刷新，调用不同的事件 forward中向缓存新增一条记录，记录的结果如下，并且触发store的navigation/FORWARD方法 1["index?a28ae28e","list?ff674e47"] refresh触发store的navigation/REFRESH方法 back触发store的navigation/BACK方法，删除一条记录 components/Navigation.js 在Navigation中检测了缓存routes的变化 1234567891011watch: &#123; routes(val) &#123; for (const key in this.cache) &#123; if (!matches(val, key)) &#123; const vnode = this.cache[key] vnode &amp;&amp; vnode.componentInstance.$destroy() delete this.cache[key] &#125; &#125; &#125;,&#125; 会根据routes中的变化，改变cache的缓存 在render函数中根据cache的缓存渲染组件12345678910111213if (this.cache[key]) &#123; if (vnode.key === this.cache[key].key) &#123; // restore vnode from cache vnode.componentInstance = this.cache[key].componentInstance &#125; else &#123; // replace vnode to cache this.cache[key].componentInstance.$destroy() this.cache[key] = vnode &#125;&#125; else &#123; // cache new vnode this.cache[key] = vnode&#125; 问题关于路由版本号keyName 只有在前往的页面路径没有keyName并且不是刷新操作的情况下才会生成新的keyName; 页面是否读取缓存是由路径以及genKey的值来决定的 页面返回会清除上一个页面的缓存 刷新页面keyName的值不会发生改变，但是因为组件的缓存是由一个变量cacha来实现的，所以依旧会触发created方法 关于路由不设置name属性路径没有keyName参数的问题 不设置name页面依旧会缓存，只不过缓存的数据是： 1["/?undefined","/list?undefined"] 原因是在全局前置钩子beforeEach中调用next函数的时候，用的是路由name字段，如果没有该字段，设置的query就无效，在afterEach中就无法获取keyName导致缓存为undefined，此种情况下虽然缓存依旧有效，但是不太安全 其他 关于其他的地方，比如replace方法，navigation提供的getRoutes和cleanRoutes因为跟主要功能关系不大，未做详细说明 navigation在没有store缓存的情况下会使用sessionStorage作为缓存路径 无论是store和sessionStorage都没有对组件进行缓存，所以页面刷新必定会引起组件的重新加载]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Less常用方法]]></title>
    <url>%2F2019%2F06%2F17%2Fless%2F</url>
    <content type="text"><![CDATA[路径引入1234567891011121314// Variables@images: "../img";// Usagebody &#123; color: #444; background: url("@&#123;images&#125;/white-sand.png");&#125;// Variables@themes: "../../src/themes";// Usage@import "@&#123;themes&#125;/tidal-wave.less"; 属性代替123456@property: color;.widget &#123; @&#123;property&#125;: #0ee; background-@&#123;property&#125;: #999;&#125; 延伸选择器初步用法12345678910111213141516nav ul &#123; &amp;:extend(.inline); background: blue;&#125;.inline &#123; color: red;&#125;输出nav ul &#123; background: blue;&#125;.inline,nav ul &#123; color: red;&#125; 对比混入示例 - 使用mixin：12345678910.my-inline-block() &#123; display: inline-block; font-size: 0;&#125;.thing1 &#123; .my-inline-block;&#125;.thing2 &#123; .my-inline-block;&#125; 输出12345678.thing1 &#123; display: inline-block; font-size: 0;&#125;.thing2 &#123; display: inline-block; font-size: 0;&#125; 12345678910.my-inline-block &#123; display: inline-block; font-size: 0;&#125;.thing1 &#123; &amp;:extend(.my-inline-block);&#125;.thing2 &#123; &amp;:extend(.my-inline-block);&#125; 输出123456.my-inline-block,.thing1,.thing2 &#123; display: inline-block; font-size: 0;&#125; Mixins中的选择器12345678910111213.my-hover-mixin() &#123; &amp;:hover &#123; border: 1px solid red; &#125;&#125;button &#123; .my-hover-mixin();&#125;输出button:hover &#123; border: 1px solid red;&#125; 循环属性循环123456789.loop(@counter) when (@counter &gt; 0) &#123; .loop((@counter - 1)); // next iteration width: (10px * @counter); // code for each iteration&#125;div &#123; .loop(5); // launch the loop&#125; 输出：1234567div &#123; width: 10px; width: 20px; width: 30px; width: 40px; width: 50px;&#125; 类名循环12345678.generate-columns(4);.generate-columns(@n, @i: 1) when (@i =&lt; @n) &#123; .column-@&#123;i&#125; &#123; width: (@i * 100% / @n); &#125; .generate-columns(@n, (@i + 1));&#125; 输出：123456789101112.column-1 &#123; width: 25%;&#125;.column-2 &#123; width: 50%;&#125;.column-3 &#123; width: 75%;&#125;.column-4 &#123; width: 100%;&#125; 合并1234567.mixin() &#123; box-shadow+: inset 0 0 10px #555;&#125;.myclass &#123; .mixin(); box-shadow+: 0 0 20px black;&#125; 输出123.myclass &#123; box-shadow: inset 0 0 10px #555, 0 0 20px black;&#125; 父选择器属性123456a &#123; color: blue; &amp;:hover &#123; color: green; &#125;&#125; 结果是：1234567a &#123; color: blue;&#125;a:hover &#123; color: green;&#125; 类名123456789101112.button &#123; &amp;-ok &#123; background-image: url("ok.png"); &#125; &amp;-cancel &#123; background-image: url("cancel.png"); &#125; &amp;-custom &#123; background-image: url("custom.png"); &#125;&#125; 输出：123456789.button-ok &#123; background-image: url("ok.png");&#125;.button-cancel &#123; background-image: url("cancel.png");&#125;.button-custom &#123; background-image: url("custom.png");&#125;]]></content>
      <categories>
        <category>Surround</category>
      </categories>
      <tags>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用方法库]]></title>
    <url>%2F2019%2F05%2F22%2Flib%2F</url>
    <content type="text"><![CDATA[CSS多行最后一行 ···1234567891011.answer-body &#123; font-size: 16px; line-height: 30px; text-align: left; height: 60px; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;&#125; BOM获取设备像素比1window.devicePixelRatio 获取浏览器信息1234567891011121314151617181920212223242526272829303132333435363738394041/*** 关于事件参数对象的工具的代码*/evtTools = &#123; //事件参数 evt: function (e) &#123; return window.event ? window.event : e; &#125;, //页面向左卷曲出去的距离 left: function () &#123; return window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft || 0; &#125;, //页面向上卷曲出去的距离 top: function () &#123; return window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop || 0; &#125;, //事件参数对象中的属性封装---可视区域的横坐标 clientX: function (e) &#123; return this.evt(e).clientX; &#125;, //事件参数对象中的属性封装---可视区域的纵坐标 clientY: function (e) &#123; return this.evt(e).clientY; &#125;, pageX: function (e) &#123; return this.evt(e).pageX ? this.evt(e).pageX : this.left() + this.clientX(e); &#125;, pageY: function (e) &#123; return this.evt(e).pageY ? this.evt(e).pageY : this.top() + this.clientY(e); &#125;&#125;;/*** 当浏览器的宽度发生变化,就获取浏览器(页面可视区域的宽度)*/getClient = () =&gt; &#123; return &#123; width: window.innerWidth || document.body.clientWidth || document.documentElement.clientWidth || 0, height: window.innerHeight || document.body.clientHeight || document.documentElement.clientHeight || 0 &#125;&#125; DOM获取元素的样式属性1234567891011/** * 获取元素的样式属性 */getStyle = (element, attr) =&gt; &#123; var result = element.currentStyle ? element.currentStyle[attr] : window.getComputedStyle(element, null)[attr]; if (result == "auto") &#123; return 0; &#125; else &#123; return result; &#125;&#125;; 绑定解绑事件12345678910111213141516171819202122232425/** * 为元素绑定多个属性的兼容代码 */addEventListener = (element, type, fn) =&gt; &#123; if (typeof (element.addEventListener) != "undefined") &#123; element.addEventListener(type, fn, false); &#125; else if (typeof (element.attachEvent) != "undefined") &#123; element.attachEvent("on" + type, fn) &#125; else &#123; element["on" + type] = fn; &#125;&#125;;/** * 解绑兼容函数 */removeEventListener = (element, type, fn) =&gt; &#123; if (typeof (element.removeEventListener) != "undefined") &#123; element.removeEventListener(type, fn) &#125; else if (typeof (element.detachEvent) != "undefined") &#123; element.detachEvent("on" + type, fn) &#125; else &#123; element["on" + click] = null; &#125;&#125;; 数据类型校验1234567891011121314151617181920212223function isArray (o) &#123; return Object.prototype.toString.call(o) === '[object Array]'&#125;function isObject (o) &#123; return Object.prototype.toString.call(o) === '[object Object]'&#125;function isString (o) &#123; return Object.prototype.toString.call(o) === '[object String]'&#125;function isNumber (o) &#123; return Object.prototype.toString.call(o) === '[object Number]'&#125;function isDate (o) &#123; return Object.prototype.toString.call(o) === '[object Date]'&#125;function isRegExp (o) &#123; return Object.prototype.toString.call(o) === '[object RegExp]'&#125; String去掉最后一个字符1s=s.substring(0,s.length-1) 获取路由路径1location.hash.match(/#(\S*)\?[\S]*/)[1] VSCode正则查找所有console1console.log((.*)) ESlint配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&#123; "extensions.ignoreRecommendations": true, "vetur.validation.template": false, "vetur.format.defaultFormatter.html": "js-beautify-html", "vetur.format.defaultFormatterOptions": &#123; "wrap_attributes": "force-aligned", "prettyhtml": &#123; "printWidth": 100, "singleQuote": false, "wrapAttributes": false, "sortAttributes": false &#125; &#125;, "files.associations": &#123; "*.vue": "vue", "*.less": "less", "*.cjson": "jsonc", "*.wxss": "css", "*.wxs": "javascript", "*.js": "javascript", "*.swig": "html", "*.styl": "css" &#125;, "git.enableSmartCommit": true, "workbench.startupEditor": "newUntitledFile", "breadcrumbs.enabled": true, "explorer.confirmDelete": false, "javascript.updateImportsOnFileMove.enabled": "always", "emmet.includeLanguages": &#123; "wxml": "html", "javascript": "javascriptreact" &#125;, "minapp-vscode.disableAutoConfig": true, "[javascript]": &#123;&#125;, "editor.fontSize": 15, "editor.fontWeight": "100", "editor.tabSize": 2, "git.confirmSync": false, "window.zoomLevel": 0, // "editor.renderWhitespace": "boundary", // "editor.cursorBlinking": "smooth", "editor.minimap.enabled": true, "editor.minimap.renderCharacters": false, "window.title": "$&#123;dirty&#125;$&#123;activeEditorMedium&#125;$&#123;separator&#125;$&#123;rootName&#125;", // "editor.codeLens": true, // 配置文件关联，以便启用对应的提示 // 配置emmet是否启用tab展开缩写 "emmet.triggerExpansionOnTab": true, // 配置emmet对文件类型的支持 "emmet.syntaxProfiles": &#123; "javascript": "jsx", "vue": "html", "vue-html": "html" &#125;, // 是否开启eslint检测 "eslint.enable": true, // 文件保存时是否根据eslint进行格式化 "eslint.autoFixOnSave": true, // eslint配置文件 "eslint.options": &#123; "extensions": [ ".js", ".vue" ] &#125;, // eslint能够识别的文件后缀类型 "eslint.validate": [ "javascript", &#123; "language": "vue", "autoFix": true &#125;, "html", "vue", "jsx" ], "search.exclude": &#123; "**/node_modules": true, "**/bower_components": true, "**/dist": true &#125;, "workbench.colorTheme": "Solarized Dark", // 格式化快捷键（默认）：Shift+Alt+F // prettier进行格式化时，开启eslint支持 // "prettier.eslintIntegration": true, // // 是否使用单引号 // "prettier.singleQuote": true, "line-counter.excludes": [ "**/build/**", "**/.vscode/**", "**/node_modules/**" ], "terminal.integrated.rendererType": "dom", "search.followSymlinks": false, "vetur.format.defaultFormatter.js": "vscode-typescript", "vetur.format.defaultFormatter.ts": "vscode-typescript"&#125; Array数组去重12Array.from(new Set([1,2,3,3,4,4])) //[1,2,3,4][...new Set([1,2,3,3,4,4])] //[1,2,3,4] 是否包含某值1234[1,2,3].includes(4) //false[1,2,3].indexOf(4) //-1 如果存在换回索引[1, 2, 3].find((item)=&gt;item===3)) //3 如果数组中无值返回undefined[1, 2, 3].findIndex((item)=&gt;item===3)) //2 如果数组中无值返回-1 类数组转换1234Array.prototype.slice.call(arguments) //arguments是类数组(伪数组)Array.prototype.slice.apply(arguments)Array.from(arguments)[...arguments] 提取对象key1Object.keys(&#123;name:'张三',age:14&#125;) //['name','age'] 提取对象value1Object.values(&#123;name:'张三',age:14&#125;) //['张三',14] 提取对象key和value1Object.entries(&#123;name:'张三',age:14&#125;) //[[name,'张三'],[age,14]] 将提取的key和value放回去1Object.fromEntries([name,'张三'],[age,14]) //ES10的api,Chrome不支持 , firebox输出&#123;name:'张三',age:14&#125; 每一项设置值12[1,2,3].fill(false) //[false,false,false] [1,2,3].map(() =&gt; 0) 每一项是否满足1[1,2,3].every(item=&gt;&#123;return item&gt;2&#125;) //false 有一项满足1[1,2,3].some(item=&gt;&#123;return item&gt;2&#125;) //true 过滤数组1[1,2,3].filter(item=&gt;&#123;return item&gt;2&#125;) //[3] 按照索引删除元素1[1,2,3].splice(index,1) //[1,3] RegExp常用正则表达式123456英文名: /^[a-zA-Z0-9_-]&#123;4,16&#125;$/中文名: /^[\u4E00-\u9FA5]&#123;2,4&#125;$/密码: /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;6,18&#125;$/邮箱: /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]&#123;2,4&#125;)$/手机号: /^[1][0-9]&#123;10&#125;$/身份证号: /(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/]]></content>
      <categories>
        <category>Surround</category>
      </categories>
      <tags>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3初始化项目]]></title>
    <url>%2F2019%2F04%2F28%2Fvue-cli3_start%2F</url>
    <content type="text"><![CDATA[安装vue-cli1npm install -g @vue/cli 创建配置创建1vue create vue-app 选择配置1234? Please pick a preset: (Use arrow keys)&gt; 1 (babel, eslint) default (babel, eslint) Manually select features 保存过的配置 默认配置 自定义配置 自定义配置12345678910? Check the features needed for your project: (*) Babel (*) TypeScript ( ) Progressive Web App (PWA) Support (*) Router&gt;( ) Vuex (*) CSS Pre-processors (*) Linter / Formatter (*) Unit Testing ( ) E2E Testing 可以直接按数字键1,2,3,4进行选择 Babel：将ES6编译成ES5 TypeScript：JS超集，主要是类型检查 Router和Vuex，路由和状态管理 Linter/ Formatter：代码检查工具 CSS Pre-processors：css预编译 (稍后会对这里进行配置) Unit Testing：单元测试，开发过程中前端对代码进行自运行测试 1Use class-style component syntax? (Y/n) y 是否使用Class风格装饰器？即原本是：home = new Vue()创建vue实例使用装饰器后：class home extends Vue{} 1Use Babel alongside TypeScript for auto-detected polyfills? (Y/n) y 使用Babel与TypeScript一起用于自动检测的填充? yes 1Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) y 路由使用历史模式? 这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面 12345? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): (Use arrow keys)&gt; Sass/SCSS (with dart-sass) Sass/SCSS (with node-sass) Less Stylus 使用什么css预编译器？ 看个人习惯 123456? Pick a linter / formatter config: (Use arrow keys)&gt; TSLint ESLint with error prevention only ESLint + Airbnb config ESLint + Standard config ESLint + Prettier tslint: typescript格式验证工具eslint w…: 只进行报错提醒；eslint + A…: 不严谨模式；eslint + S…: 正常模式；eslint + P…: 严格模式； 建议选择正常模式 123? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)&gt;(*) Lint on save ( ) Lint and fix on commit 代码检查方式 保存时检查 提交时检查并修复 启动打包配置可以在项目最外层新建vue.confi.js来配置端口，代理等配置，具体可以参照官方文档]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CG-FLOW-FE-ELE组件说明文档]]></title>
    <url>%2F2019%2F04%2F25%2Fcg-flow-fe-ele%2F</url>
    <content type="text"><![CDATA[关于cg-flow-fe-ele主要技术点 Vue ElementUi Axios(可选) 功能cg-flow-fe-ele（以下简称flow）包括6个组件，主要作用为已注册工作流展示，工作流编辑&amp;添加，进程展示（待处理，已处理，处理历史），以及进程展示 使用场景 flow的框架基于Vue,UI基于Elementui,请求基于Axios，在使用flow之前保证项目已经依赖三者 flow所有组件主要基于Web端，进程展示组件兼容移动端 各个组件的具体要求参数会在下方详细说明 快速开始引入1234567import Flow from 'cg-flow-fe-ele'import 'cg-flow-fe-ele/dist/cg-flow-fe-ele.css'const theme = &#123; fs:'mini', //可选值medium / small / mini color:'red' // red&#125;Vue.use(Flow, &#123; api, web, theme &#125;) 参数说明 api&amp;web主要服务于axios,如果项目内已经配置了axios,这两个参数非必传; theme参数有两个fs和color fs：可选值medium / small / mini，设置input、下拉框select、按钮button的大小 color:可选值red，设置主题色 组件工作流列表基本使用组件名称：approval-list基本使用： 1&lt;approval-list path='FlowEdit'&gt;&lt;/approval-list&gt; 参数 参数 说明 说明 path 详情所在组件路由query参数 如果使用了header以及flow-list的slot，此参数可以不传 插槽 名称 说明 参数 header 头部 flow-list 表格列表 flowList：列表数据 进行中流程详情展示基本使用组件名称：processess-detail基本使用： 12&lt;processess-detail backgroundColor="#fff" nodeWidth="300" :processId="processDetail.processId" container = "div"&gt;&lt;/processess-detail&gt; 参数 参数 说明 类型 可选值 默认值 processId 进程列表的 processId参数（必传） String backgroundColor 背景色 String 所有16进制颜色 #f5f5f7 container 组件所在容器类型 String div/window window nodeWidth 节点宽度 String 200 unprocessedType 展示未处理节点样式 String default/simple/none default 插槽 名称 说明 参数1 参数2 control-size 控制流程大小比例 size：为目前流程大小（%） function：change 控制size大小；参数：add（String）增加、sub（String）减小 header 节点头部 row：节点数据 content 节点内容 row：节点数据 line 节点连接线 row：节点数据]]></content>
      <categories>
        <category>Lib</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试常见问题]]></title>
    <url>%2F2019%2F03%2F18%2Finterview%2F</url>
    <content type="text"><![CDATA[CSS盒模型 在标准模型中，盒模型的宽高只是内容（content）的宽高， 在IE模型中盒模型的宽高是内容(content)+填充(padding)+边框(border)的总宽高。 JS原型相关概念 原型(prototype): 一个简单的对象，主要用于实现对象的属性继承。new完之后，由实例对象的proto来继承该属性的值； 构造函数: 可以通过new来 新建一个对象的函数（首字母常用大写）。 实例对象: 通过构造函数和new创建出来的对象，便是实例对象，实例通过proto指向原型；]]></content>
      <categories>
        <category>Surround</category>
      </categories>
      <tags>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML&CSS]]></title>
    <url>%2F2019%2F03%2F06%2Fhtml_css%2F</url>
    <content type="text"><![CDATA[CSS盒模型基本概念盒模型的组成大家肯定都懂，由里向外content,padding,border,margin. 盒模型是有两种标准的，一个是标准模型，一个是IE模型。 在标准模型中，盒模型的宽高只是内容（content）的宽高， 而在IE模型中盒模型的宽高是内容(content)+填充(padding)+边框(border)的总宽高。 css如何设置两种模型这里用到了CSS3 的属性 box-sizing 12345/* 标准模型 */box-sizing:content-box; /*IE模型*/box-sizing:border-box; rem布局最终方案Rem布局方案 通过上面可以得出最好的弹性布局方案是，rem+js方案，同时还要解决noscript问题，解决字体问题，解决屏幕过宽问题 但是上面的方案还有个问题，就是分成100份的话，假设屏幕宽度320，此时html大小是3.2px，但浏览器支持最小字体大小是12px，怎么办？那就分成10份呗，只要把上面的100都换成10就好了 下面给一个完整的例子，css的计算没有使用预处理器，这个很简单 html代码如下 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"&gt; &lt;title&gt;rem布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;noscript&gt;开启JavaScript，获得更好的体验&lt;/noscript&gt; &lt;div class="p1"&gt; 宽度为屏幕宽度的50%，字体大小1.2em &lt;div class="s1"&gt; 字体大小1.2.em &lt;/div&gt; &lt;/div&gt; &lt;div class="p2"&gt; 宽度为屏幕宽度的40%，字体大小默认 &lt;div class="s2"&gt; 字体大小1.2em &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859html &#123; font-size: 32px; /* 320/10 */&#125;body &#123; font-size: 16px; /* 修正字体大小 */ /* 防止页面过宽 */ margin: auto; padding: 0; width: 10rem; /* 防止页面过宽 */ outline: 1px dashed green;&#125; /* js被禁止的回退方案 */@media screen and (min-width: 320px) &#123; html &#123;font-size: 32px&#125; body &#123;font-size: 16px;&#125;&#125;@media screen and (min-width: 481px) and (max-width:640px) &#123; html &#123;font-size: 48px&#125; body &#123;font-size: 18px;&#125;&#125;@media screen and (min-width: 641px) &#123; html &#123;font-size: 64px&#125; body &#123;font-size: 20px;&#125;&#125; noscript &#123; display: block; border: 1px solid #d6e9c6; padding: 3px 5px; background: #dff0d8; color: #3c763d;&#125;/* js被禁止的回退方案 */ .p1, .p2 &#123; border: 1px solid red; margin: 10px 0;&#125; .p1 &#123; width: 5rem; height: 5rem; font-size: 1.2em; /* 字体使用em */&#125; .s1 &#123; font-size: 1.2em; /* 字体使用em */&#125; .p2 &#123; width: 4rem; height: 4rem;&#125;.s2 &#123; font-size: 1.2em /* 字体使用em */&#125; js代码如下 12345678910111213(function (w, d) &#123; var documentElement = document.documentElement function callback () &#123; var clientWidth = documentElement.clientWidth // 屏幕宽度大于780，不在放大 clientWidth = clientWidth &lt; 780 ? clientWidth : 780 documentElement.style.fontSize = clientWidth / 15 + 'px' &#125; document.addEventListener('DOMContentLoaded', callback) window.addEventListener('orientationchange' in window ? 'orientationchange' : 'resize', callback)&#125;)(window, document) 750设计图的情况下使用方法 123div&#123; height:500rem/50;&#125; CSS样式格式化代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154/* css清除默认样式*/html,body,h1,h2,h3,h4,h5,h6,p,ul,li,ol,dl,dt,dd,div,span,a,b,i,strong,em,img,form,input,textarea,table,th,td,section &#123; padding: 0; margin: 0;&#125;html,body &#123; font-family:'黑体', sans-serif; width: 100%; height: 100%; overflow: initial;&#125;body &#123; background: #F9F9F9 !important; color: #333; font-size: 14px; -webkit-overflow-scrolling: touch;&#125;h1,h2,h3,h4,h5,h6 &#123; font-size: 100%; line-height: 100%; font-weight: normal;&#125;li &#123; list-style: none;&#125;a &#123; text-decoration: none; display: inline-block; color: #333; -webkit-tap-highlight-color: rgba(0, 0, 0, 0)&#125;/*a的默认下划线和字体颜色| 移动端点击蓝边*/a:hover &#123; text-decoration: none !important; color: @primary-color ; cursor: pointer;&#125;i,em &#123; font-style: normal;&#125;strong,b &#123; font-weight: normal;&#125;input[type=button],input[type=submit],input[type=file],button &#123; cursor: pointer; -webkit-appearance: none;&#125;/*解决苹果手机默认的背景透明*/input,button,select,textarea &#123; resize: none; outline: none; border: none 0; padding: 0; font-family: '黑体', sans-serif;&#125;input[type="search"] &#123; -webkit-appearance: none;&#125;input::-webkit-search-cancel-button &#123; display: none;&#125;li &#123; list-style: none; vertical-align: top;&#125;/*li里浮动,li不浮动，去3像素bug*/a img &#123; border: 0;&#125;/*a包img：去蓝色边框*/img &#123; vertical-align: middle; width: 100%;&#125;/*a包img：去3像素bug*/table &#123; border-collapse: collapse; font-size: 100%; font-weight: normal;&#125;table,tr,th,td &#123; padding: 0; font-size: 100%; font-weight: normal;&#125;]]></content>
      <categories>
        <category>HTML/CSS Base</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JS插件]]></title>
    <url>%2F2019%2F02%2F27%2Fplugin_base%2F</url>
    <content type="text"><![CDATA[序很早之前就想写一个方法库，用于项目中数据处理，数据验证方面，后来写了一个，使用的是ES6的Class方法，使用import模块化，这就局限于了支持ES6的前提，而且不支持其他模块，无法静态引入，而且很多方法使用繁琐，也不是很满意，就打算研究一下JS插件的一般写法，然后做一下完善； JS插件实现步骤关于构造函数最早写JS插件的时候，用的最多的是构造函数Function，使用方式基本以静态引入为主； 1234567function Plugins()&#123;&#125;Plugins.prototype.add = function()&#123; console.log(this)&#125; 关于闭包我们的plugin对象，是定义在全局域里面的。我们知道，js变量的调用，从全局作用域上找查的速度会比在私有作用域里面慢得多得多。所以，我们最好将插件逻辑写在一个私有作用域中。实现私有作用域，最好的办法就是使用闭包。可以把插件当做一个函数，插件内部的变量及函数的私有变量，为了在调用插件后依旧能使用其功能，闭包的作用就是延长函数(插件)内部变量的生命周期，使得插件函数可以重复调用，而不影响用户自身作用域。故需将插件的所有功能写在一个立即执行函数中： 最开始的if判断是喂了防止命名冲突（最好和开发伙伴定好命名规则，比如每个方法开头标注代表字母等） 在定义插件之前添加一个分号，可以解决js合并时可能会产生的错误问题； undefined在老一辈的浏览器是不被支持的，直接使用会报错，js框架要考虑到兼容性，因此增加一个形参undefined，就算有人把外面的 undefined 定义了，里面的 undefined 依然不受影响； 把window对象作为参数传入，是避免了函数执行的时候到外部去查找。 1234567891011121314;(function (w, undefined) &#123; if (!Plugins) &#123; function Plugins() &#123; &#125; Plugins.prototype.add = function () &#123; console.log(this) &#125; w.Plugins = Plugins; &#125;&#125;)(window) 关于Window以上例子中我把window作为global顶级对象传入插件，但是如果此插件并不是用在浏览器中，比如在node中可以访问到global顶级对象； 1234567891011121314151617(function (global, undefined) &#123; "use strict" //使用js严格模式检查，使语法更规范 var _global; function Plugins() &#123; &#125; Plugins.prototype.add = function () &#123; console.log(this) &#125; // 最后将插件对象暴露给全局对象 _global = (function () &#123; return this || (0, eval)('this'); &#125;()); !('Plugins' in _global) &amp;&amp; (_global.Plugins = Plugins)&#125;()) 关于(0, eval)(&#39;this&#39;) 123var global = (function()&#123; return this || (0, eval)('this');&#125;()) 在这里的(0,eval) 返回的是eval函数，在这里为什么要用(0,eval),当然，正常情况(非IE)下，可以直接使用eval()，但是在部分低版本的ie中，不可以直接运行eval，所以可以使用 (0,eval)； 关于模块化一般项目除了静态引入JS插件以外，还需要需要支持一定模块化规范common.js、AMD、CMD，所以在配置插件的时候也需要注意模块化的设置 为什么需要代码模块化？ 如果是多个人一起开发一个大型的插件,多人合作，肯定会产生多个文件，每个人负责一个小功能，那么如何才能将所有人开发的代码集合起来呢？这是一个讨厌的问题。要实现协作开发插件，必须具备如下条件： 每功能互相之间的依赖必须要明确，则必须严格按照依赖的顺序进行合并或者加载 每个子功能分别都要是一个闭包，并且将公共的接口暴露到共享域也即是一个被主函数暴露的公共对象 以上需求也可能通过按需引入JS实现，比较繁琐，而且不能实现按需加载； 综合以上，需要我们插件也实现模块化的机制,只要判断是否存在加载器，如果存在加载器，我们就使用加载器，如果不存在加载器。我们就使用顶级域对象。 1234567891011121314151617181920212223(function (global, undefined) &#123; "use strict" //使用js严格模式检查，使语法更规范 var _global; function Plugins() &#123; &#125; Plugins.prototype.add = function () &#123; console.log(this) &#125; // 最后将插件对象暴露给全局对象 _global = (function () &#123; return this || (0, eval)('this'); &#125;()); if (typeof module !== "undefined" &amp;&amp; module.exports) &#123; module.exports = Plugins; &#125; else if (typeof define === "function" &amp;&amp; define.amd) &#123; define(function () &#123; return Plugins; &#125;); &#125; else &#123; _global.Plugins = Plugins; &#125;&#125;()) jQuery插件源码在实现插件的基本功能之后，把jquery源码抽出来一部分，主要是通过模块化、顶级对象和以上代码对比； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051(function(global, factory) &#123; //严格模式 "use strict"; /* 判断是否支持common.js，可以理解为判断是否是node环境*/ if (typeof module === "object" &amp;&amp; typeof module.exports === "object") &#123; // 判断顶级对象中是否有document module.exports = global.document ? factory(global, true) : function(w) &#123; if (!w.document) &#123; throw new Error("jQuery requires a window with a document"); &#125; return factory(w); &#125;; &#125; else &#123; factory(global); &#125;&#125;)(typeof window !== "undefined" ? window : this, function(window, noGlobal) &#123; var version = "3.3.1", jQuery = function(selector, context) &#123; return new jQuery.fn.init(selector, context); &#125; jQuery.fn = jQuery.prototype = &#123; jquery: version, constructor: jQuery, &#125; //设置支持AMD规范 if (typeof define === "function" &amp;&amp; define.amd) &#123; define("jquery", [], function() &#123; return jQuery; &#125;); &#125; if (!noGlobal) &#123; window.jQuery = window.$ = jQuery; &#125; return jQuery;&#125;);]]></content>
      <categories>
        <category>JavaScript Advanced</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js中间层项目概览]]></title>
    <url>%2F2019%2F02%2F22%2Fnode_middle%2F</url>
    <content type="text"><![CDATA[解决SEO问题和页面渲染问题； 开发技术架构架构图解 技术讲解Koa作用Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。 与express对比koa是一个比express更精简，使用node新特性的中间件框架，相比之前express就是一个庞大的框架 如果你喜欢diy，很潮，可以考虑koa，它有足够的扩展和中间件，而且自己写很简单 如果你想简单点，找一个框架啥都有，那么先express 团队成本问题，如果他们连express都不会，上来就koa，学习曲线太陡，不合适 目前基于express的快读开发框架需要一段时间迁移到koa bcrypt一个跨平台的文件加密工具。由它加密的文件可在所有支持的操作系统和处理器上进行转移。它的口令必须是8至56个字符，并将在内部被转化为448位的密钥。 Nodemailer是 Node.js 应用程序的一个模块，可以方便地发送电子邮件。该项目于 2010 年开始，至今已经相当稳定，这也是如今大多数 Node.js 用户默认情况下发送邮件的解决方案。 apollo-server一个在nodejs上构建grqphql服务端的web中间件。支持express，koa ，hapi等框架。 HandlebarsJavaScript 一个语义模板库，通过对view和data的分离来快速构建Web模板。它采用”Logic-less template”（无逻辑模版）的思路，在加载时被预编译，而不是到了客户端执行到代码时再去编译， 这样可以保证模板加载和运行的速度。简单的说就是：Handlebars是一个很好的前后端的分离的方案 项目所需介绍Nunjucks中文文档 JavaScript 专用的功能丰富、强大的模板引擎。 Lodash中文文档 一个一致性、模块化、高性能的 JavaScript 实用工具库。 Lodash 通过降低 array、number、objects、string 等等的使用难度从而让 JavaScript 变得更简单。Lodash 的模块化方法 非常适用于： 遍历 array、object 和 string 对值进行操作和检测 创建符合功能的函数 其他 mongodb: 数据库软件 jsonplaceholder：api接口 Postman:接口测试下载软件 svg-captcha:验证码工具]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue生命周期详解]]></title>
    <url>%2F2019%2F01%2F23%2Fvue_lifeCycle%2F</url>
    <content type="text"><![CDATA[new Vue()这时new了一个Vue 的实例对象，此时，就会进入组件的创建过程 init Events&amp;Lifecycle初始化组件、事件和声明周期，当执行完这一步，组件的声明周期函数，就都已经初始化好了，等待依次去调用 beforeCreated这时第一个生命周期函数，此时，组件的data和methods以及dom结构，都还没有初始化，此时什么都做不了 123456789beforeCreate() &#123; console.log('beforeCreate-data:' + this.msg) console.log('beforeCreate-methods:' + this.get) console.log('beforeCreate-dom:' + this.$el)&#125;,// beforeCreate-data:undefined// index.html:30 beforeCreate-methods:undefined// index.html:31 beforeCreate-dom:undefined init injections &amp; reacitvity这个阶段中，正在初始化data和methods中的数据以及方法 created这是组件创建阶段的第二个生命周期，此时组件的data和methods已经可用了，但是页面还没有渲染出来，在生命周期中，我们经常用来调用Ajax请求 123456789created() &#123; console.log("=======================================") console.log('created-data:' + this.msg) console.log('created-methods:' + this.get) console.log('created-dom:' + this.$el)&#125;// created-data:122// index.html:36 created-methods:function () &#123; [native code] &#125;// index.html:37 created-dom:undefined Has ‘el’ option or nothas如果正常有el属性，正常渲染页面，解析执行模板的指令，当所有直径解析完毕之后，我们的模板页面就会渲染到内存中； no如果没有el属性，那么就会等到vm.$mount(el)方法调用之后才会正常执行渲染页面 注意：此时用户依然看不到页面内容 beforeMount当模板在内存中编译完成，会立即执行实例创建阶段的第三个生命周期函数，此时内存中的模板结构，还没有真正渲染到页面上，此时页面上也看不到真实的数据，此时用户看到的只是一个模板页面而已 12345678910beforeMount() &#123; console.log("=======================================") console.log('beforeMount-data:' + this.msg) console.log('beforeMount-methods:' + this.get) console.log('beforeMount-dom:' + this.$el)&#125;// beforeMount-data:122// index.html:42 beforeMount-methods:function () &#123; [native code] &#125;// index.html:43 beforeMount-dom:[object HTMLDivElement] Create vm.$el and replace ‘el’ with it正在把内存渲染好的模板结构，替换到页面上 mounted此刻已经渲染完毕 关于数据更新组件运行的生命周期函数，会根据data的数据变化，有选择的触发0次或者N次 beforeUpdate当执行beforeUpdata运行中声明周期函数的时候，数据肯定是最新的，但是页面上的数据还是旧的 Vitual Dom re-render and patch正在根据最新的data数据，重新渲染模板内容，并把渲染好的模板结构，替换到页面上 updated页面已经完成了更新，此时，data数据是最新的，同时，页面上呈现的数据也是最新的 过程 拿到最新的data数据 根据最新的data数据，在内存中，重新渲染一颗新的DOM树 把旧的页面移除，同时渲染新的DOM树 beforeDestroy当执行此函数的时候，组件即将被销毁，但是组件还是正常可以使用的，data和mehods等数据方法依旧可以调用 destroyed组件已经完成销毁，data和mehods等数据方法不可以用了 声明周期图示]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【持续更新】前端知识汇总]]></title>
    <url>%2F2019%2F01%2F22%2Fdevelop_question%2F</url>
    <content type="text"><![CDATA[参考文章：世界顶级公司的前端面试都问些什么面试集锦：中高级前端大厂面试秘籍，为你保驾护航金三银四，直通大厂(上)面试集锦：JavaScript知识点整理 我们会在开发以及常见面试中遇到一些问题，关于这些问题，个人准备了一个这样的集锦，涉及CSS,JS,常用框架等； CSS盒模型盒模型详解 页面渲染时，dom 元素所采用的 布局模型。可通过box-sizing进行设置。根据计算宽高的区域可分为： content-box (W3C 标准盒模型) border-box (IE 盒模型) padding-box margin-box (浏览器未实现) CSS HackCSS hack详解 什么是CSS hack由于不同厂商的流览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack! CSS hack的原理由于不同的浏览器和浏览器各版本对CSS的支持及解析结果不一样，以及CSS优先级对浏览器展现效果的影响，我们可以据此针对不同的浏览器情景来应用不同的CSS。 CSS hack分类CSS Hack大致有3种表现形式，CSS属性前缀法、选择器前缀法以及IE条件注释法（即HTML头部引用if IE）Hack，实际项目中CSS Hack大部分是针对IE浏览器不同版本之间的表现差异而引入的。 属性前缀法(即类内部Hack)：例如 IE6能识别下划线”“和星号” “，IE7能识别星号” “，但不能识别下划线”“，IE6~IE10都认识”\9”，但firefox前述三个都不能认识。 选择器前缀法(即选择器Hack)：例如 IE6能识别html .class{}，IE7能识别+html .class{}或者*:first-child+html .class{}。 IE条件注释法(即HTML条件注释Hack)：针对所有IE(注：IE10+已经不再支持条件注释)： ，针对IE6及以下版本： 。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。 移动端布局—remrem详解 rem是什么？rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过rem计算的规则是依赖根元素,em是依赖父元素计算。 rem布局原理是，先按定高宽设计出来页面，然后转换为rem单位，配合js查询屏幕大小来改变html的font-size，最终做出所谓的完美自适应。（100%还原） rem原理rem布局的本质是等比缩放，一般是基于宽度； 比如一个750的设计图，我们可以分成50分，每一份为15px，如果一个div宽度要求30px,设置宽度的时候只需要 12html &#123;font-size: 15px&#125;p &#123;width: 2rem&#125; /*30px/15*/ 当然也可以通过js来设置根元素html的字体大小 12345678910111213// 常规情况!(function(doc, win) &#123; var docEle = doc.documentElement, evt = "onorientationchange" in window ? "orientationchange" : "resize", fn = function() &#123; var width = docEle.clientWidth; width &amp;&amp; (docEle.style.fontSize = 20 * (width / 320) + "px"); &#125;; win.addEventListener(evt, fn, false); doc.addEventListener("DOMContentLoaded", fn, false); &#125;(document, window)); 优化方案vw,vh让页面元素随着页面宽度变化，需要一个新的单位x，x等于屏幕宽度的百分之一，css3带来了rem的同时，也带来了vw和vh vw —— 视口宽度的 1/100；vh —— 视口高度的 1/100 —— MDN 缺点 vw的兼容性不如rem好，使用之前要看下 兼容性 Ios 安卓 rem 4.1+ 2.1+ vw 6.1+ 4.4+ 另外，在使用弹性布局时，一般会限制最大宽度，比如在pc端查看我们的页面，此时vw就无法力不从心了，因为除了width有max-width，其他单位都没有，而rem可以通过控制html根元素的font-size最大值，而轻松解决这个问题 其他问题字体的问题字体大小并不能使用rem，字体的大小和字体宽度，并不成线性关系，所以字体大小不能使用rem；由于设置了根元素字体的大小，会影响所有没有设置字体大小的元素，因为字体大小是会继承的我们可以在body上做字体修正，比如把body字体大小设置为16px，但如果用户自己设置了更大的字体，此时用户的设置将失效，比如合理的方式是，将其设置为用户的默认字体大小可以通过修改body字体的大小来实现，同时所有设置字体大小的地方都是用em单位，对就是em，因为只有em才能实现 屏幕过宽一般我们都会设置一个最大宽度，大于这个宽度的话页面居中，两边留白 123var clientWidth = document.documentElement.clientWidth;clientWidth = clientWidth &lt; 780 ? clientWidth : 780;document.documentElement.style.fontSize = clientWidth / 100 + 'px'; 设置body的宽度为100rem，并水平居中 1body &#123; margin: auto; width: 100rem &#125; JavaScript主要是根据项目中常用以及考虑到JavaScript的深度需要，总结一下问题 关于原型链原型链是由原型对象组成，每个对象都有 proto 属性，指向了创建该对象的构造函数的原型，proto 将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链。 属性查找机制: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则输出undefined； 属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: b.prototype.x = 2；但是这样会造成所有继承于该对象的实例的属性发生改变。 ES6主要针对ES6的个人见解 async函数async,await相比于promise的优势优势在于处理then的调用链，能够更清晰准确的写出代码缺点：await将异步代码改造成同步，如果多个异步代码之间没有依赖性却使用了await会导致性能降低 对async，await的理解，内部原理async就是将函数返回值使用Promise.resolve()包裹一下，和then中处理返回值一样，并且async只能搭配await使用await其实就是generator加上Promise的语法糖，且内部实现了自动执行generator]]></content>
      <categories>
        <category>Surround</category>
      </categories>
      <tags>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3]]></title>
    <url>%2F2019%2F01%2F22%2Fcss3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>HTML/CSS Base</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于图片处理的唠唠叨叨]]></title>
    <url>%2F2019%2F01%2F21%2Fdealwith_pic%2F</url>
    <content type="text"><![CDATA[以下代码是以vue语法为主，如果使用其他框架，请更改语法 图片上传并获取图片方法图片上传本方法是获取图片的文件流，通过formData方法处理图片参数以文件流方式传递到后台（同样支持文件）; 为input绑定change事件，并绑定accept 1&lt;input type="file" ref="input" accept="image/gif,image/jpeg,image/jpg,image/png,image/svg" @change="uploadImg($event)"&gt; 通过change方法获取图片 123456789uploadImg(e) &#123; var event = e ? e : window.event; var obj = event.srcElement ? event.srcElement : event.target; //obj.files[0]为获取的图片文件流 // getObjectURL方法上传图片方法 var srcs = this.getObjectURL(obj.files[0]); //清除input的方法，防止change事件不触发 this.$refs.input.value = ""&#125;, 获取上传的图片如果在图片上传之前需要预览图片，可以通过以下方法获取图片，url绑定到img标签即可 1234567891011getObjectURL(file) &#123; var url = null; if (window.createObjectURL != undefined) &#123; url = window.createObjectURL(file) &#125; else if (window.URL != undefined) &#123; url = window.URL.createObjectURL(file) &#125; else if (window.webkitURL != undefined) &#123; url = window.webkitURL.createObjectURL(file) &#125; return url;&#125; 判断图片链接是否有效 场景：如果后台返回图片链接，如果有效则展示，无效的话不展示 原理：通过img标签引入图片，可以通过img的onload（有效）和onerror（无效）回调来区分 注意回调方法是异步的 1234567891011 checkImgExists(imgurl) &#123; var ImgObj = new Image(); ImgObj.src = imgurl; image.onload = function () &#123; return true &#125;; image.onerror = function () &#123; return false &#125;;&#125; 图片压缩图片压缩方法有点长，懒得分了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * * @param &#123;文件&#125; file * @param &#123;配置属性&#125; options * @param &#123;回调函数&#125; callback */loopPhotoCompress(file, options, callback) &#123; options.size = 1;//此处的单位为MB var self = this; var imgtype = 'image/jpeg'; // 用FileReader读取文件 var reader = new FileReader(); // 将图片读取为base64 reader.readAsDataURL(file); reader.onload = function (evt) &#123; var base64 = evt.target.result; // 创建图片对象 var img = new Image(); // 用图片对象加载读入的base64 img.src = base64; img.onload = function () &#123; var that = this, canvas = document.createElement('canvas'), ctx = canvas.getContext('2d'); canvas.setAttribute('width', that.width); canvas.setAttribute('height', that.height); // 将图片画入canvas ctx.drawImage(that, 0, 0, that.width, that.height); // 压缩到指定体积以下（M） if (options.size) &#123; var scale = 0.9; (function f(scale) &#123; if (base64.length / 1024 / 1024 &gt; options.size &amp;&amp; scale &gt; 0) &#123; base64 = canvas.toDataURL(imgtype, scale); scale = scale - 0.1; f(scale); &#125; else &#123; callback(self.convertBase64UrlToBlob(base64, file)); &#125; &#125;)(scale); &#125; else if (options.scale) &#123; // 按比率压缩 base64 = canvas.toDataURL(imgtype, options.scale); callback(self.convertBase64UrlToBlob(base64, file)); &#125; &#125; &#125;&#125; base64转file文件流1234567891011121314151617/** * 将以base64的图片url数据转换为Blob * @param urlData *用url方式表示的base64图片数据 */convertBase64UrlToBlob(urlData, file) &#123; var arr = urlData.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) &#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new File([u8arr], file.name, &#123; type: file.type &#125;);&#125; 图片增加马赛克 获取图片写入到canvas，通过检测鼠标的落下，移动、抬起事件，获取矩形 通过getImageData方法获取图片像素点数组 通过改变数据中像素点的颜色（不同像素点交换颜色）setXY方法 getImageData此方法对于跨域图片，浏览器会进行拦截，服务器需要设置允许跨域访问 文件：图片增加马赛克]]></content>
      <categories>
        <category>JavaScript Base</category>
      </categories>
      <tags>
        <tag>Pic Deal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Date的那些事]]></title>
    <url>%2F2019%2F01%2F21%2Fdealwith_time%2F</url>
    <content type="text"><![CDATA[日期格式化12345678910111213function dateToString(date) &#123; if (date &amp;&amp; date instanceof Date) &#123; var yyyy = date.getFullYear(); var mm = date.getMonth() &lt; 9 ? "0" + (date.getMonth() + 1) : (date.getMonth() + 1); var dd = date.getDate() &lt; 10 ? "0" + date.getDate() : date.getDate(); var hh = date.getHours() &lt; 10 ? "0" + date.getHours() : date.getHours(); var min = date.getMinutes() &lt; 10 ? "0" + date.getMinutes() : date.getMinutes(); var ss = date.getSeconds() &lt; 10 ? "0" + date.getSeconds() : date.getSeconds(); return "".concat(yyyy).concat('-').concat(mm).concat('-').concat(dd).concat('-').concat(ss); &#125; return '';&#125; 模拟moment插件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 格式化时间 */myMoment = (date = new Date().getTime()) =&gt; &#123; this.date = new Date(date) return this;&#125;/** * 输入格式化格式 */formate = (formatStr = 'YYYY-MM-DD HH:mm:ss') =&gt; &#123; const date = this.date const year = date.getFullYear() const month = date.getMonth() + 1 const day = date.getDate() const week = date.getDay() const hour = date.getHours() const minute = date.getMinutes() const second = date.getSeconds() return formatStr.replace(/Y&#123;2,4&#125;|M&#123;1,2&#125;|D&#123;1,2&#125;|d&#123;1,4&#125;|H&#123;1,2&#125;|m&#123;1,2&#125;|s&#123;1,2&#125;/g, (match) =&gt; &#123; switch (match) &#123; case 'YY': return String(year).slice(-2) case 'YYY': case 'YYYY': return String(year) case 'M': return String(month) case 'MM': return String(month).padStart(2, '0') case 'D': return String(day) case 'DD': return String(day).padStart(2, '0') case 'd': return String(week) case 'dd': return weeks[week] case 'ddd': return '周' + weeks[week] case 'dddd': return '星期' + weeks[week] case 'H': return String(hour) case 'HH': return String(hour).padStart(2, '0') case 'm': return String(minute) case 'mm': return String(minute).padStart(2, '0') case 's': return String(second) case 'ss': return String(second).padStart(2, '0') default: return match &#125; &#125;)&#125; 获取当前日期的周边今天12345function showToDay() &#123; var Nowdate = new Date(); M = Number(Nowdate.getMonth()) + 1 return Nowdate.getFullYear() + "-" + M + "-" + Nowdate.getDate();&#125; 明天1234567function showTomorrow() &#123; var tom = new Date(); tom.setDate(tom.getDate() + 1); M = Number(tom.getMonth()) + 1 return tom.getFullYear() + "-" + M + "-" + tom.getDate();&#125; 本周第一天123456function showWeekFirstDay() &#123; var Nowdate = new Date(); var WeekFirstDay = new Date(Nowdate - (Nowdate.getDay() - 1) * 86400000); M = Number(WeekFirstDay.getMonth()) + 1 return WeekFirstDay.getFullYear() + "-" + M + "-" + WeekFirstDay.getDate();&#125; 本周最后一天1234567function showWeekLastDay() &#123; var Nowdate = new Date(); var WeekFirstDay = new Date(Nowdate - (Nowdate.getDay() - 1) * 86400000); var WeekLastDay = new Date((WeekFirstDay / 1000 + 6 * 86400) * 1000); M = Number(WeekLastDay.getMonth()) + 1 return Nowdate.getFullYear() + "-" + M + "-" + WeekLastDay.getDate();&#125; 本月第一天123456function showMonthFirstDay() &#123; var Nowdate = new Date(); var MonthFirstDay = new Date(Nowdate.getFullYear(), Nowdate.getMonth(), 1); M = Number(MonthFirstDay.getMonth()) + 1 return MonthFirstDay.getFullYear() + "-" + M + "-" + MonthFirstDay.getDate();&#125; 本月最后一天1234567function showMonthLastDay() &#123; var Nowdate = new Date(); var MonthNextFirstDay = new Date(Nowdate.getFullYear(), Nowdate.getMonth() + 1, 1); var MonthLastDay = new Date(MonthNextFirstDay - 86400000); M = Number(MonthLastDay.getMonth()) + 1 return MonthLastDay.getFullYear() + "-" + M + "-" + MonthLastDay.getDate();&#125;]]></content>
      <categories>
        <category>JavaScript Base</category>
      </categories>
      <tags>
        <tag>DateTime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的面向对象]]></title>
    <url>%2F2019%2F01%2F18%2Foop_base%2F</url>
    <content type="text"><![CDATA[面向对象（oop）Class类可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已 基本使用123456789class Person &#123; constructor(age, name) &#123; this.age = age; this.name = name; &#125;&#125;console.log(new Person(12, '张三')) 构造器–constructor 构造器：每一个类中都有一个构造器，如果我们程序员没有手动指定构造器，那么可以认为类内部有一个隐形的，看不见的空构造器类似于constructor(){} 作用：就是每当new这个类的时候，必然会优先执行构造器中的代码 静态方法&amp;静态属性类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用 构造函数 123456function PersonC()&#123;&#125;PersonC.a = 1;PersonC.b = function()&#123; &#125; Class类 12345678910class Person &#123; constructor(age, name) &#123; this.age = age; this.name = name; &#125; static a = 12 static b()&#123; &#125;&#125; 静态方法或者静态属性无法通过实例之后的对象来调用，因为这是挂载到类或者构造函数上面的，只能通过Person.a或者PersonC.a来获取或者调用 实例方法&amp;实例属性通过new出来的实例，访问到的属性或者方法，叫做实例方法或者实例对象 1234567891011121314151617//构造函数function PersonC()&#123;&#125;PersonC.prototype.c = function()&#123;&#125;//class类class Person &#123; constructor(age, name) &#123; this.age = age; this.name = name; &#125; c()&#123; &#125;&#125; 继承Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 基本使用1234567891011class Person &#123; constructor(age, name) &#123; this.age = age; this.name = name; &#125;&#125;class Chiness extends Person&#123;&#125;console.log(new Chiness(12,'李四')) 关于super方法在以上代码中如果我们在Chiness中值只调用配置constructor函数，就会报错 1234567891011121314151617class Chiness extends Person&#123; constructor()&#123; &#125;&#125;// missing super() call in constructorclass Chiness extends Person&#123; constructor()&#123; super() &#125;&#125;console.log(new Chiness(12,'李四'))//Chiness &#123;age: undefined, name: undefined&#125; 但是如果我们调用了，不会报错，但是实例对象中的age和name属性的值为undefined 就会提醒我们调用super方法 为什么必须调用super? 答：如果一个子类，通过extends关键字继承了父类，那么，子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。 根据以上说法，如果想在构造器中使用this也必须是在super调用之后 super方法是什么? 答:super是一个函数，而且它是父类的构造器，子类中的super就是其中父类中，constructor构造器的一个引用 为什么调用之后实例对象中的age和name属性的值为undefined? 答:super是一个函数，而且它是父类的构造器,所以如果只调用，不传递参数，所以实例对象中的age和name属性的值为undefined 正确用法 1234567class Chiness extends Person&#123; constructor(age,name)&#123; super(age,name) &#125;&#125;console.log(new Chiness(12,'李四')) 关于子类独有属性123456789class Chiness extends Person&#123; constructor(age,name,id)&#123; super(age,name) this.id = id; &#125;&#125;console.log(new Chiness(12,'李四',12))]]></content>
      <categories>
        <category>JavaScript Advanced</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bug第一弹]]></title>
    <url>%2F2019%2F01%2F17%2Fbugs_1%2F</url>
    <content type="text"><![CDATA[SSO拦截登陆后页面报错功能场景校验登录通过cookie中特定cookie，如果没有，所有请求会报403，通过axios的钩子函数检测异常跳转到指定登录页面 12345678910111213141516171819// 请求后的钩子函数HTTP.interceptors.response.use(function (config) &#123; // console.log(location.href.split('?')[0] + '?' + encodeURIComponent(location.href.split('?')[1])) return config;&#125;, function (error) &#123; if (error.response.status === 401) &#123; Cookie.remove('userData') localStorage.clear(); sessionStorage.clear(); console.log(location.href) if (error.response.data.indexOf('jumpto') === -1) &#123; location.href = error.response.data + '&amp;jumpto=' + location.href &#125; else &#123; location.href = error.response.data &#125; &#125; return Promise.reject(error)&#125;) 问题原因在指定jumpto跳转，后天未将参数中&amp;符号后面的参数带来，导致页面参数不足报错 解决方法解析url路径？参数，通过incode方法解析，去除&amp;符号，页面在通过decode方法解析 1234567891011121314151617181920212223// 请求后的钩子函数HTTP.interceptors.response.use(function (config) &#123; // console.log(location.href.split('?')[0] + '?' + encodeURIComponent(location.href.split('?')[1])) return config;&#125;, function (error) &#123; if (error.response.status === 401) &#123; Cookie.remove('userData') localStorage.clear(); sessionStorage.clear(); console.log(location.href) if (error.response.data.indexOf('jumpto') === -1) &#123; if (location.href.indexOf('/approval') &gt;= 0) &#123; location.href = error.response.data + '&amp;jumpto=' + location.href.split('?')[0] + '?' + encodeURIComponent(location.href.split('?')[1]); &#125; else &#123; location.href = error.response.data + '&amp;jumpto=' + location.href &#125; &#125; else &#123; location.href = error.response.data &#125; &#125; return Promise.reject(error)&#125;) web和app共有页面无法区分设备功能场景移动端和app端有相同功能页面，需要判断当前设备，并打开相应页面 代码12345678910111213141516171819common.judegWebOrApp = () =&gt; &#123; var userAgentInfo = navigator.userAgent.toLowerCase(); var Agents = ["zhushou", "android", "iphone", "symbianos", "windows phone", "ipad", "ipod"]; var flag = true; for (var i = 0; i &lt; Agents.length; i++) &#123; if (userAgentInfo.indexOf(Agents[i]) &gt; 0) &#123; flag = false; break; &#125; &#125; var params = location.href.split('?')[1]; var nowPage = location.href.indexOf('app'); console.log(flag,nowPage) if (flag &amp;&amp; nowPage &gt;= 0) &#123;//web端 location.href = "/web/approval?"+params; &#125; else if (!flag &amp;&amp; nowPage &lt; 0) &#123;//app端 location.href = "/app/approval?" + params; &#125;&#125; 通过app的webview加载H5页面在iphone6s和iphoneSE中吸底偶尔不出现bug原因在浏览器中测试没有问题，经过测试，在webview中，获取的高度iphone6s和iphoneSE获取的页面高度比真实高度高64px，导致吸底消失 解决措施判断是否是iphone手机，并判断宽度，符合iphone6s以及iphonese尺寸的，采取设置top值而不是botom值 12345678910111213var docEl = document.clientWidth ? document : document.documentElement;var height = docEl.clientHeight;var width = docEl.clientWidth;var reduce = 98 / 30 * width / 25;setTimeout(() =&gt; &#123; this.xiBot = this.$refs.botTab; if(!this.xiBot) return; if (width == 320) &#123; this.xiBot.style.top = 548 - reduce + 'px'; &#125; else if (width == 375 &amp;&amp; height &lt; 690) &#123; this.xiBot.style.top = 647 - reduce + 'px'; &#125;&#125;, 500); webview中ios系统页面不出现具体场景在app中内嵌网页，安卓端没问题，在ios上会出现偶数次打开页面空白现象，但是页面中去除本身app头部的方法已经执行，也就是说页面正常加载，但是页面呈现空白； bug原因在vue的router.beforeEach钩子函数中调用了函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* 路由拦截（钩子）*/router.beforeEach((to, from, next) =&gt; &#123; //重置到页面顶端 document.body.scrollTop = 0; document.documentElement.scrollTop = 0; //去除桔子堆头部 api.appDelHeader(); //判断路径是否是403和选择地址页面 if (to.path === '/403' || to.path === '/FoodAddress') &#123; next(); return; &#125; //判断是否校验checkCode if (api.mall.on) &#123; login.checkLogin(() =&gt; &#123;//失败时候的回调 next('/403'); return; &#125;, () =&gt; &#123;//成功的回调 if (!api.checkUA() &amp;&amp; api.mall.isCheckUA) &#123; next('/403'); &#125; else if (localStorage.getItem('arriveAddress') &amp;&amp; localStorage.getItem('menuId')) &#123; // 已选择了默认区域 next(); &#125; else &#123; console.log('重新获取地址') getArea();//就是这个方法，实参未传 &#125; &#125;); &#125;&#125;)//获得区域列表const getArea = function (next, to) &#123; api.get(&#123; data: &#123; flag: 1 &#125;, url: "/area/queryList", object: Vue, errorIfo: "获取区域失败", then: (data) =&gt; &#123; // data = null; if (data &amp;&amp; data.menuId &amp;&amp; data.arriveAddress) &#123; localStorage.setItem('menuId', data.menuId); localStorage.setItem('arriveAddress', data.arriveAddress) localStorage.setItem('floorId', data.floorId)//localStorage保存楼层信息 if (to.path == '/confirmPrepareMeal') &#123; next(); return; &#125; else &#123; next('/HomeIndex'); &#125; &#125; else &#123; next('/FoodAddress'); &#125; &#125; &#125;)&#125; 按照上面问题应该导致报错，但是web端测试没问题，安卓没问题，ios偶尔出现，很奇怪 时间控件国际化无法重新渲染问题场景时间控件可以使用中英文，但是一经渲染，后期无法局部更新，导致点击切换语言按钮时候无法更改控件内容 解决措施检测中英文切换操作，采用if重新渲染时间控件 123456789watch: &#123; '$i18n.locale': function (value) &#123; this.dataPicker = false; setTimeout(() =&gt; &#123; this.dataPicker = true; this.showData = this.$t('message.myAppoint.today'); &#125;, 10); &#125;,&#125;, ios时间处理失效问题场景提交表单需要校验时间，如果时间小于当前时间，则默认取当前时间，此时需要时间戳对比 12345678910111213141516171819202122232425//选择时间完成chooseTime(time) &#123; this.cancelTime(time); this.modalData.timeModal = false; this.initialCache("ok");&#125;,//控制时间大小cancelTime(time) &#123; if (this.setTimeToSeconds(time) - this.setTimeToSeconds() &gt; 1000) &#123; this.cacheData.visitingTime = time; &#125; else &#123; this.cacheData.visitingTime = new Date(); &#125;&#125;,//设置时间setTimeToSeconds(time) &#123; // var seconds = this.$moment(time).format('YYYY-MM-DD HH:mm'); // return parseInt(new Date(seconds).getTime()); if (time) &#123; return new Date(time).getTime(); &#125; else &#123; return new Date().getTime(); &#125;&#125;, bug原因new Date(‘时间字符串’)，ios对于时间字符串格式支持较少，不支持2018-02-02此格式的数据，支持/不支持-，导致时间戳校验失败 12345678910111213141516171819202122232425262728//选择时间完成chooseTime(time) &#123; console.log(time) time = this.$moment(time).format('YYYY/MM/DD HH:mm:ss') console.log(time) this.cancelTime(time); this.modalData.timeModal = false; this.initialCache("ok");&#125;,//控制时间大小cancelTime(time) &#123; if (this.setTimeToSeconds(time) - this.setTimeToSeconds() &gt; 1000) &#123; this.cacheData.visitingTime = time; &#125; else &#123; this.cacheData.visitingTime = new Date(); &#125;&#125;,//设置时间setTimeToSeconds(time) &#123; // var seconds = this.$moment(time).format('YYYY-MM-DD HH:mm'); // return parseInt(new Date(seconds).getTime()); if (time) &#123; return new Date(time).getTime(); &#125; else &#123; return new Date().getTime(); &#125;&#125;, 超小字符实现方式问题场景设计图要求一个按钮字体大小为10px，但是谷歌浏览器最小字符为12px 实现场景12345678910.repeat-post &#123; border: 1px solid #FC9153; border-radius: 4px; background-color: #fff; height: 25px; font-size: 12px; width: 65px; color: #FC9153; transform: scale(.8,.9);//采用缩放属性实现 transform-origin: left; 安卓键盘遮挡输入框问题场景安卓在获取焦点弹起键盘会自动将也页面上滑，将input框置于可视位置，但是如果body有滚动条的情况下，则input框位置靠下就会被遮挡 解决措施在input获取焦点的情况下现将页面上移到顶部 12345//滚动条到初始状态scollTopZero() &#123; document.body.scrollTop = 0; document.documentElement.scrollTop = 0;&#125;, 取餐时间内无法取餐问题场景正常订餐时间是00：00到下午16：30，但是在0点到8点区间无法点餐；问题原因：后台返回的当前时间currentDate是一个日期字符串，与北京时区不同，有8个小时的时间差，前台处理的时候只是取了日期，导致当天8点之前的日期是昨天的时期 解决措施123456Gray.prototype.toSeconds = function (time, currentTime) &#123; time = moment(time).format('HH:mm:ss'); currentTime = moment(currentTime).format('YYYY/MM/DD'); var time2 = new Date(currentTime + ' ' + time).getTime(); return time2;&#125; 显示时间和取餐时间不一致问题场景后台提示的下单时间是00：00到下午4：30 在EP部分有一个的电脑时间显示有误，其他人没有问题 1Thu Mar 22 2018 21:21:47 GMT+0800 (中国标准时间) 解决措施导致此问题原因为该人电脑时区设置的是美国，导致浏览器解析new Date的时候和正常时区不一致将电脑时区调整好即可 IOS系统中div盒子内设置滚动条，偶尔会滑动失效问题场景在餐品页面内，有餐品列表，偶尔会出现滑动失效的问题，在苹果手机 解决措施 采用body整体布局 使用iscroll插件解决 将此盒子设置为fixed定位 iphonx的兼容问题问题场景一个侧边栏，点击从右侧划出的时候iphonex底部有空白，只有这个是这样的 解决措施布局问题，原来次侧边栏和遮挡层在一个div中，点击的时候显示此div，并给遮挡层和侧边栏加入动画效果；现在取消外层div即可]]></content>
      <categories>
        <category>Bugs</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【持续更新】关于Hexo优化]]></title>
    <url>%2F2019%2F01%2F16%2Fabout_hexo%2F</url>
    <content type="text"><![CDATA[基本命令 hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 增加站内搜索功能安装插件在自己博客根目录下（我的目录：D:\workspace\hexo），执行如下命令 1cnpm install hexo-generator-searchdb --save 修改站点配置文件修改根目录下的_config.yml（我的目录：D:\workspace\hexo_config.yml），在最底部添加如下配置 12345search: path: search.xml field: post format: html limit: 10000 修改主题配置文件修改主体下的themes\next_config.yml配置文件（我的目录：D:\workspace\hexo\themes\next_config.yml），搜索local_search，修改enable为true 1234567local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 预览效果开启本地server123hexo cleanhexo ghexo s 增加博客置顶功能（自定义排序）修改node_modules下代码找到node_modules/hexo-generator-index/lib/generator.js文件 将内部代码替换成 1234567891011121314151617181920212223242526272829303132'use strict';var pagination = require('hexo-pagination');module.exports = function(locals) &#123; var config = this.config; var posts = locals.posts.sort(config.index_generator.order_by); posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; var path = config.index_generator.path || ''; return pagination(path, posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 使用在文章添加 top 标签可以设置置顶顺序顺序根据top的值来决定 123456---title: 文章名date: 文章发布时间tags: 文章标签top: 100(文章置顶)--- Next主题设定代码高亮格式需要改动的有hexo的配置文件_config.yml，以及next主题的配置文件themes/next/_config.yml文件 更改hexo的配置文件查找highlight关键字，更改一下属性为true12345highlight: enable: true line_number: true auto_detect: true tab_replace: 更改next主题配置文件搜索highlight_theme关键字，这个属性有四个值： normal ：默认值 night ：黑色 night eighties ：个人感觉跟第二个差不太多 night blue ： 底部是蓝色，跟sublime text3默认配色差不多 night bright ： 有点闪瞎眼的感觉 具体使用哪个看个人喜好吧，本人night 增加显示文章更新时间在next主题的配置文件themes/next/_config.yml文件中搜索post_meta关键字，将属性updated_at该为true 12345post_meta: item_text: true created_at: true updated_at: true categories: true]]></content>
      <categories>
        <category>Surround</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识React]]></title>
    <url>%2F2019%2F01%2F08%2Fn_reactBase%2F</url>
    <content type="text"><![CDATA[React简介 React起源于Facebook的内部项目，因为该公司对市场上所有的JavaScript MVC框架，都不满意，就决定自己写一套，用来架设Instagram(照片交友)的网站，做出来以后，发现这套东西很好用，就在2013年5月开源了； Angular1 2009年谷歌 由于React的设计思想独特，属于革命性的创新，性能出众，代码逻辑却非常简单，所以，越来越多的人开始关注和使用，认为他可能将来是Web开发的主流工具 清楚两个概念 library（库）：小而巧的库，有点事船小好调头，可以很方便的从一个库切换到另外的库，但是代码几乎不会改变； framework（框架）：大而全的是框架，框架提供了一整套的解决方案，所以，如果在项目中间，想切换到另外的框架，往往是比较困难的； 前端的三大主流框架 Angular.js：出来的较早的前端框架，学习曲线比较陡，NG1学起来比较麻烦，NG2-NG5开始，进行了一系列的改革，也提供了组件化开发的概念，从NG2开始，也支持使用了TS进行编辑； Vue.js：最火（关注的人比较多）的一门前端框架，它是中国人开发的，对我们来说，文档比较友好一些； React.js:最流行（用的人比较多）的一门框架，因为它的设计很优秀； React与Vue的对比组件化方面 什么是模块化：从代码的角度来进行分析的，把一些可复用的代码，抽离为单个的模块，便于项目的维护和开发； 什么是组件化：是从UI界面的角度来进行分析的，把一些可复用的UI元素，抽离为单独的组件，便于醒目的维护和开发； 组件化的好处：随着项目规模的增大，手里的组件越来越多，很方便的能把现有的组件，拼接为一个完整的页面； Vue是如何实现组件化的：通过.vue文件； React如何实现组件化：一般都是通过JS来实现的 开发团队方面 React是由FaceBook前端官方团队进行维护和更新的，因此，React的维护开发团队，技术实力比较雄厚= Vue：第一版，主要是由作者尤雨溪专门进行维护的，当Vue更新到2.x版本之后，也有了以尤雨溪为主的开源小团队，进行维护和开发 社区方面 在社区方面，React由于诞生的比较早，所以社区比较强大，一些常见的问题，坑，最优的解决方案，文档，博客，在社区中都是很方便的就能找到； Vue是近两年才火起来的，所以他的社区性对于React来说要小一些，可能有的一些坑，没人踩过； 移动APP开发体验方面 Vue，结合Weex这门技术，提供了迁移到移动端APP开发的体验 React 结合ReactNative也提供了无缝迁移到移动App的开发体验 为什么要学习React 设计很优秀，一切基于JS并且实现了组件化的思想 开发团队实力强悍，不必担心断更的情况； 社区强大，很多问题都能找到直接的解决方案 提供了无缝转到ReactNative的开发体验，让我们的技术能力得到了拓展，增强了我们的核心竞争力 很多企业中，前端项目的技术选型采用的是React.js React中的几个核心概念虚拟DOM（Vitual Document Object Model） Dom的本质 浏览器中的概念，用JS对象来表示页面上的元素，并提供了操作DOM对象的API； React中的虚拟DOM 是框架中的概念，是程序员用JS对象来模拟页面中的DOM和DOM嵌套； 虚拟DOM的目的 为了实现页面中，DOM元素的高效更新 Dom和虚拟DOM的区别 DOM：浏览器中提供的概念，用JS对象，表示页面中的元素，并提供了操作元素的API 虚拟DOM：是框架中的概念，是开发框架的程序员，手动用JS对象来模拟DOM元素和嵌套关系； 本质：用JS对象来模拟DOM元素和嵌套关系 目的：是为了实现页面元素的高效更新； Diff算法 tree diff 新旧两颗DOM树，逐层对比的过程，就是Tree Diff,当整颗DOM逐层对比完毕，则所有需要被按时更新的元素，必然能够找到 component diff 在进行Tree Diff的时候，每一层，组件级别的对比，叫做Component Diff; 如果对比前后，组件的类型相同，则暂时认为此组件不需要被更新； 如果对比之后，组件类型不同，则暂时认为此组件不需要被更新 element diff 在进行组件对比的会后，如果两个组件类型相同，则需要进行元素的对比，这叫做element diff； 创建基本的webpack4.x项目 运行npm init -y 快速初始化项目 在根目录创建src源代码以及dist产品目录 在src下创建index.html和main.js(入口文件) 执行命令安装依赖 12cnpm i webpack wepack-cli webpack-dev-server html-webpack-plugin -D 新建 webpack.config.js 123456789101112131415const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: "development", entry: "./src/index.js", output: &#123; path: __dirname, filename: './dist/bundle.js' &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: "./src/index.html" &#125;) ],&#125; 执行命令 webpack-dev-server JSX语法JSX语法就是符合xml规范的JS语法，语法格式相对来说，要比HTML严谨的多 使用jsx语法 安装babel插件 123cnpm i babel-core babel-loader babel-plugin-transform-runtime babel-preset-env babel-preset-stage-0 -Dcnpm i babel-loader@7.1.5 -D 安装能够识别转换jsx的包 1cnpm i babel-preset-react -D 新建.babelrc 1234&#123; "presets":["env","stage-0","react"], "plugins":["transform-runtime"]&#125; 配置 webpack.config.js 123456789module:&#123; rules:[ &#123; test:/\.js|jsx$/, use:'babel-loader', exclude:/node_modules/ &#125; ]&#125; jsx注意事项 jsx语法本质:并不是直接把jsx渲染到页面上，而是内部先转换成了createElement的形式，在渲染的 在jsx中混合写入js表达式：在jsx语法中，要把js代码写到{}中 在jsx中添加类名：使用className来替代class 在jsx中为label添加for属性：使用htmlFor 在jsx语法中，标签必须成对出现，如果是单标签，则必须自闭 当编译引擎，在编译jsx代码的时候，如果遇到了&lt;就会把它当做html代码去编译，如果遇到了{}就会作为普通js代码去编译 React中创建组件使用构造函数来创建组件声明组件123456function Hello(props)&#123; //注意，不论在vue还是react中，组件props永远都是只读的，不能被重新赋值 return &lt;div&gt;HELLO--&#123;props.name&#125;--&#123;props.age&#125;&lt;/div&gt;&#125; 使用组件12&lt;Hello &#123;...li&#125;&gt;&lt;/Hello&gt; 注意事项 组件名称必须大写 组件传参可以使用...展开运算符进行传参 可以将组件封装到单独的js文件中，但是必须引入React对象 关于路径配置 如果引入文件需要省略后缀名可以在webpack中做如下配置 1234resolve:&#123; extensions:['.js','.jsx','.json'],//表示，这几个文件的后缀名可以省略不写，会按照书写顺序来解析&#125;, 关于引用路径中的@符号 123alias:&#123; '@':path.join(__dirname,'./src')//这样，@就表示项目根目录中src的这一层路径&#125; 使用Class类来创建组件基本使用123456789101112class Movie extends React.Component&#123; render()&#123; return &lt;div&gt;movie组件&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;div&gt; &lt;Movie&gt;&lt;/Movie&gt;&lt;/div&gt;,document.getElementById('app')); 传参组件内可以直接通过this.props接受父组件传递的参数 12345678910class Movie extends React.Component&#123; render()&#123; return &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;div&gt; &lt;Movie &#123;...li&#125;&gt;&lt;/Movie&gt;&lt;/div&gt;,document.getElementById('app')); 状态这个this.state就相当于vue中的data(){return{}}状态和props相比，是可以更改的 123456789101112131415161718class Movie extends React.Component&#123; constructor()&#123; super(); this.state=&#123; msg:"大家好" &#125; &#125; render()&#123; return &lt;div&gt;&#123;this.props.name&#125;---&#123;this.state.msg&#125;&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;div&gt; &lt;Movie &#123;...li&#125;&gt;&lt;/Movie&gt;&lt;/div&gt;,document.getElementById('app')); 两种组件方式的对比 注意：使用class关键字创建的组件，有自己的私有数据this.state和生命周期注意：使用function创建的组件，只有props，没有自己的私有属性和声明周期 用构造函数创造出来的组件叫做无状态组件 用class关键字创造出来的组件，叫做有状态组件 什么情况下使用有状态组件？什么情况下使用无状态组件？ 如果一个组件需要有自己的私有数据，推荐使用class 如果一个组件不需要有私有数据，则推荐使用构造函数 React官方说，无状态组件，由于没有自己的state和声明周期，所以运行效率会比有状态组件稍微高一些 有状态组件和无状态组件之间的本质区别就是：有无state属性，有无声明周期函数 组件中的props和state/data之前的区别 props中的数据都是外界传递进来的 state、data中的数据，都是组件私有的； props中的数据都是只读，不能重新赋值 state/data中的数据，都是可读可写的 CSS模块化CSS行内式1&lt;h1 style=&#123;&#123;color:'red',fontWeight:200&#125;&#125;&gt;&lt;/h1&gt; 启用css-modules 修改webpack.config.js这个配置文件，为css-loader添加参数 12&#123;test:/\.css$/,use:&#123;'style-loader','css-loader-modules&#125;&#125;//为.css后缀名的样式表启动CSS模块化= 在需要的组件中，import 导入样式表，并接口模块化的CSS样式对象 1import cssObj from '../css/CmtList.css' 在需要HTML标签上，使用className指定模块化的样式 其他 案例 React中绑定事件的注意点 使用ref获取DOM元素应用和vue差不多，vue为页面上的元素提供了ref的属性，如果想要获取元素引用，则需要this.$refs引用名称 在React中，也有ref如果获取元素的应用this.$refs应用名称 组件的生命周期]]></content>
      <categories>
        <category>JavaScript Advanced</category>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Ne</tag>
        <tag>MVVM</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玲珑金管家-交接文档]]></title>
    <url>%2F2018%2F12%2F12%2Fl_back%2F</url>
    <content type="text"><![CDATA[项目构建实现方式通过vue-cli实现基本项目的搭建 自定义配置方面打包命令区分环境 package.json中设置打包命令 1"uat": "node build/uat.js", 新建打包配置文件 在webpack.prod.conf配置不同的环境变量 在config里面新建相对应的环境变量 1234'use strict'module.exports = &#123; NODE_ENV: '"uat"'&#125; 在项目中使用process.env.NODE_ENV来获取不同的环境变量； 配置代理地址 在config/index.js里面配置 配置方式 1234567891011proxyTable: &#123; '/hyacp': &#123; // '*': &#123; target: 'https://yunyingtest.huanyueguoji.com', // target: 'http://192.168.1.168:8091/', changeOrigin: true, pathRewrite: &#123; '^/hyacp': '/hyacp' &#125; &#125;&#125;, 基本作用 用于请求后台数据==》调用接口 解决可能会存在的跨域问题； vue相关配置vue的use方法1Vue.use(iView) 基本原理就是通过模块化外放一个变量，内置有一个install方法，vue调用use方法的时候，可以理解为调用了install，并且将vue实例作为实参传递进去 12345export default &#123; install: function(Vue) &#123; &#125;&#125; axios的相关配置 通过axios的create方法统一配置axios的配置项 通过promise封装axios来区别后天返回的成功或失败(在状态值为200的成功) 在axios的请求钩子函数中统一处理请求数据 路由此项目除了登录页，其他页面都是有相同的菜单栏，所以使用路由嵌套的方式在app.vue中为1级路由；在home.vue中为2级路由； 关于vuex 数据共享； 数据发生改变之后，凡是用到这个数据的地方都会发生改变； 在咱们项目中vuex的数据：menu的层级数据； vuex使用步骤 声明实例化 12345678Vue.use(Vuex);export default new Vuex.Store(&#123; state, getters, actions, mutations,&#125;) 在vue实例化的时候挂载到vue 1234567const vm = new Vue(&#123; el: '#app', router, store, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 关于四个属性 status：存放变量（状态） mutations：存储更改变量的方法 action：涉及到异步； 获取变量 1234567891011import &#123; mapState, mapMutations, mapGetters, mapActions &#125; from 'vuex' computed: mapState(&#123; power: state =&gt; state.power, shrinked: state =&gt; state.shrinked, tabData: state =&gt; state.tabData &#125;), //通过this.power获取到相应变量 computed: &#123; ...mapState(['pSwiperModal', 'pSwiperPicList']) &#125;, 更改变量（状态）通过mapMutations等方法将函数挂载到method下面就可以了直接调用了 1234567...mapMutations([ 'setPowerM', 'pathPushM', 'setTabList', 'setTabChoosed', 'setPermList' ]), 后台管理系统home.vuehome文件主要有layout.vue组成，包括左侧菜单，右侧头部，右侧主要内容，这些主要有插槽来实现的 vue插槽 确定插槽位置 1&lt;slot name='logo'&gt;&lt;/slot&gt; 设置插槽的主要内容template、组件、div都可以作为插槽，主要设置slot属性即可12&lt;e-menu slot='menu' :openNames='openNames'&gt;&lt;/e-menu&gt; 左侧菜单 这个是有ivew的menu功能实现的 最多实现三级菜单 数据由后台接口或者menu.js的all属性（关闭权限之后）提供 数据渲染步骤 在router/index.js中判断权限开关是否打开 打开的情况下请求接口获取权限list数据，使用方法分出层级结构，将数据赋值给menu.js中的list属性 在关闭的情况下，直接获取menu.js的all属性的值，赋值给menu.js的list属性 在home.vue中获取menu.js的值并通过vuex保存； 在menu.vue中获取vuex中的数据，渲染页面 menu.vue需求 在右侧打开一系列菜单 保存菜单中的操作； 实现 新建一个vue文件(menu.vue)用来展示选项卡； 新建一个list数据(vuex)用来存放选项卡数据； 新建一个标志位用来判断当前那个选项卡展示(vuex:choosed)； 点击菜单需要为list增加数据并且改变标志位的值； 获取点击菜单的key判断在一开打的选项卡中有无该key值 有，直接将choosed的值改为该key值； 没有，将list中push该菜单，并且改变choosed的值； 不管又或者没有，都需要获取该菜单的fakId来记录哪一个菜单被打开(openNames)； 点击关闭选项卡功能的时候，为list删除数据并且改变标志位的值； 获取点击的选项卡的index值； 通过方法从list数据中删除该选项卡； 判断如果删的此index还在选中此index值 如果index值不在，选中index-1的值； 需要在本地以及vuex中缓存数据； 删除也好或者增加也好都是通过调用vuex的方法来实现的 并且更改vuex数据的同时更改session中的数据； 在session中存数据的目的是页面刷新之后能够记录打开的选项卡 在home.vue中会先去session中获取数据然后存储到vuex中 在展示当前选中组件的时候，需要找一个文件注册所有的组件:config/components.js 在展示选项卡标题部分需要对于超出页面宽度的滑动处理； 点击选项卡改变显示 点击选项卡获取此key值fakid 然后改变choosed的值和fakId来记录哪一个菜单被打开 阻止架构 权限管理 负责的是所有的菜单，按钮，接口的访问权限 角色管理 权限匹配到每个角色身上 员工管理 匹配相应的角色和部门 部门管理 有一个城市的属性 作用是为每一个员工增加一个城市的属性 风控管理整个权限控制 菜单是由后台接口返回的权限list数据+breadcrumbs.js的本地配置来实现的 首先从后台获取数据之后做层级处理 渲染左侧菜单 打开以及关闭选项卡的时候，是获取到点击的目录key值，循环breadcrumbs.js数据，找到相同key值push到tabData.list中 breadcrumb数据中有一个action用来区分相同组件不同菜单的； 打开风控详情部分 这个不同于菜单，这个页面是不存在与权限树中的 当打开多个详情页面时，使用由一些id组成的对象转化的字符串来作为选中的key值； 列表的按钮以及详情中的tab权限控制 在menu.js中为风控页面配置相应的key值 循环遍历后台返回的权限树，新建一个由所有权限key组成的list； 当我们判断该按钮或者tab菜单是否展示的时候，首先找到这个菜单或者tab相对应的key，然后去list去找，有，展示，没有则不展示 详情-审核决策页面 除了上述说的由后台返回的list还有在不同情况下展示按钮的控制 主要是由detailStatus来控制的 实地和背调操作 先用接口获取checkbox列表渲染弹窗 checkbox里面有一个其它选项，选择之后可以自定义添加类型 类型有文件和图片两种可选（发起补件的情况下只有图片类型） 考察结果 先用接口获取需要提交的文件列表并且区分image和input类型 通过循环处理resultGetData来储存提交好的图片和文字 上传图片进行压缩处理小于1M 上传成功之后将图片以及文字信息处理成list并转化成字符串以imgdata传给后台 玲珑金管家webpack配置问题此项目是vue-cli脚手架的基础上，更改的多页面应用，如果在pages下增加了新的页面，项目需要重启，在执行npm run dev命令 vue配置如果需要为所有页面设置公用的过滤器、组件等，可以再src/public.js中进行配置； 页面组成所有页面公用组件基本都在src/components文件目录下，基本内容包括，头部，底部，公用弹窗，分页组件 项目关于权限拦截部分此项目的拦截系统都是有config/beforeEnter.js中外放的两个方法来决定的，其中go方法为页面跳转时候去调用，hashIntercept为路由拦截的时候调用； 原理: 首先判断路由的跳转方式 判断该路由下是需要校验权限history.js中为路由配置 根据权限判断是为满足那种权限，在做相对应的操作 1234567891011121314151617181920212223242526272829/** * 跳转拦截触发函数 */hashInterFun = &#123; isrealname: function() &#123; this.$bus.$emit('isRealName', true) &#125;, issurvey: function() &#123; this.$bus.$emit('isSurvey', true) &#125;, isbank: function() &#123; location.href = '/myAccount.html#/SecuritySetting/BandcardInfo'; &#125;, isLend: function() &#123; this.$MyMessage.info('当前账户为借款人，不能进行出借操作！') &#125;, isBorrow: function() &#123; this.$MyMessage.info('当前账户为出借人，不能进行借款操作！') &#125;, normal: function(self, params) &#123; const direction = this.dealPath(this.params); if (this.jumpage) &#123; location.href = this.params; &#125; else &#123; self.$router.push(params) &#125; lib.goScrollTop(0); &#125;,&#125;]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式进阶]]></title>
    <url>%2F2018%2F12%2F03%2Fregular_advanced%2F</url>
    <content type="text"><![CDATA[关于分组分组在正则中用的还是比较广的，我所理解的分组 就是一对括号（） ，每一对括号 就代表了一个分组，分组可以分为：捕获性分组和非捕获性分组 捕获性分组关于捕获性分组字面意思就是可以捕获的分组类型，比如 123console.log(/(\d)(-)/.test('1-'))//trueconsole.log(RegExp.$1) //1console.log(RegExp.$2) //- 捕获性分组会在 比如$1, match exec这样的函数中以第二项，第三项的形式得到相应分组的结果 案例12345// var reg = /test(\d+)/;var reg = /test(\d+)/g;var str = 'new test001 test002';console.log(str.match(reg)); //["test001", "001", index: 4, input: "new test001 test002"]console.dir(RegExp) 非捕获性分组–(?:)非捕获性分组也就是 有些地方需要用到一对括号，但是又不想让他成为一个捕获性分组也就是不想让这个分组被类似 macth exec 这样的函数所获取到通常在括号内部的前面加上?: 也就是 (?:pattern)这样就变成了一个非捕获性分组,比如 123console.log(/(\d)(?:-)/.test('1-')) //trueconsole.log(RegExp.$1)//1console.log(RegExp.$2)//空值 非捕获性分组–断言javascript只支持零宽先行断言,所以关于JS中的正则表达式的断言，说的一般就是零宽，而零宽先行断言又可以分为正向零宽先行断言，和负向零宽先行断言。 零宽度断言零宽断言正如它的名字一样，是一种零宽度的匹配，它匹配到的内容不会保存到匹配结果中去，最终匹配结果只是一个位置而已。 作用是给指定位置添加一个限定条件，用来规定此位置之前或者之后的字符必须满足限定条件才能使正则中的字表达式匹配成功。 正向零宽断言代表符号符号：?= 案例解析 简单了解 1234var str = "abZW863";var reg = /ab(?=[A-Z])/;console.log(str.match(reg));// "ab" 在以上代码中，正则表达式的语义是:匹配后面跟随任意一个大写字母的字符串”ab”。最终匹配结果是”ab”，因为零宽断言”(?=[A-Z])”并不匹配任何字符，只是用来规定当前位置的后面必须是一个大写字母。 案例进阶 如果在上述案例的基础上我想要匹配上ZW应该怎么写； 1234var str = "abZW863";var reg = /ab(?=[A-Z]+)[A-Z]+/;console.log(str.match(reg));//"abZW" 案例3 1234var str="&lt;div&gt;antzone";var reg=/^(?=&lt;)&lt;[^&gt;]+&gt;\w+/;console.log(str.match(reg));//"&lt;div&gt;antzone" 解析过程： 首先^符号表示位置，从0开始匹配，匹配成功，让后将控制权交给(?=&lt;) 由于^是零宽度，所以(?=&lt;)还是从0开始匹配，要求第一个位置的必须是&lt;,所以也成功 由于(?=&lt;)也是零宽度，&lt;还是从0开始匹配，第一个&lt;成功； 后面就没啥好说的了； 负向零宽断言代表符号符号：?! 案例解析 案例1 1234var str = "abZW863";var reg = /ab(?![A-Z])/;console.log(str.match(reg));// null 正则表达式的语义是:匹配后面不跟随任意一个大写字母的字符串”ab”。正则表达式没能匹配任何字符，因为在字符串中，ab的后面跟随有大写字母。 案例2 123var str="abZW863ab88";var reg=/ab(?![A-Z])/g;console.log(str.match(reg)); 首先由正则表达式的字符”a”获取控制权，从位置0处开始匹配，匹配字符”a”成功 然后控制权转交给”b”，从位置1处开始匹配，配字符”b”成功，然后控制权转交给”(?[A-Z])”，它从位置2处开始匹配，它要求所在位置的右边不能够是任意一个大写字母，而位置的右边是大写字母”Z”,匹配失败 然后控制权又重新交给字符”a”，并从位置1处开始尝试，匹配失败，然后控制权再次交给字符”a”，从位置2处开始尝试匹配 依然失败，如此往复尝试，直到从位置7处开始尝试匹配成功，然后将控制权转交给”b”,然后从位置8处开始尝试匹配，匹配成功，然后再将控制权转交给”(?[A-Z])”，它从位置9处开始尝试匹配，它规定它所在的位置右边不能够是大写字母，匹配成功，但是它并不会真正匹配ab后面的字符，所以最终匹配结果是”ab”。 案例3 1var reg = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;6,12&#125;$/; 关于贪婪模式和非贪婪模式介绍贪婪与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配。非贪婪模式只被部分NFA引擎所支持。 属于贪婪模式的量词，也叫做匹配优先量词，包括： “{m,n}”、“{m,}”、“?”、“*”和“+”。 在一些使用NFA引擎的语言中，在匹配优先量词后加上“?”，即变成属于非贪婪模式的量词，也叫做忽略优先量词，包括： “{m,n}?”、“{m,}?”、“??”、“*?”和“+?”。 案例12console.log('abcadc'.match(/a.+c/g)) //["abcadc"]console.log('abcadc'.match(/a.+?c/g)) // ["abc", "adc"]]]></content>
      <categories>
        <category>JavaScript Advanced</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Reg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式基础]]></title>
    <url>%2F2018%2F11%2F30%2Fregular-base%2F</url>
    <content type="text"><![CDATA[关于正则表达式简介正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。 正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 123var str = "abc123def";var patt1 = /[0-9]+/;document.write(str.match(patt1)); 为什么要用正则表达式典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。 通过使用正则表达式，可以： 测试字符串内的模式。 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 替换文本。 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 基于模式匹配从字符串中提取子字符串。 可以查找文档内或输入域内特定的文本。 元字符常用元字符汇总表 符号 描述 . 表示出了\n以外任意的一个单个的字符串； \d 匹配一个数字字符。等价于 [0-9] \D 匹配一个非数字字符。等价于 [^0-9]。 \s 匹配任何空白字符，包括空格、制表符、换页符等等 \S 匹配任何非空白字符 \w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’ \W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’ 特殊的元字符 –限定符 符号 描述 * 匹配前面的子表达式零次或者多次。 + 匹配前面的子表达式一次或者多次。 ？ 匹配前面的子表达式零次或者一次。 {n} 匹配确定的n次。 {n,} 至少匹配n次。 {n,m} 最少匹配n次，且最多能匹配m次。 其他特殊符号 符号 描述 [] 查找方括号之间的任何字符,可以理解为一个范围，或者表示一个单独字符 [a-z] 表示小写字母 [A-Z] 表示大写字母 [0-9] 表示数字 [a-zA-Z0-9] 表示所有数字和字母 [\u4e00-\u9fa5] 校验中文 \ 将下一个字符标记为一个特殊字符、或一个原义字符：转义 ^ 表示以什么开始或者取反 $ 表示以什么结束 竖线 指明两项之间的一个选择（优先级最低） () 小括号：提升优先级别的；作用：分组 从最左边算起 案例1234567console.log(/./.test('除了换行以外的任意字符'))console.log(/.*/.test(''))console.log(/.+/.test(''))console.log(/b|(ara)/.test('abra'))console.log(/^b|(ara)$/.test('abra'))console.log(/[a-z]&#123;2,3&#125;/.test('ar'))console.log(/\w&#123;2&#125;/.test('abc23')) RegExp 对象简介正则表达式是描述字符模式的对象。 正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。 使用关于参数 pattern（模式） 描述了表达式的模式 modifiers(修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 构造函数1var patt=new RegExp(pattern,modifiers); 使用字面量12var patt=/pattern/modifiers; 对象方法test()方法test() 方法用于检测一个字符串是否匹配某个模式.如果字符串中有匹配的值返回 true ，否则返回 false。 12345//关于严格模式var reg = new RegExp(/^\d&#123;5&#125;$/);console.log(reg.test('12345')) //trueconsole.log(reg.test('123456')) //false exec()方法exec() 方法用于检索字符串中的正则表达式的匹配。 如果字符串中有匹配的值返回该匹配值，否则返回 null。 12console.log(/\d/.exec('adf12')) toString()返回正则表达式的字符串值。 12var res = /\d/.toString();console.log(res) // /\d/ 支持正则的String方法replace()replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 123var str = "Mr Blue has a blue house and a blue car";console.log(str.replace(/blue/, "red"))console.log(str.replace(/blue/g, "red")) search()用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。 1console.log('1212adfvafed'.search(/\d/)) //0 match()可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 1234var str = "The rain in SPAIN stays mainly in the plain";var n = str.match(/ain/gi);console.log(n) split()用于把一个字符串分割成字符串数组。 123var str = "The rain in SPAIN stays mainly in the plain";var n = str.match(/ain/gi);]]></content>
      <categories>
        <category>JavaScript Base</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Reg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wepy基本使用]]></title>
    <url>%2F2018%2F11%2F29%2Fn_wcwepy%2F</url>
    <content type="text"><![CDATA[1. wepy-介绍&nbsp; &nbsp; WePY (发音: /‘wepi/)是一款腾讯团队于2016年11月发布的小程序组件化框架，通过预编译的手段让开发者可以选择自己喜欢的开发风格去开发小程序。 官网 1.1. 特性 类Vue开发风格 支持自定义组件开发 支持引入NPM包 支持Promise 支持ES2015+特性，如Async Functions 支持多种编译器，Less/Sass/Stylus/PostCSS、Babel/Typescript、Pug 支持多种插件处理，文件压缩，图片压缩，内容替换等 支持 Sourcemap，ESLint等 小程序细节优化，如请求列队，事件优化等 1.2. 优秀案例&nbsp; &nbsp; 腾讯疫苗查询小程序、 腾讯翻译君小程序、 腾讯地图小程序、 玩转故宫小程序、 手机充值+、 手机余额查询、 手机流量充值优惠、 友福图书馆（开源）、 素洁商城（开源）、 NewsLite（开源）、 西安找拼车（开源）、 深大的树洞（开源）、 求知微阅读（开源）、 给你的 iPhone X 换个发型、 天天跟我买、 坚橙、 群脱单、 米淘联盟、 帮助圈、 众安保险福利、 阅邻二手书、 趣店招聘、 满熊阅读（开源： 微信小程序、支付宝小程序）、 育儿柚道、 平行进口报价内参、 GitHub掘金版、 班级群管、 鲜花说小店、 逛人备忘、 英语助手君、 花花百科、 独角兽公司、 爱羽客羽毛球、 斑马小店、 小小羽球、 培恩医学、 农资优选、 公务员朝夕刷题、 七弦琴小助手、 七弦琴大数据、 爽到家小程序、 应用全球排行（开源）、 we川大（开源）、 聊会儿、 … 1.3. 前置知识 node&amp;npm vue es6 微信小程序 2. 快速项目搭建2.1. 全局安装WePY的安装或更新都通过npm进行。 1npm install wepy-cli -g 2.2. 创建空项目 1.7.0版本之前的请查询官网完成创建 1wepy init empty my-project 2.3. 编译并监控项目等待创建成果后，进入到项目目录 1cd my-project 安装依赖 1npm install 编译并监控项目 1wepy build --watch 此时，可以看到目录下多了一个dist文件夹，该文件夹便是经过wepy编译后的小程序源代码，也就是我们可以用小程序开发者工具直接监控的项目代码。 2.4. WePY项目的目录结构123456789101112131415161718192021├─dist 小程序文件夹│ └─pages 小程序页面文件夹│ index.js 首页的js文件│ index.json 首页的配置文件│ index.wxml 首页的标签文件 │ index.wxss 首页的样式文件│—node_modules node包 │─src wepy的项目源代码│ │ app.wpy wepy的小程序的全局组件│ │ │ └─pages wepy的页面组件文件夹│ index.wpy wepy的小程序的首页组件│ .editorconfig 代码格式的配置文件│ .gitignore 告诉git哪些文件需要忽略│ .prettierrc 代码格式化的配置文件│ .wepycache wepy项目的缓存文件 防止build时 重复编译npm目录│ .wepyignore wepy编译工具的忽略清单│ package-lock.json npm的项目描述文件│ package.json npm的项目描述文件│ project.config.json 小程序项目内的配置文件│ wepy.config.js wepy的编译配置文件 &nbsp;&nbsp; dist为小程序运行目录，因此千万不要手动去编辑或者修改!! 3. 开发环境配置3.1. 小程序开发者工具配置由于统一使用wepy进行开发，因此关于开发者工具的配置也需要直接在wepy项目中直接进行配置。通过project.config.json即可进行配置，默认不需要修改。 12345678910111213&#123; &quot;description&quot;: &quot;project description&quot;, &quot;setting&quot;: &#123; &quot;urlCheck&quot;: true, &quot;es6&quot;: false, &quot;postcss&quot;: false, &quot;minified&quot;: false &#125;, &quot;compileType&quot;: &quot;miniprogram&quot;, &quot;appid&quot;: &quot;touristappid&quot;, &quot;projectname&quot;: &quot;Project name&quot;, &quot;miniprogramRoot&quot;: &quot;./dist&quot;&#125; es6: 对应关闭ES6转ES5选项，关闭。 重要：未关闭会运行报错。 postcss: 对应关闭上传代码时样式自动补全选项，关闭。 重要：某些情况下漏掉此项也会运行报错。 minified: 对应关闭代码压缩上传选项，关闭。重要：开启后，会导致真机computed, props.sync 等等属性失效。 urlCheck: 对应不检查安全域名选项，开启。 如果已配置好安全域名则建议关闭。 3.2. 代码高亮配置wepy推荐开发者使用较为成熟的编辑器来代替 微信开发者工具 ， 微信开发者工具 只用来做显示界面使用。 这里推荐 使用vs code ，如需要其他编辑器，其他编辑器配置 在 Code 里先安装 Vue 的语法高亮插件 Vetur。 打开任意 .wpy 文件。 点击右下角的选择语言模式，默认为纯文本。 在弹出的窗口中选择 .wpy 的配置文件关联...。 在选择要与 .wpy 关联的语言模式 中选择 Vue。 3.3. 启用promise因为不想陷入异步的回调地狱中，所以在一些复杂的业务当中，我们推荐使用 promise 或者 async-function 来代替传统的回调。因此需要在项目中单独进行配置。 3.3.1. 进入项目根目录，安装polyfill1npm install wepy-async-function --save 3.3.2. 在app.wpy中导入polyfill1import 'wepy-async-function'; 3.3.3. 在app.wpy中开启promise123456export default class extends wepy.app &#123; constructor () &#123; super(); this.use('promisify'); &#125;&#125; 3.4. wepy.config.js&nbsp;&nbsp;wepy项目编译的配置文件 属性名 含义 target wepy编译后的生成目录 wpyExt wepy组件的后缀名，默认为wepy，可以指定为vue eslint 是否开启eslint的验证 cliLogs 开启控制台打印 compilers 编译sass，js等文件的配置 plugins 插件 appConfig 全局变量，可以在组件中通过 wepy.$appConfig访问 4. 小程序页面结构和wepy组件结构对比4.1. wepy组件的编译图解wepy组件编译的流程如图所示，我们在学习wepy组件前，最好提前了解一下。 4.2. 小程序页面结构小程序页面结构分为4个部分 wxml 标签文件 wxss 样式文件 JavaScript 逻辑文件 json 配置文件 4.3. wepy组件结构wepy组件默认后缀名为 .wpy,该文件里面包含有了 样式、标签和逻辑部分 如 12345678910111213141516171819202122/* 样式 */&lt;style lang="less"&gt;&lt;/style&gt;/* 标签 */&lt;template&gt; &lt;view class="container"&gt; Hello world &lt;/view&gt;&lt;/template&gt; /* 逻辑 */&lt;script&gt;import wepy from 'wepy';export default class Index extends wepy.page &#123; config = &#123; navigationBarTitleText: 'test' &#125;; onLoad() &#123; console.log('onLoad'); &#125;&#125;&lt;/script&gt; 5. app.wpy文件wpy文件分为3个部分，分别是 样式 style，标签 template，还有 脚本 javascript。下面挨个来讲解 5.1. style在app.wpy 文件的style中，控制的是全局的样式。它有如下特点 设置的样式可以在所有的页面文件中使用 通过lang关键字可以设置 css,less,scss 等预处理器 123&lt;style lang="less"&gt;&lt;/style&gt; 可以使用 //等作为注释（小程序中的wxss中直接写//是不支持的）。 123view &#123; // color: yellow;&#125; 可以通过style标签中的src关键字导入另外的第三方样式文件 1&lt;style src="./styles/base.css"&gt; &lt;/style&gt; 5.2. template template为标签部分，由于app.wpy最终是要编译为小程序中的app.js文件的，因此该template无特别用法 5.3. JavaScript app.wpy中的javascript为脚本部分，继承自wepy.app 它经过编译后，最终会生成两个文件，分别是 app.js 和 app.json。 主要有以下特点 代码风格类似vue，es6的语法。 继承自 wepy.app 1234567891011121314export default class extends wepy.app &#123; config = &#123; pages: ['pages/index'], window: &#123; backgroundTextStyle: 'light', navigationBarBackgroundColor: '#fff', navigationBarTitleText: 'WeChat', navigationBarTextStyle: 'black' &#125; &#125;; onLaunch() &#123; console.log('on launch'); &#125;&#125; 在 default class内，config字段对应的是小程序中 app.json的内容 全局配置 123456789config = &#123; pages: ['pages/index'], window: &#123; backgroundTextStyle: 'light', navigationBarBackgroundColor: '#fff', navigationBarTitleText: 'WeChat', navigationBarTextStyle: 'black' &#125;&#125;; 和config同层级，可以定义小程序的App注册事件 和全局变量 globalData等 123456789config = &#123;... &#125;;onLaunch() &#123; console.log('on launch');&#125;onShow()&#123; console.log("on show");&#125;globalData=&#123;&#125;; 6. index.wpy6.1. 介绍页面组件wpy的文件结构类似 app.wpy结构，也是由三个部分组成 标签 template ，样式 style和脚本javascript 继承自 wepy.page。其中 脚本 javascript经过编译后，也是会生成两个文件。分别是小程序中的页面javascript和页面json 1234567891011121314&lt;style lang="less"&gt;&lt;/style&gt;&lt;template&gt;&lt;/template&gt;&lt;script&gt;import wepy from 'wepy';export default class Index extends wepy.page &#123;&#125;&lt;/script&gt; 属性 说明 config 页面配置对象，对应于原生的page.json文件，类似于app.wpy中的config data 页面渲染数据对象，存放可用于页面模板绑定的渲染数据 methods wxml事件处理函数对象，存放响应wxml中所捕获到的事件的函数，如bindtap、bindchange 生命周期函数 小程序页面生命周期函数，如onLoad、onReady等，以及其它自定义的方法与属性 computed 计算属性 watch 监控数据 自定义数据 可以自定义内部使用的数据 自定义函数 可以自定义内部需要使用的函数 components 页面组件列表对象，声明页面所引入的组件列表 events WePY组件事件处理函数对象，存放响应组件之间通过$broadcast、$emit、$invoke所传递的事件的函数 mixins 声明页面引入的Minxin 6.2. 数据绑定在wepy中，数据绑定的类似vue的风格，也是通过 来绑定，this.mydata=&#39;hello wepy&#39;来修改。 注意，如在异步里修改数据，需要手动调用 this.$apply(); 来触发数据更新 代码： 1234567891011121314&lt;template&gt; &lt;view&gt;&#123;&#123;mydata&#125;&#125;&lt;/view&gt;&lt;/template&gt;&lt;script&gt;import wepy from 'wepy';export default class Index extends wepy.page &#123; data=&#123; mydata:"hello wepy" &#125;; onLoad() &#123; this.mytitle = '你好wepy'; &#125;&#125;&lt;/script&gt; 6.3. 事件页面中，绑定事件的方式变为更为简单了。并且，可以实现在事件中传递参数。通过@来绑定，可以省略小程序中的关键字 bind。如 bindtap 变为 @tap。 而且，可以通过添加事件后缀来指定对应的事件类型，如： .default: 绑定小程序冒泡型事件，如bindtap，.default后缀可省略不写； .stop: 绑定小程序捕获型事件，如catchtap； .user: 绑定用户自定义组件事件，通过$emit触发。注意，如果用了自定义事件，则events中对应的监听函数不会再执行。 123456789101112131415&lt;template&gt; &lt;view class="container" @tap="myTap(123)"&gt; Hello world &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import wepy from 'wepy';export default class Index extends wepy.page &#123; methods = &#123; myTap(data) &#123; console.log(data); &#125; &#125;;&#125;&lt;/script&gt; 7. component.wpy组件文件，结构上大体和页面.wpy类似，区别在于组件是继承自 wepy.component,并且它拥有自己的属性设置，插槽等。关于一些小程序自身的组件基本属性，可以通过 小程序组件 来进行查阅。这里主要讲解如何使用自定义组件和组件传参。 7.1. 使用自定义组件7.1.1. 声明组件 新建组件 Myheader.wpy 编辑组件 1234567891011121314&lt;template&gt; &lt;view @tap="myTap" &gt;组件中的文字&lt;/view&gt;&lt;/template&gt;&lt;script&gt;import wepy from "wepy";export default class MyHeader extends wepy.component &#123; methods=&#123; myTap()&#123; console.log("组件被点击了"); this.$emit("parentEvent",&#123;&#125;); &#125; &#125;&#125;&lt;/script&gt; 7.1.2. 使用组件 在页面文件中引入组件 1import MyHeader from '../components/MyHeader'; 在 class中声明引入的组件 123components = &#123; MyHeader &#125;; template中使用组件 12345&lt;template&gt; &lt;view class=&quot;container&quot; &gt; &lt;MyHeader&gt;&lt;/MyHeader&gt; &lt;/view&gt;&lt;/template&gt; 7.2. props组件传值页面和组件之间的传值可以通过 props实现。分为三种： 静态传值 父组件传递到子组件的值，不会再被父组件改变。只能传递字符串 动态传值 使用 .sync修饰符来将父组件的数据绑定到子组件上，单向绑定。父 -&gt; 子 动态传值 使用 .sync 和 子组件中的twoWay: true 实现双向绑定 父 &lt;-&gt; 子 7.2.1. 静态传值组件 MyHeader 12345678&lt;template&gt; &lt;view &gt;&#123;&#123;parentTitle&#125;&#125;&lt;/view&gt;&lt;/template&gt;&lt;script&gt; // .... props=&#123; parentTitle:String // 静态传值&lt;/script&gt; 父组件 12345&lt;template&gt; &lt;view class="container" &gt; &lt;MyHeader parentTitle="父组件中的title" &gt;&lt;/MyHeader&gt; &lt;/view&gt;&lt;/template&gt; 7.2.2. 单向绑定组件 MyHeader 123456789101112&lt;template&gt; &lt;view &gt;&#123;&#123;parentTitle&#125;&#125;&lt;/view&gt;&lt;/template&gt;&lt;script&gt; // .... props=&#123; parentTitle:&#123; type:String, default:null &#125; &#125;&lt;/script&gt; 父组件 使用 .sync 修饰符 1234567891011121314151617181920&lt;template&gt; &lt;view class="container" &gt; &lt;MyHeader :parentTitle.sync="父组件中的title" &gt;&lt;/MyHeader&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import MyHeader from '../components/MyHeader';import wepy from 'wepy';export default class Index extends wepy.page &#123; data=&#123; title:"父中的组件" &#125; onLoad() &#123; setTimeout(() =&gt; &#123; this.title="被修改了"; this.$apply(); &#125;, 2000); &#125;&#125;&lt;/script&gt; 7.2.3. 双向绑定父组件和子组件上同时加上配置便可实现 组件中的数据双向绑定。 组件 MyHeader 加上配置 twoWay: true 1234567891011121314151617181920&lt;template&gt; &lt;view @tap="myTap" &gt;子组件 &#123;&#123;parentTitle&#125;&#125;&lt;/view&gt;&lt;/template&gt;&lt;script&gt;import wepy from "wepy";export default class MyHeader extends wepy.component &#123; props=&#123; parentTitle:&#123; type:String, default:null, twoWay:true &#125; &#125; methods=&#123; myTap()&#123; this.parentTitle="组件中修改了"; &#125; &#125;&#125;&lt;/script&gt; 父组件 中继续使用 .sync 修饰符 1234567891011121314151617181920212223242526&lt;template&gt; &lt;view class="container" &gt; &lt;view&gt; 父组件上的数据： &#123;&#123;title&#125;&#125; &lt;/view&gt; &lt;MyHeader:parentTitle.sync="title" &gt;&lt;/MyHeader&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import MyHeader from '../components/MyHeader';import wepy from 'wepy';export default class Index extends wepy.page &#123; components = &#123; MyHeader &#125;; data=&#123; title:"父中的组件" &#125; onLoad() &#123; setTimeout(() =&gt; &#123; this.title="父组件中修改了"; this.$apply(); &#125;, 2000); &#125;&#125;&lt;/script&gt; 7.3. 组件通信组件之间的通信，都通过事件触发的形式来实现。主要有以下三种 父组件向子组件通信 $broadcast 子组件向父组件通信 $emit 页面或组件对另一个组件中的方法的直接调用 $invoke 7.3.1. $broadcast$broadcast 负责由父组件向子组件传播事件。 流程如下 使用方式： 父组件中 触发 1this.$broadcast("子组件中的事件名",..参数) 子组件中，在events字段内监听 12345events=&#123; 事件名(...args)&#123; // 执行逻辑 &#125;&#125; 7.3.2. $emit$emit 负责由子组件向父组件触发事件 。 流程如下 方向和 $broadcast 相反 使用方式 子组件中触发 1this.$emit(&quot;parentFn&quot;,1,3,4,5); 父组件 events 字段中监听 12345events = &#123; parentFn(...args)&#123; console.log("父组件事件触发"); &#125;&#125;; 7.3.3. $invoke$invoke是一个页面或组件对另一个组件中的方法的直接调用 1234// 页面中的调用this.$invoke('ComA', 'someMethod', 'someArgs');// 组件中的调用this.$invoke('./../ComB/ComG', 'someMethod', 'someArgs'); 如同文件夹下，在页面index中，A 组件想要调用B组件内的方法 index.wpy 12&lt;A&gt;&lt;/A&gt;&lt;B&gt;&lt;/B&gt; A.wpy 1234567891011121314151617&lt;template lang="wxml"&gt; &lt;view @tap="myTap"&gt;组件1&lt;/view&gt;&lt;/template&gt;&lt;script&gt;import wepy from 'wepy';import B from './B';export default class A extends wepy.component &#123; methods = &#123; myTap() &#123; this.$invoke('B', 'show', 'A的呼叫'); &#125; &#125;; components=&#123; B &#125;&#125;&lt;/script&gt; B.wpy 12345678910111213&lt;template lang="wxml"&gt; &lt;view &gt;组件0&lt;/view&gt;&lt;/template&gt;&lt;script&gt;import wepy from 'wepy';export default class B extends wepy.component &#123; methods = &#123; show(msg) &#123; console.log("触发 " +msg); &#125; &#125;;&#125;&lt;/script&gt; 7.3.3.1. 组件自定义事件可以通过使用.user修饰符为自定义组件绑定事件，如：`@customEvent.user=”myFn”` 其中，@表示事件修饰符，customEvent 表示事件名称，.user表示事件后缀。 目前总共有三种事件后缀： .default: 绑定小程序冒泡型事件，如bindtap，.default后缀可省略不写； .stop: 绑定小程序捕获型事件，如catchtap； .user: 绑定用户自定义组件事件，通过$emit触发。注意，如果用了自定义事件，则events中对应的监听函数不会再执行。 7.4. 插槽slot插槽slot可以允许我们在页面中往组件的内部动态的插入标签结构 slot有两种使用方式，单个slot和多个slot 当使用多个slot时，只需要指定唯一的name属性即可。 在Panel组件中有以下模板： 1234&lt;view class="panel"&gt; &lt;slot name="title"&gt;默认标题&lt;/slot&gt; &lt;slot name="content"&gt;默认内容&lt;/slot&gt;&lt;/view&gt; 在父组件中使用Panel子组件时，可以这样使用： 123456&lt;panel&gt; &lt;view slot="title"&gt;新的标题&lt;/view&gt; &lt;view slot="content"&gt; &lt;text&gt;新的内容&lt;/text&gt; &lt;/view&gt;&lt;/panel&gt; 8. 拦截器可以使用WePY提供的全局拦截器对原生API的请求进行拦截。 8.1. 在app.wpy中定义全局拦截器123456789101112131415161718192021222324252627282930313233343536373839import wepy from 'wepy';export default class extends wepy.app &#123; constructor () &#123; // this is not allowed before super() super(); // 拦截request请求 this.intercept('request', &#123; // 发出请求时的回调函数 config (p) &#123; // 对所有request请求中的OBJECT参数对象统一附加时间戳属性 p.timestamp = +new Date(); console.log('config request: ', p); // 必须返回OBJECT参数对象，否则无法发送请求到服务端 return p; &#125;, // 请求成功后的回调函数 success (p) &#123; // 可以在这里对收到的响应数据对象进行加工处理 console.log('request success: ', p); // 必须返回响应数据对象，否则后续无法对响应数据进行处理 return p; &#125;, //请求失败后的回调函数 fail (p) &#123; console.log('request fail: ', p); // 必须返回响应数据对象，否则后续无法对响应数据进行处理 return p; &#125;, // 请求完成时的回调函数(请求成功或失败都会被执行) complete (p) &#123; console.log('request complete: ', p); &#125; &#125;); &#125;&#125; 8.2. 使用内置的wepy发送请求通过 wepy.request的方式来发送请求 如： 记得要先开启 wepy对promise 和 async 方法的支持。 12let movies = await wepy.request(&#123; url: "http://api.apiopen.top/searchAuthors?name=李白" &#125;);console.log(movies); 9. 循环标签repeat当需要循环渲染WePY组件时，必须使用WePY定义的辅助标签&lt;repeat&gt; 默认项为 item 索引为 index 12&lt;repeat for="&#123;&#123;list&#125;&#125;" key="index" index="index" item="item"&gt;&lt;/repeat&gt;]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Ne</tag>
        <tag>MVVM</tag>
        <tag>Wepy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVVM框架进阶与实现--解析版]]></title>
    <url>%2F2018%2F11%2F28%2Fn_h_vue%2F</url>
    <content type="text"><![CDATA[Vue基本思路 创建vue对象：构造函数或者class类 声明data层数据（data,methods） 创建dom对象（#app）（告诉vue解析那一部分的dom对象）（view层） 创建compile：解析view层 解析指令：v-text等 解析文本 创建observer对象:劫持data层; 创建watcher层 连接compile和observer作用 compile创建文本碎片 所有操作dom在文本碎片中进行 处理结束之后放到body里面，再由浏览器进行解析； 可以避免一定程度的回流和重绘 compile方法解析node节点 注意区分元素节点和文本节点 进行递归操作：解析下一层的node 元素节点 主要解析指令 是在元素节点处进行递归解析 主要解析有”v-“开头指令 需要尤其注意v-on:click绑定事件特殊处理 文本节点 主要解析文本中包含此种形式的数据 正则分组参考文件 解析完毕解析完毕之后要将文本碎片放回body中 observer 主要作用通过Object.defineProperty检测data中所有的属性 此处依旧注意递归操作; watcher连接observer和compile 如果需要使页面更新,需要在compile中的指令解析的时候; 如果需要检测数据改变,需要在observer中的数据劫持的set中进行; 所以就需要 在更改dom对象值的时候使用watcher检测:声明watcher对象； 1234567if (type === 'text') &#123; node.textContent = this.getVmValue(expr) new Watcher(this.$vm, expr, (newAalue, oldValue) =&gt; &#123; node.textContent = newAalue; &#125;)&#125; 如果需要更改调用回调：在watcher内部需要一个方法来调用callback； 12345678update() &#123; let oldValue = this.oldValue; let newValue = this.getVMValue(this.vm, this.expr) if (oldValue !== newValue) &#123; this.cb(newValue, oldValue) &#125; &#125; 需要知道在什么时候调用update：数据改变的时候-也就是observer中的set方法调用的时候 问题： 我们是在compile中实例化的watcher，需要在observer中调用watcher中的updata方法 而且每一个数据在compile过程中，可能不只有一个watcher对象 data.msg==&gt;=&gt;v-test=&gt;v-html; data中的每一个key，都需要一个对象挂载上他自己的watcher对象 实现步骤需要在observer中劫持data中的每一个属性的时候，声明一个Dep（挂载此属性下watcher）对象1234let dep = new Dep();Object.defineProperty(obj, key, &#123; configurable: true, enumerable: true, 需要每个watcher在实例化的时候把自己放到Dep中的一个属性里面：；1234class Dep &#123; constructor() &#123; this.subs = [];//就是这个 &#125; 先把watcher挂载到一个对象上面，要求在observer中也能拿到：window可以，此处用的是dep本身； 12Dep.target = this;//此处的this就是watcher实例化之后的对象 在wathcer中调用获取oldValue的时候就会触发get方法，此时把我们挂载到Dep中的watcher放到dep中的subs数组中 1Dep.target &amp;&amp; dep.addSub(Dep.target) 解析总结整个完成之后data中的每一个属性都会有自己一个Dep,Dep中的subs包含着凡是用到过此属性的所有watcher； 在data发生改变之后 首先触发的是observer中的set方法； 调用dep中的发布函数：notify 发布函数会通知subs中的所有watcher调用自身的update函数 watcher中的updata会触发回调，改变元素的值；]]></content>
      <categories>
        <category>JavaScript Advanced</category>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Ne</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpvue基本使用]]></title>
    <url>%2F2018%2F11%2F27%2Fn_wcmyvue%2F</url>
    <content type="text"><![CDATA[1. mpvue-介绍mpvue 是美团团队开发的语法类似 Vue.js 的小程序的前端框架 官网 开发文档 1.1. 主要特性主要有以下特性 彻底的组件化开发能力：提高代码复用性 完整的 Vue.js 开发体验 方便的 Vuex 数据管理方案：方便构建复杂应用 快捷的 webpack 构建机制：自定义构建策略、开发阶段 hotReload 支持使用 npm 外部依赖 使用 Vue.js 命令行工具 vue-cli 快速初始化项目 H5 代码转换编译成小程序目标代码的能力 1.2. 优秀案例 1.3. 前置知识 前端基本功 html + css + javascript nodejs es6 webpack vue 微信小程序 1.3.1. 代码示例12345678910111213new Vue(&#123; data: &#123; a: 1 &#125;, created () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a) &#125;, onShow () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a, '小程序触发的 onshow') &#125;&#125;) 2. 启动项目2.1. 全局安装vue脚手架工具1npm install --global vue-cli 2.2. 创建项目mpvue 提供了开发企业级的模板 quickstart 和 页面级的模板 simple。 1vue init mpvue/mpvue-quickstart my-project 2.3. 安装依赖12cd my-projectnpm install 2.4. 修改微信入口地址由于 mpvue中的 小程序入口路径和打包编译后的路劲 对应不上，因此需要我们手动的修改下 入口路径。 修改 project.config.json 文件 12345// 源代码"miniprogramRoot": "./dist/",// 修改为"miniprogramRoot": "./dist/wx/", 2.5. 启动项目1npm run dev 2.6. 使用小程序开发者工具打开编译成功后，可以看到在 dist/wx内有我们熟悉的小程序代码文件，此时，使用小程序开发者工具直接打开 项目的根目录(因为直接在配置文件中配置过 /dist/wx/入口路径 ) 3. 项目目录结构编译成功后，可以看到如下的项目结构 123456789101112131415├─build 打包构建相关配置文件├─config 用于打包的一些变量文件├─dist 小程序页面文件├─src mpvue源代码├─static 一些静态资源└─test 测试相关│ .babelrc js的编译配置│ .editorconfig 编辑器风格│ .gitignore git文件忽略清单│ .postcssrc.js 转换css到wxss的│ index.html 入口模板│ package-lock.json node包版本说明文件│ package.json 项目描述文件│ project.config.json 小程序开发者工具配置文件│ README.md 项目说明文档 4. 生命周期图示mpvue的生命周期结合了 vue和小程序的生命周期 4.1. vue 生命周期 beforeCreate 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用 created 在实例创建完成后被立即调用，$el 属性目前不可见，data中的数据可以使用 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted 示例和对应的dom都被创建后开始调用，子组件不一定全部被挂载，如要确保，使用 vm.$nextTick 来代替。$el可用。 beforeUpdate 数据更新时调用,这里适合在更新之前访问现有的 DOM，data中的数据更新了，但是视图还没有更新 updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁时会被调用，data中的数据更新了，视图也更新了 activated keep-alive 组件激活时调用 deactivated keep-alive 组件停用时调用 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用 destroyed Vue 实例销毁后调用，Vue 实例指示的所有东西都会解绑定，所有的事件监听器和所有的子实例都会被销毁 4.2. 小程序生命周期app 部分： onLaunch 小程序初始化时被调用 onShow 当小程序启动，或从后台进入前台显示被调用 onHide 当小程序从前台进入后台 page 部分： onLoad 页面加载完毕被调用 onShow 页面开始显示时被调用 onReady， 页面初次渲染完成被调用 onHide 页面隐藏时被调用 onUnload 页面卸载被调用 onPullDownRefresh 用户下拉动作开始时被调用 onReachBottom 页面上拉触底时被调用 onShareAppMessage 用户点击右上角分享时被调用 onPageScroll 页面滚动时被调用 onTabItemTap, 当前是 tab 页时，点击 tab 时触发 4.3. mpvue-生命周期图示 mpvue会在小程序 onReady 后，再去触发 vue mounted 生命周期 不建议使用小程序的生命周期钩子 5. mpvue 标签映射由于web中的标签和小程序中的标签存在差异，因此 mpvue内部提供了对应的标签转换，可以让开发者专注于业务本身，省去了记忆新标签的成本。 web标签 小程序标签 备注 div view[_div] p view[_p] span label a navigator 属性参照小程序的navigator img image 属性参照小程序的image ul view[_ul] ol view[_ol] 6. mpvue 语法6.1. 数据绑定mpvue绑定数据的方式大部分和vue一样。 6.1.1. 支持的语法 Mustache(双大括号) 文本插值 v-text属性的方式绑定 标签内属性方式绑定 :attr=&quot;value&quot; v-model也是支持的 6.1.2. 不支持的语法 v-html 因为小程序内部不支持动态标签 （会被解释为rich-text标签） v-once 暂时不支持 6.1.3. 代码示例12345678910111213&lt;!-- 1.0 支持的语法 --&gt;&lt;!-- 双括号 --&gt;&#123;&#123;msg&#125;&#125;&lt;!-- v-text --&gt;&lt;view v-text="msg"&gt;&lt;/view&gt;&lt;!-- :hidden --&gt;&lt;view :hidden="false" &gt;显示与隐藏&lt;/view&gt;&lt;!-- 2.0 不支持的错误 --&gt;&lt;!-- v-html --&gt;&lt;view v-html="htmlmsg"&gt;&lt;/view&gt;&lt;!-- v-once --&gt;&lt;view v-once="msg"&gt;&lt;/view&gt; 6.2. JavaScript 渲染表达式目前可以使用的有 + - * % ?: ! == === &gt; &lt; [] .，剩下的还待完善。 但写在 @event 里面的表达式是都支持的，因为这部分的计算放在了 vdom 里面 123456789&lt;!-- 这种就不支持，建议写 computed --&gt;&lt;p&gt;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/p&gt;&lt;!-- 但写在 @event 里面的表达式是都支持的，因为这部分的计算放在了 vdom 里面 --&gt;&lt;ul&gt; &lt;li v-for="item in list"&gt; &lt;div @click="clickHandle(item, index, $event)"&gt;&#123;&#123; item.value &#125;&#125;&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 6.3. computed 和 watch6.3.1. computed对于任何复杂逻辑，都应当使用计算属性 使用方式和vue中一样 12345computed:&#123;reversedMessage: function () &#123; return this.message.split('').reverse().join('')&#125;&#125; 6.3.2. watchwatch相比于computed可以让我们做更多的事情。 使用方式和vue中一样 12345watch: &#123; msg(newValue, oldValue) &#123; console.log("watch被触发了"); &#125;&#125; 6.4. 条件渲染6.4.1. v-if支持 v-if v-else 和 v-else if指令。 v-if 指令的显示和隐藏是通过 增加和删除节点实现。频繁操作性能损耗大。 123&lt;div v-if="false"&gt;if&lt;/div&gt;&lt;div v-else-if="true"&gt; v-else-if&lt;/div&gt;&lt;div v-else&gt;v-else&lt;/div&gt; 6.4.2. v-show用法大致一样 1&lt;div v-show="true"&gt;v-show&lt;/div&gt; 6.5. 列表渲染6.5.1. v-for v-for 可以循环 数组和对象等可迭代的对象。 mpvue中，嵌套列表渲染，必须指定不同的索引！ 数组 12345&lt;ul v-for="(card, index) in list"&gt; &lt;li v-for="(item, itemIndex) in card"&gt; &#123;&#123;item.value&#125;&#125; &lt;/li&gt; &lt;/ul&gt; 对象 123&lt;div v-for="(value, key) in object"&gt; &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; 嵌套列表渲染 12345&lt;ul v-for="(card, index) in list"&gt; &lt;li v-for="(item, itemIndex) in card"&gt; &#123;&#123;item.value&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 6.6. Class 与 Style 绑定动态设置样式 6.6.1. class 支持的语法:12345&lt;p :class="&#123; active: isActive &#125;"&gt;111&lt;/p&gt;&lt;p class="static" v-bind:class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt;222&lt;/p&gt;&lt;p class="static" :class="[activeClass, errorClass]"&gt;333&lt;/p&gt;&lt;p class="static" v-bind:class="[isActive ? activeClass : '', errorClass]"&gt;444&lt;/p&gt;&lt;p class="static" v-bind:class="[&#123; active: isActive &#125;, errorClass]"&gt;555&lt;/p&gt; 6.6.2. style 支持的语法:12&lt;p v-bind:style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;666&lt;/p&gt;&lt;p v-bind:style="[&#123; color: activeColor, fontSize: fontSize + 'px' &#125;]"&gt;777&lt;/p&gt; 6.6.3. 不支持的语法 不支持 官方文档：Class 与 Style 绑定 中的 classObject 和 styleObject 语法。 不支持在组件上使用 Class 与 Style 绑定 7. 事件几乎全支持 vue中的事件处理器 7.1. 绑定方式使用v-bind或者@关键字来执行绑定 12345&lt;!-- // v-bind --&gt;&lt;view v-bind:click="clickHandle3"&gt;点我&lt;/view&gt;&lt;!-- // @ --&gt; &lt;view @click="clickHandle3"&gt;点我&lt;/view&gt; 7.2. 事件映射表 WEB 事件 小程序 事件 备注 click tap touchstart touchstart touchmove touchmove touchcancel touchcancel touchend touchend tap tap longtap longtap input input change change submit submit blur blur focus focus reset reset confirm confirm columnchange columnchange linechange linechange error error scrolltoupper scrolltoupper scrolltolower scrolltolower scroll scroll 7.3. 踩坑注意 列表中没有的原生事件也可以使用例如 bindregionchange 事件直接在 dom 上将bind改为@ 小程序能力所致，bind 和 catch 事件同时绑定时候，只会触发 bind ,catch 不会被触发，要避免踩坑。 事件修饰符 .stop 的使用会阻止冒泡，但是同时绑定了一个非冒泡事件，会导致该元素上的 catchEventName 失效！ .prevent 可以直接干掉，因为小程序里没有什么默认事件，比如submit并不会跳转页面 .capture 支持 1.0.9 .self 没有可以判断的标识 .once 也不能做，因为小程序没有 removeEventListener, 虽然可以直接在 handleProxy 中处理，但非常的不优雅，违背了原意，暂不考虑 其他 键值修饰符 等在小程序中压根没键盘，所以。。。 @regionchange,同时这个事件也非常特殊，它的 event type 有 begin 和 end 两个，导致我们无法在handleProxy 中区分到底是什么事件，所以你在监听此类事件的时候同时监听事件名和事件类型既 &lt;map @regionchange=&quot;functionName&quot; @end=&quot;functionName&quot; @begin=&quot;functionName&quot;&gt;&lt;map&gt; 8. 表单控件绑定建议开发过程中直接使用 微信小程序：表单组件 如： select 组件用 picker 组件进行代替 表单元素 radio 用 radio-group 组件进行代替 9. 组件有且只能使用单文件组件（.vue 组件）的形式进行支持。详细的使用方式，参照vue中的组件文档 9.1. 定义组件新建组件文件 card.vue 组件也是分为3个部分。 标签 template 脚本 script 和 样式 style 编辑内容 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;p class="card"&gt; &#123;&#123;text&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; text: "卡片组件" &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;.card &#123; padding: 10px;&#125;&lt;/style&gt; 9.2. 使用组件在某个页面文件中使用组件 card.vue 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;card&gt;&lt;/card&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import card from '@/components/card'export default &#123; components: &#123; card &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 9.3. 组件传值父组件通过prop来向子组件传递数据。 9.3.1. 父组件在data中定义数据同时在标签上通过属性的方式传递 123456789&lt;!-- template --&gt;&lt;card :text="msg"&gt;&lt;/card&gt;&lt;!-- script --&gt; data () &#123; return &#123; msg: "mpvue" &#125;&#125; 9.3.2. 子组件通过props进行接收 123export default &#123; props: ['text']&#125; 9.4. 组件通信主要有三种方式 子向父 通过$emit 所有的组件之间 通过事件总线 EventBus 企业级的组件通信，建议使用 vuex状态管理方案 来实现，更好维护数据。 9.4.1. 子向父通信通过 $emit关键字触发 父组件中 1234567891011121314151617&lt;template&gt; &lt;card2 @parentEvent="parentHd"&gt;&lt;/card2&gt;&lt;/template&gt;&lt;script&gt; import card2 from "@/components/card2.vue"; export default &#123; components: &#123; card2 &#125;, methods: &#123; parentHd(...args) &#123; console.log(args); console.log("父组件打印纸"); &#125; &#125; &#125;&lt;/script&gt; 子组件中 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['text'], mounted()&#123; setTimeout(() =&gt; &#123; this.$emit("parentEvent",1,2,3,4); &#125;, 5000); &#125;&#125;&lt;/script&gt; 9.4.2. 事件总线 EventBusEventBus 又称为事件总线。它是组件共用的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件。使用起来很方便，但是容器导致代码混乱，不好维护。 新建总线文件 在 utils/中新建 js文件 event-bus.js 12import Vue from 'vue'export default new Vue() 组件中开始触发事件 123456789101112131415161718 &lt;!-- template --&gt; &lt;div&gt; &lt;p class="card" @click="clickHd"&gt; 组件3 &lt;/p&gt; &lt;/div&gt;&lt;script&gt; /* script */ import &#123; EventBus &#125; from "../utils/event-bus.js"; export default &#123; methods: &#123; clickHd() &#123; EventBus.$emit("incremented", &#123; num: 111, deg: 222 &#125;); &#125; &#125; &#125;&lt;/script&gt; 其他页面监听 12345678910import &#123; EventBus &#125; from "@/utils/event-bus.js"; mounted() &#123; EventBus.$on("incremented", (&#123; num, deg &#125;) =&gt; &#123; console.log(num, deg); &#125;); &#125;, 9.5. 不支持的功能 暂不支持在组件引用时，在组件上定义 click 等原生事件、v-show（可用 v-if 代替）和 class style 等样式属性(例：&lt;card class=&quot;class-name&quot;&gt; &lt;/card&gt; 样式是不会生效的)，因为编译到 wxml，小程序不会生成节点，建议写在内部顶级元素上。 Slot（scoped 暂时还没做支持） 动态组件 异步组件 inline-template X-Templates keep-alive transition class style]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Ne</tag>
        <tag>MVVM</tag>
        <tag>MpVue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发]]></title>
    <url>%2F2018%2F11%2F27%2Fn_weChat%2F</url>
    <content type="text"><![CDATA[1. 小程序介绍微信小程序 ( Mini Program ) ，微信创始人 张小龙 ，在2017年1月9日宣布的微信小程序正式上线 1.1. 特点 触手可及，用完即走 拥有和原生APP的体验 用户量大 面向所有用户开放（企业，组织，个人均可以发布自己的小程序） 小程序就是套在 微信里面的原生APP 1.2. 小程序的运行环境1.2.1. 传统原生APP 1.2.2. 微信运行环境 1.2.3. 微信小程序运行环境 1.2.4. 小结问： 微信小程序和原生APP、微信有什么联系？ 答： 微信小程序就是套在微信里的原生APP 2. 开发环境的准备2.1. 注册账号访问注册页面，耐心完成注册即可。 2.2. 获取APPID由于后期调用微信小程序的接口等功能，需要索取开发者的小程序中的APPID，所以在注册成功后，可登录，然后获取APPID。 登录，成功后可看到如下界面 然后复制你的APPID,悄悄的保存起来，不要给别人看到😄。 2.3. 开发工具严格来说，微信小程序支持所有的开发工具，但是从效率和便利性来说，推荐如下 vs code 下载地址 推荐vs code 代码插件 wechat-snippet 文件图标主题 file-icons 微信自己的微信小程序开发工具 下载地址 3. 我的第一个微信小程序下面开始演示如何创建我的第一个微信小程序 3.1. 安装微信小程序开发者工具下载好微信小程序开发者工具后，直接双击安装，一直点击下一步即可。 安装好后，界面如下 3.2. 选择小程序项目 3.3. 新建项目 3.4. 创建项目 3.5. 成功 4. 微信开发工具深入介绍工具介绍 5. mina框架小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。 框架提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。 官网 5.1. 小程序文件结构和传统web对比 结构 传统web 微信小程序 结构 HTML WXML 样式 CSS WXSS 逻辑 Javascript Javascript 配置 无 JSON 通过以上对比得出，传统web 是三层结构。而微信小程序 是四层结构，多了一层 配置.json 5.2. 基本的项目目录 6. 配置介绍一个小程序应用程序会包括最基本的两种配置文件。一种是全局的 app.json 和 页面自己的 page.json 注意：配置文件中不能出现注释 6.1. 全局配置app.jsonapp.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。普通快速启动项目里边的 app.json 配置 123456789101112&#123; &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;:&#123; &quot;backgroundTextStyle&quot;:&quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;, &quot;navigationBarTextStyle&quot;:&quot;black&quot; &#125;&#125; 字段的含义 pages字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。 window字段 —— 定义小程序所有页面的顶部背景颜色，文字颜色定义等。 完整的配置信息请参考 app.json配置 6.2. page.json这里的 page.json 其实用来表示页面目录下的 page.json 这类和小程序页面相关的配置。 开发者可以独立定义每个页面的一些属性，如顶部颜色、是否允许下拉刷新等等。 页面的配置只能设置 app.json 中部分 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。 属性 类型 默认值 描述 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如 #000000 navigationBarTextStyle String white 导航栏标题颜色，仅支持 black / white navigationBarTitleText String 导航栏标题文字内容 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark / light enablePullDownRefresh Boolean false 是否全局开启下拉刷新。 详见 Page.onPullDownRefresh onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px。 详见 Page.onReachBottom disableScroll Boolean false 设置为 true 则页面整体不能上下滚动；只在页面配置中有效，无法在 app.json 中设置该项 7. 视图层WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。 7.1. 数据绑定7.1.1. 普通写法1&lt;view&gt; &#123;&#123; message &#125;&#125; &lt;/view&gt; 12345Page(&#123; data: &#123; message: 'Hello MINA!' &#125;&#125;) 7.1.2. 组件属性1&lt;view id="item-&#123;&#123;id&#125;&#125;"&gt; &lt;/view&gt; 12345Page(&#123; data: &#123; id: 0 &#125;&#125;) 7.1.3. bool类型不要直接写 checked=”false”，其计算结果是一个字符串 1&lt;checkbox checked="&#123;&#123;false&#125;&#125;"&gt; &lt;/checkbox&gt; 7.2. 运算7.2.1. 三元运算1&lt;view hidden="&#123;&#123;flag ? true : false&#125;&#125;"&gt; Hidden &lt;/view&gt; 7.2.2. 算数运算1&lt;view&gt; &#123;&#123;a + b&#125;&#125; + &#123;&#123;c&#125;&#125; + d &lt;/view&gt; 1234567Page(&#123; data: &#123; a: 1, b: 2, c: 3 &#125;&#125;) 7.2.3. 逻辑判断1&lt;view wx:if="&#123;&#123;length &gt; 5&#125;&#125;"&gt; &lt;/view&gt; 7.2.4. 字符串运算1&lt;view&gt;&#123;&#123;"hello" + name&#125;&#125;&lt;/view&gt; 12345Page(&#123; data:&#123; name: 'MINA' &#125;&#125;) 7.2.5. 注意 花括号和引号之间如果有空格，将最终被解析成为字符串 7.3. 列表渲染7.3.1. wx:for项的变量名默认为 item wx:for-item 可以指定数组当前元素的变量名 下标变量名默认为 index wx:for-index 可以指定数组当前下标的变量名 123&lt;view wx:for="&#123;&#123;array&#125;&#125;"&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;&lt;/view&gt; 123456789Page(&#123; data: &#123; array: [&#123; message: 'foo', &#125;, &#123; message: 'bar' &#125;] &#125;&#125;) 7.3.2. wx:for渲染一个包含多节点的结构块 block最终不会变成真正的dom元素 1234&lt;block wx:for="&#123;&#123;[1, 2, 3]&#125;&#125;"&gt; &lt;view&gt; &#123;&#123;index&#125;&#125;: &lt;/view&gt; &lt;view&gt; &#123;&#123;item&#125;&#125; &lt;/view&gt;&lt;/block&gt; 7.3.3. wx:key提高效率使用的 7.4. 条件渲染7.4.1. wx:if在框架中，使用 wx:if=&quot;&quot; 来判断是否需要渲染该代码块： 1&lt;view wx:if="&#123;&#123;condition&#125;&#125;"&gt; True &lt;/view&gt; 7.4.2. hidden1&lt;view hidden="&#123;&#123;condition&#125;&#125;"&gt; True &lt;/view&gt; 类似 wx:if 频繁切换 用 hidden 不常使用 用 wx:if 8. WXSSWXSS(WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。 与 CSS 相比，WXSS 扩展的特性有： 尺寸单位 样式导入 8.1. 尺寸单位 rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。 设备 rpx换算px (屏幕宽度/750) px换算rpx (750/屏幕宽度) iPhone5 1rpx = 0.42px 1px = 2.34rpx iPhone6 1rpx = 0.5px 1px = 2rpx iPhone6 Plus 1rpx = 0.552px 1px = 1.81rpx 建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。 注意： 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。 8.2. 样式导入使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。 示例代码： 1234/** common.wxss **/.small-p &#123; padding:5px;&#125; 12345/** app.wxss **/@import "common.wxss";.middle-p &#123; padding:15px;&#125; 8.3. 内联样式框架组件上支持使用 style、class 属性来控制组件的样式。 style：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。 1&lt;view style="color:&#123;&#123;color&#125;&#125;;" /&gt; class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上.，样式类名之间用空格分隔。 1&lt;view class="normal_view" /&gt; 8.3.1. 选择器目前支持的选择器有： 选择器 样例 样例描述 .class .intro 选择所有拥有 class=”intro” 的组件 #id #firstname 选择拥有 id=”firstname” 的组件 element view 选择所有 view 组件 element, element view, checkbox 选择所有文档的 view 组件和所有的 checkbox 组件 ::after view::after 在 view 组件后边插入内容 ::before view::before 在 view 组件前边插入内容 8.3.2. 全局样式与局部样式定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。 9. 基本组件 小程序提供了常用的标签组件用于构建页面 组件 9.1. view 类似 div 属性名 类型 默认值 说明 hover-class String none 指定按下去的样式类。当 hover-class=&quot;none&quot; 时，没有点击态效果 9.1.1. 代码1234567&lt;view hover-class="h-class"&gt;点击我试试&lt;/view&gt;&lt;!-- wxss --&gt;.h-class&#123; background-color: yellow;&#125; 9.2. text 显示普通的文本 text只能嵌套text 属性名 类型 默认值 说明 selectable Boolean false 文本是否可选 decode Boolean false 是否解码 9.2.1. 代码123&lt;text selectable="&#123;&#123;false&#125;&#125;" decode="&#123;&#123;false&#125;&#125;"&gt; 普&amp;nbsp;通&lt;/text&gt; 9.3. image 图片标签，image组件默认宽度320px、高度240px 注意：该标签 其实是 web中的 图片标签 和 背景图片的结合！！！ 并且不支持以前的web中的背景图片的写法！！！ 属性名 类型 默认值 说明 src String 图片资源地址，支持云文件ID（2.2.3起） mode String ‘scaleToFill’ 图片裁剪、缩放的模式 lazy-load Boolean false 图片懒加载。只针对page与scroll-view下的image有效 mode 有效值： mode 有 13 种模式，其中 4 种是缩放模式，9 种是裁剪模式。 模式 值 说明 缩放 scaleToFill 不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素 缩放 aspectFit 保持纵横比缩放图片，使图片的长边能完全显示出来。 缩放 aspectFill 保持纵横比缩放图片，只保证图片的短边能完全显示出来。 缩放 widthFix 宽度不变，高度自动变化，保持原图宽高比不变 裁剪 top 不缩放图片，只显示图片的顶部区域 裁剪 bottom 不缩放图片，只显示图片的底部区域 裁剪 center 不缩放图片，只显示图片的中间区域 裁剪 left 不缩放图片，只显示图片的左边区域 裁剪 right 不缩放图片，只显示图片的右边区域 裁剪 top left 不缩放图片，只显示图片的左上边区域 裁剪 top right 不缩放图片，只显示图片的右上边区域 裁剪 bottom left 不缩放图片，只显示图片的左下边区域 裁剪 bottom right 不缩放图片，只显示图片的右下边区域 9.4. swiper 微信内置有轮播图组件 默认宽度 100% 高度 150px 属性名 类型 默认值 说明 indicator-dots Boolean false 是否显示面板指示点 indicator-color Color rgba(0, 0, 0, .3) 指示点颜色 indicator-active-color Color #000000 当前选中的指示点颜色 autoplay Boolean false 是否自动切换 interval Number 5000 自动切换时间间隔 9.4.1. swiper滑块视图容器。 9.4.2. swiper-item 滑块 默认宽度和高度都是100% 9.5. navigator 导航组件 类似超链接标签 属性名 类型 默认值 说明 target String self 在哪个目标上发生跳转，默认当前小程序，可选值self/miniProgram url String 当前小程序内的跳转链接 open-type String navigate 跳转方式 open-type 有效值： 值 说明 navigate 保留当前页面，跳转到应用内的某个页面，但是不能跳到 tabbar 页面 redirect 关闭当前页面，跳转到应用内的某个页面，但是不允许跳转到 tabbar 页面。 switchTab 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 reLaunch 关闭所有页面，打开到应用内的某个页面 navigateBack 关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层 exit 退出小程序，target=”miniProgram”时生效 10. 自定义组件小程序允许我们使用自定义组件的方式来构建页面。 自定义组件 10.1. 创建自定义组件 类似于页面，一个自定义组件由 json wxml wxss js 4个文件组成 10.1.1. 声明组件首先需要在 json 文件中进行自定义组件声明 123&#123; &quot;component&quot;: true&#125; 10.1.2. 编辑组件同时，还要在 wxml 文件中编写组件模板，在 wxss 文件中加入组件样式 注意：在组件wxss中不应使用ID选择器、属性选择器和标签名选择器。 12345&lt;!-- 这是自定义组件的内部WXML结构 --&gt;&lt;view class="inner"&gt; &#123;&#123;innerText&#125;&#125;&lt;/view&gt;&lt;slot&gt;&lt;/slot&gt; 1234/* 这里的样式只应用于这个自定义组件 */.inner &#123; color: red;&#125; 10.1.3. 注册组件在自定义组件的 js 文件中，需要使用 Component() 来注册组件，并提供组件的属性定义、内部数据和自定义方法 1234567891011121314151617Component(&#123; properties: &#123; // 这里定义了innerText属性，属性值可以在组件使用时指定 innerText: &#123; type: String, value: &apos;default value&apos;, &#125; &#125;, data: &#123; // 这里是一些组件内部数据 someData: &#123;&#125; &#125;, methods: &#123; // 这里是一个自定义方法 customMethod: function()&#123;&#125; &#125;&#125;) 10.2. 使用自定义组件首先要在页面的 json 文件中进行引用声明。还要提供对应的组件名和组件路径 1234567&#123; // 引用声明 &quot;usingComponents&quot;: &#123; // 要使用的组件的名称 // 组件的路径 &quot;component-tag-name&quot;: &quot;path/to/the/custom/component&quot; &#125;&#125;]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Ne</tag>
        <tag>weChat</tag>
        <tag>mina</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVVM框架进阶与实现]]></title>
    <url>%2F2018%2F11%2F14%2Fn_myVue%2F</url>
    <content type="text"><![CDATA[MVVM框架介绍介绍 M ：Modal 模型层 V ：View 视图层 VM ： ViewModal 视图模型，V和M的桥梁 MVVM框架实现了数据双向绑定 当M层数据进行修改时，VM层会检测到变化，并且通知V层进行相应的修改； 修改V层则会通知M层数据进行修改 MVVM框架实现了视图和模型层的相互解耦 几种双向数据绑定的方式 发布-订阅者模式（backbone.js）一般通过pub、sub的方式来实现数据和视图的绑定，但是使用比较麻烦 脏值检查（anjular.js）angular.js是通过脏值检测的方式对数据是否有变更，来决定是否更新视图。类似于通过定时器轮训检测数据是否发生了改变； 数据劫持vue.js是通过数据劫持结合发布者-订阅者的方式。通过Object.defineProperty()来劫持各个属性的setter、getter，在数据发生变动的时候发布消息给订阅者，触发相应的监听回调 Vue实现思路 实现一个Compile模板解析器，能够对模板中的指令和插值表达式进行解析，并且赋予不同的操作 实现一个Observe数据监听器，能够对数据对象的所有属性进行监听 实现一个Watcher观察者，将Compile的解析结果，与Observer所观察的对象链接起来，建立关系，在Observer观察对象到对象数据变化时，接受通知，同时更新DOM 创建一个公共的入口对象，接受初始化的配置并且协调上面三个模块，也就是Vue Compile实现逻辑创建文件 需要基本的html文件，vue.js文件，并且引入并且实例化vue对象 123456789101112131415161718192021&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p v-text="msg"&gt;&lt;/p&gt; &lt;p v-html="msg"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="./src/compile.js"&gt;&lt;/script&gt;&lt;script src="./src/vue.js"&gt;&lt;/script&gt;&lt;script&gt; var el = new Vue(&#123; el: '#app', data: &#123; msg: "hello vue" &#125; &#125;) console.log(el)&lt;/script&gt;&lt;/html&gt; 创建vue对象 123456789101112class Vue &#123; constructor(option = &#123;&#125;) &#123; this.$el = option.el; this.$data = option.data; if (this.$el) &#123; //compile负责解析模板的内容 new Compile(this.$el, this) &#125; &#125;&#125; 创建Compile模板解析器、 123456789class Compile &#123; constructor(el, vm) &#123; //允许用户传递的dom对象可以是真实Dom或者是选择器 this.el = typeof el === 'string' ? document.querySelector(el) : el; this.vm = vm; &#125;&#125; 创建文本碎片DocumentFragments 是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。 因为文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。 关于createDocumentFragment方法 12345678910111213141516171819202122232425if (this.el) &#123; let fragment = this.node2fragment(this.el)&#125; /** * 核心方法-生成文档碎片 * @param &#123;根Dom对象&#125; node */ node2fragment(node) &#123; let fragment = document.createDocumentFragment(); let childNodes = node.childNodes; this.toArray(childNodes).forEach(node =&gt; &#123; fragment.appendChild(node); &#125;); &#125; /** * 工具方法-类数组转化数组 * @param &#123;类数组&#125; likeArray */ toArray(likeArray) &#123; return [].slice.call(likeArray) &#125; 根据类型解析节点 区分是文本节点还是元素节点来分别解析 使用递归层层解析 123456789101112131415/** * 工具方法-类数组转化数组 * @param &#123;类数组&#125; likeArray */toArray(likeArray) &#123; return [].slice.call(likeArray)&#125;/** * 判断是否是元素节点 * @param &#123;node&#125; node */isElementNode(node) &#123; return node.nodeType === 1;&#125; 解析元素节点 需要分别解析v-text v-html v-modal指令 v-on指令因为类型原因需要特别解析 1234567891011121314151617181920212223242526272829/** * 解析元素节点 * @param &#123;节点&#125; node */compileElement(node) &#123; // 1.获取所有当前节点下的属性 let attributes = node.attributes; this.toArray(attributes).forEach((attr) =&gt; &#123; let attrName = attr.name; if (this.isDirective(attrName)) &#123; let type = attrName.slice(2); let attrValue = attr.value; if (type === 'text') &#123; node.textContent = this.vm.$data[attrValue]; &#125; if (type === 'html') &#123; node.textContent = this.vm.$data[attrValue]; &#125; if (type === 'modal') &#123; node.value = this.vm.$data[attrValue]; &#125; if (this.isEventDirective(type)) &#123; let eventType = attrName.split(':')[1]; node.addEventListener(eventType, this.vm.$methods[attrValue].bind(this.vm)) &#125; &#125; &#125;)&#125; 解析文本节点12345678910111213141516171819//解析文本节点mustache(node, vm) &#123; let txt = node.textContent; let reg = /\&#123;\&#123;(.+)\&#125;\&#125;/; if (reg.test(txt)) &#123; let expr = RegExp.$1; node.textContent = txt.replace(reg, this.getVMValue(vm, expr)) &#125;&#125;, //获取VM中的数据getVMValue(vm, expr) &#123; let data = vm.$data; expr.split('.').forEach(key =&gt; &#123; data = data[key] &#125;) return data;&#125; Observer实现逻辑关于数据劫持关于Object.defineProperty方法 configurable当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。 enumerable当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。 get一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为 undefined。 set一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为 undefined。 简单案例12345678910111213141516171819var obj = &#123; name: 12,&#125;var temp = obj.name;Object.defineProperty(obj, 'name', &#123; configurable: true, enumerable: true, get() &#123; console.log(obj) return temp; &#125;, set(newValue) &#123; console.log(newValue) temp = newValue console.log(obj) &#125;&#125;) observer实现 观察者目的是使用数据劫持检测$data下的所有数据（为什么天赐还没成大佬） 1new Observer(this.vm.$data); 使用Object.keys(data)方法获取所有key，并通过Object.defineProperty为所有数据添加绑定（为什么天赐还没成大佬） 为了绑定复杂数据，需要进行递归操作（为什么天赐还没成大佬） 在set函数中，设置了新的数据，也需要进行监控（为什么天赐还没成大佬） 123456789101112131415161718192021222324252627282930313233constructor(data) &#123; this.walk(data);&#125;walk(data) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; Object.keys(data).forEach((key) =&gt; &#123; this.defineReactive(data, key, data[key]) this.walk(data[key]) &#125;)&#125;defineReactive(obj, key, value) &#123; const self = this; Object.defineProperty(obj, key, &#123; configurable: true, enumerable: true, get() &#123; console.log('获取了', value) return value; &#125;, set(newvalue) &#123; if (newvalue === value) &#123; return &#125; console.log('设置了', newvalue) value = newvalue; self.walk(value) &#125; &#125;)&#125; Wacher实现逻辑已经实现了页面渲染compile以及数据监听observer，接下来是将数据和页面做一个连接，即是，数据发生改变之后通知compile重新渲染，compile发生改变之后通知observer更改数据，接下来的watcher作为一个连接中心，实现这一部分的功能； 创建watcher对象初始化需要传递三个变量 vm:vue对象实例 expr:数据对象 cb:callback回调函数 123456constructor(vm, expr, cb) &#123; this.vm = vm; this.expr = expr; this.cb = cb; this.oldValue = this.getVMValue(vm, expr);&#125; 创建更新数据函数12345678update() &#123; let oldValue = this.oldValue; let newValue = this.getVMValue(this.vm, this.expr) if (oldValue !== newValue) &#123; this.cb(newValue, oldValue) &#125;&#125; 实例化watcher对象12345678//解析v-text指令text(node, vm, expr) &#123; node.textContent = this.getVMValue(vm, expr) window.Watcher = new Watcher(vm, expr, (newVlaue, oldValue) =&gt; &#123; console.log(newVlaue, '打印newValue') node.textContent = newVlaue &#125;)&#125;, 获取新值调用update123456789set(newvalue) &#123; if (newvalue === value) &#123; return &#125; console.log('设置了', newvalue) value = newvalue; window.Watcher.update(); self.walk(value)&#125; 使用订阅发布者模式检测数值改变 声明发布者构造函数 订阅检测对象 实例化检测data中的每一个属性 12345678910111213141516class Dep &#123; constructor() &#123; this.subs = []; &#125; addSub(watcher) &#123; this.subs.push(watcher) &#125; notify() &#123; this.subs.forEach(sub =&gt; &#123; sub.update(); &#125;) &#125;&#125; 12345678910111213141516171819202122232425262728Dep.target = this;this.oldValue = this.getVMValue(vm, expr);Dep.target = null;//observer.jsdefineReactive(obj, key, value) &#123; const self = this; let dep = new Dep(); Object.defineProperty(obj, key, &#123; configurable: true, enumerable: true, get() &#123; Dep.target &amp;&amp; dep.addSub(Dep.target) return value; &#125;, set(newvalue) &#123; if (newvalue === value) &#123; return &#125; value = newvalue; dep.notify(); self.walk(value) &#125; &#125;)&#125; 实现双向数据绑定123456789101112 node.addEventListener('input', function() &#123; var arr = expr.split('.'); var data = vm.$data; arr.forEach((v, i) =&gt; &#123; if (i == arr.length - 1) &#123; data[v] = this.value; &#125; else &#123; data = data[v]; &#125; console.log(data); &#125;)&#125;) 将数据挂载到vue对象中12345678910111213141516171819202122232425262728293031class Vue &#123; constructor(option = &#123;&#125;) &#123; this.$el = option.el; this.$data = option.data; this.$methods = option.methods; new Observer(this.$data); this.porxy(this.$data) this.porxy(this.$methods) if (this.$el) &#123; //compile负责解析模板的内容 let c = new Compile(this.$el, this); &#125; &#125; porxy(data) &#123; Object.keys(data).forEach((key) =&gt; &#123; Object.defineProperty(this, key, &#123; configurable: true, enumerable: true, get() &#123; return data[key] &#125;, set(newvalue) &#123; if (data[key] === newvalue) &#123; return &#125; data[key] = newvalue; &#125; &#125;) &#125;) &#125;&#125;]]></content>
      <categories>
        <category>JavaScript Advanced</category>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Ne</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flow&TypeScript]]></title>
    <url>%2F2018%2F10%2F29%2Fn_flow_typeScript%2F</url>
    <content type="text"><![CDATA[Javscript语言特征介绍JavaScript是一种弱类型，动态类型检查的语言 弱类型和强类型弱类型在定义变量的时候，我们可以为变量赋值任何数值，变量的数据类型不是固定死的，这样的类型叫做弱类型 强类型在声明变量的时候，一旦给变量赋值，那么变零的数据类型已经确定，之后如果要给该变量赋值其他类型的数据，需要进行强制数据类型转换； 动态类型和静态类型动态类型和静态类型的核心区别：动态类型的类型检查会在代码运行的时候进行，而静态类型检查则是在编译时候进行； FlowFlow官网 安装步骤12npm init -y npm i flow-bin -D 使用步骤声明flow需要给文件添加@flow 标记，否则flow不会对文件进行类型检测 1//@flow 书写方式 通过注释的方式进行添加（不会改写js） 123var a /*:number */ = 12;a = "111";console.log(a) 通过直接给数据添加类型，改写js代码，如果需要正常运行，需要进行babel进行转码 123var a: number = 12;a = 1;console.log(a); 使用flow进行检查 在package.json中添加命令 1"flow": "flow" 创建flow配置文件.flowconfig1npm run flow init 使用babel对flow进行转码如果给数据添加类型声明通过第二种方式，直接修改js代码，那么代码是不能正常运行的； 我们需要通过babel对代码进行转码之后才能正常进行 安装bebel以及persets 1npm i babel-cli babel-preset-flow -D 新建 .babelrc文件并添加配置 12345&#123; &quot;presets&quot;: [ &quot;flow&quot; ]&#125; 配置package.json 添加build命令调用babel 12&quot;build&quot;:&quot;babel ./src -d ./dist&quot; 执行build命令进行转换 Flow的数据类型类型说明 类型 说明 number 数字、NaN、Infinity都是number类型的数据 string 字符串 null 只有null是null类型的 void undefined在flow中类型就是void Array 数组类型，定义的时候需要使用 Array这种形式，T为指定的类型，说的是特定类型的数据组成的数组 Object 对象类型，由于对象比较自由，可以规定对象类型的时候有多中写法 any 表示任意类型，这个尽量少用，但是有时有很有用 Functions 函数类型 Maybe Maybe类型允许我们声明一个包含null和undefined两个潜在类型的值 或操作 或操作可以设置一个变量为多种可能的类型 类型判断 flow会常识自行腿短某个数据的类型 部分案例12345678910111213141516171819202122232425262728293031323334353637383940//@flow//1.数组let a: Array &lt; number &gt; = [1, 2, 3];//2.函数function test(a: number, b: number): number &#123; return a + b;&#125;;test(1, 2);//3.maybefunction test2(a: ? number) &#123; a = a || 0; console.log(a)&#125;test2()test2(1)//3.或 |let b: number | string = 1;b = 1;b = '1'//4.Objectfunction greet(obj: &#123; sayHello: () =&gt; void, name: string &#125;) &#123; obj.sayHello();&#125; TypeScript介绍TypeScript是微软公司开发的一种开源的JavaScript超集语言 JavaScript超集：当前任何JavaScript都是合法的TypeScript代码 TypeScript主要是为JavaScript提供了类型系统和ES6的语法支持； Flow是一个类型检查工具，而TypeScript是一种开发语言 TypeScript有自己的编译工具，我们写好的TypeScript代码最终通过编译器编译成JavaScript代码进行运行 安装TypeScriptTypeScript代码最终要运行起来，我们需要编译成JavaScript代码，那么TypeScript的命令工具就可以帮我们完成；TypeScript命令行工具安装方法如下： 1npm install -g typescript 以上命令会在全局安装typescript命令，完成之后可以在任何地方执行tsc命令 1tsc index.js TypeScript配置文件生成tsconfig.json文件1tsc --init 设置配置项 targe：指的就是将ts代码要转换成那个版本的es5，es3 module：指的就是将ts代码转换成js代码之后，使用的模块化的标准是什么 outDir：指的就是ts代码转成js之后，js代码存放的文件夹路径 rootDir：指的就是要将哪个目录的ts代码进行转换；ts代码的存放路径 strict：是否要将ts代码转换成严格模式的js代码 使用配置文件1tsc -p ./tsconfig.js 数据类型数字（Number）数字类型可以是普通数字、NaN、Infinity,包括可以赋值二进制，八进制，16进制等（0x:16进制、0b:2进制、0o:8进制） 12345let b: number = Infinity;let n2: number = 0xA12;let n3: number = 0b1010;let n4: number = 0o75; 字符串（String）字符串类型可以使用单引号、双引号以及ES6的模板字符串； 123let str:string = "abc";let str2:string = "$&#123;str&#125;def" 数组（Array）数组可以使用两种方式声明 123let arr :Array&lt;number&gt; = [2,3,4];let arr2:number[] = [1,2,3] 元祖（Tuple）12let arr2 = [number,string] = [1,'a]; 空值 （void）1let res:void = undefined; 对象（Object）123let o:object =&#123;&#125;;let o2 Nevernever类型表示的是永不存在的值，例如，never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式；变量也可能是never类型，当它们被永不为真的类型保护所约束时 1234567891011121314function error(message:string):never&#123; throw new Error(message)&#125;function fail(message:string)&#123; return error(message)&#125;function infinitloop():never &#123; while(true)&#123;&#125;&#125; 枚举（enum）enum类型是对JavaScript标准类型的一个补充。可以未一组数值赋予友好的名字 1234enum Color &#123; Red, Green,&#125; 默认情况下，从0开始为元素编号，也可以手动为指定成员赋值 12345enum Color &#123; Red = 1, Green = 2,&#125; 类型断言有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息，通常这会发生在你清除的知道一个实体具有比他现有类型更确切的类型。 通过类型断言这种方式可以告诉浏览器，类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。 123456let someVal:any = 'this is a string';// 断言1let someLen:number =(&lt;string&gt;someVal).length;// 断言2let someLe2:number =(someVal as string).length; 两种方式是等价的，但是当在TypeScript中使用JSX时，只有as语法断言是被允许的； TypeScript中的类基本使用 和ES6不同的是，TS中属性必须声明，需要指定类型 声明好属性之后，属性必须赋值一个默认值或者在构造函数中进行初始化 12345678class Person &#123; name: string age: number = 12 constructor(name: string) &#123; this.name = name; &#125;&#125; 继承 继承类的时候在constructor调用super方法； 子类中如果出现和父类同名的方法，则会进行覆盖，调用的会后调用的是子类的方法； 1234567class Teacher extends Person &#123; type: string constructor(type: string) &#123; super('12') this.type = type &#125;&#125; 访问修饰符 public ：公共，默认 private：私有的，只能在当前类中进行访问 protected：受保护的，这能在当前类或者子类中进行访问 readonly修饰符可以使用readonly关键字将属性设置为只读，只读属性必须在声明时活构造函数里面被初始化 参数属性可以方便的让我们在一个地方定义并初始化一个成员 12345class Anmial &#123; constructor(private name:string)&#123;&#125; &#125; 类成员的存取器在set的时候可以根据需求判断是否执行操作； 123456789class People&#123; private _name:string = ""; get name():string&#123; return this._name &#125; set name(value:string)&#123; this._name = value; &#125;&#125; TypeScript的接口基本使用接口可以理解为一个约定或者一种规范 12345678910111213141516171819interface AjaxOptins&#123; url:string type:string data:object success(data:object):void;&#125;function ajax(options:AjaxOptins)&#123;&#125;ajax(&#123; url:"http", type:'post', data:&#123;&#125;, success(data:object)&#123; &#125;&#125;) 接口的可选属性以及只读属性可选属性：?1234567891011121314151617181920interface AjaxOptins&#123; url:string //type加了可选属性，代表，type不是必须的值，是可选的 type?:string data:object success(data:object):void;&#125;function ajax(options:AjaxOptins)&#123;&#125;ajax(&#123; url:"http", data:&#123;&#125;, success(data:object)&#123; &#125;&#125;) 只读属性123456789101112interface Point&#123; readonly x:number y:number&#125;let poi:Point = &#123; x:10, y:10,&#125;//x为只读属性，重新赋值就会报错poi.x =100; 接口的额外属性检查可以在指定范围以外设置其他属性 1234567891011121314interface Point&#123; readonly x:number y:number, //设置了额外的属性检查才可以为下面的增加z属性 [propName:string]:any,&#125;let poi:Point = &#123; x:10, y:10, z:19,&#125; 函数类型接口12345678interface SumInterface&#123; (a:number,b:number):number&#125;let sum:SumInterface = function(a:number,b:number)&#123; return a+b&#125; 类类型12345678910interface ClockInterFace&#123; currentTime:Date,&#125;class Clock implements ClockInterFace&#123; currentTime:Date = new Date() constructor(h:number,m:number)&#123; &#125;&#125; 接口继承接口123456789101112131415interface TwoPointP &#123; x: number, y: number,&#125;interface ThreePointP extends TwoPointP &#123; z: number&#125;//必须指定x,y,z三项内容才可以let poi2: ThreePointP = &#123; z: 100, x: 100, y: 100&#125; 接口继承类当接口继承一个类类型，他会继承类的成员但是不包括其实现。就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。接口同样会继承到类的private和protected成员。这意味着当你创建了一个接口继承了一个拥有私有或者被保护的成员的类时，这个接口类型只能被这个类或其子类所实现implement。 当你有一个庞大的继承结构这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用，除了继承自基类，子类之间不必相关联。 1234567891011121314class Animal &#123; name:string ="" eat()&#123;&#125;&#125;interface AnimalInterFace extends Animal&#123;&#125;class Bird implements AnimalInterFace &#123; name:string = "12" eat()&#123;&#125;&#125;]]></content>
      <categories>
        <category>JavaScript Advanced</category>
      </categories>
      <tags>
        <tag>Ne</tag>
        <tag>TypeScript</tag>
        <tag>Flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架原理与进阶]]></title>
    <url>%2F2018%2F10%2F25%2Fn_framework%2F</url>
    <content type="text"><![CDATA[前端工程化工具模块化关于模块化模块化是一种将系统分离成独立功能部分的方法，可将系统分割成独立的功能部分，严格定义模块接口、模块间具有透明性。 优点 灵活架构，焦点分离 方便模块间组合、分解 方便单个模块功能调试、升级 多人协作互不干扰 发展历程 script标签 ComonJS AMD CMD UMD ES6 工具Webpackhttps://webpack.js.org 基本概念: 1Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 优势: 123451、代码拆分2、Loader3、智能解析4、插件系统5、快速运行 实战之基本演练: 12345678910111213141516171819202122232425262728293031323334353637383940414243打包单个js文件 1、新建一个项目的入口文件entry.js并且在里面写好内容 2、一定要切换到项目根目录，使用 webpack entry.js bundle.js 3、在项目根目录，创建index.html，导入bundle.js文件 4、运行 打包具有依赖关系的两个js文件 1、新建两个文件 entry.js module.js ，并且在里面写好导出 导入的代码 2、一定要切换到项目根目录，使用 webpack entry.js bundle.js 3、在项目根目录，创建index.html，导入bundle.js文件 4、运行 打包非js(以后css)文件 1、新建一个site.css文件，里面写上内容 2、一定要切换到项目根目录，使用 webpack entry.js bundle.js 3、我们需要安装两个load来打包css文件 npm i style-loader css-loader -D 4、使用style-loader &amp; css-loader 来打包css文件 4.1、再导入css的时候，使用style-loader css-loader 4.2、在终端里面对css结尾的文件统一处理 webpack.config.js的使用 作用:简化在终端里面输入的很长的打包指令 1、项目根目录下创建webpack.config.js 2、在webpack.config.js中配置 entry output loader github案例 实战之和VueJS结合使用 1234567891011121314151617181920212223242526272829303132333435webpack + vue 构建项目【实现热更新，看到Hello Vue】#### 新建基本的文件和文件夹 1、创建一个项目的根目录 szhmqd18 |--src 项目的源代码目录 |--main.js 项目的入口文件 |--App.vue 根组件【项目启动之后看到的第一个组件】 |--package.json 项目配置文件 npm init -y |--webpack.config.dev.js 项目开发阶段的配置文件#### 在新建的文件中写代码 App.vue 写上hello Vue main.js 导入根组件【使用es6的语法】，渲染根组件【利用Vue】 webpack.config.dev.js entry #### 利用 webpack-dev-server + html-webpack-plugin 运行我们的项目 webpack-dev-server【只是打包生成了bundle.js】 webpack-dev-server --progress --config webpack.config.dev.js --open --hot 把上面的指令，放在package.json的scripts中 "dev":"webpack-dev-server --progress --config webpack.config.dev.js --open --hot" html-webpack-plugin【帮我们生成index.html并且自动导入bundle.js】 安装包 在 webapck.config.dev.js 中配置 Parcelhttps://parceljs.org/ 基本概念: 1极速零配置Web应用打包工具 优势: 1234561、极速打包2、将你所有的资源打包3、自动转换4、零配置代码分拆5、热模块替换6、友好的错误日志 实战之基本使用 1234567891、首先通过 Yarn 或者 npm 安装 Parcel npm install -g parcel-bundler2、创建一个 index.html 和 index.js 文件，并且写好代码3、打包 parcel index.html4、打开浏览器 parcel index.html --open 实战之和VueJS结合使用 1234567891、首先，我们需要安装 Vue 的依赖关系。 npm install --save vue npm install --save-dev parcel-bundler2、向 package.json 的 scripts 中添加 start 脚本。 // package.json "scripts": &#123; "start": "parcel index.html" &#125; Rolluphttps://www.rollupjs.com/guide/zh 基本概念: 1Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。 优势: 1231、静态分析2、小巧而专一 实战之打包流行库 1231、写一个js库2、使用rollup打包]]></content>
      <categories>
        <category>JavaScript Advanced</category>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Webpack</tag>
        <tag>Vue</tag>
        <tag>Ne</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初步实现Axios]]></title>
    <url>%2F2018%2F09%2F11%2Fmy-axios%2F</url>
    <content type="text"><![CDATA[关于Axiosaxios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止CSRF/XSRF 本次主要实现浏览器的XMLHttpRequest请求，使用原生方法，使用promise封装实现； 关于原生Ajax初步认识ajax12345678var xhr = new XMLHttpRequest();xhr.open('get', 'http://localhost:3002/login', true);xhr.send();xhr.onreadystatechange = function() &#123; console.log(xhr.readyState) console.log(xhr.responseText) console.log(xhr.status)&#125;; 详细解析构建对象使用XMLHttpRequest构造函数构造ajax对象，注意此方法在IE有兼容行兼容写法 1234567var xhr = null;if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest();&#125; else &#123; // xhr = new ActiveXObject('Microsoft.XMLHTTP'); xhr = new ActiveXObject('Microsoft.XMLHTTP');&#125; 参数open方法参数： type（post、get） url：路径 async：是否异步：true、false如果是同步情况下，获得文本内容不用使用回调函数，直接xhr.responseText就可以 发送参数send方法 get请求默认null； post请求根据请求数据格式设置不同的请求头 1json:xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); 处理响应处理相应方法为onreadystatechange回调函数 关于readyState： 0：xhr对象初始化 1：执行发送动作 2：服务端数据已经完全返回 3：数据正在解析 4：数据解析完成，可以使用了 原生封装123456789101112131415161718192021222324252627282930function myAjax(type, url, param, callback) &#123; //Ajax语法结构 var xhr = null; if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123; // xhr = new ActiveXObject('Microsoft.XMLHTTP'); xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; if (type == 'get') &#123; url += '?' + encodeURI(param); &#125; xhr.open(type, url); var data = null; if (type == 'post') &#123; //如果是post提交，需要将参数传给send； data = param; //设置请求头 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); &#125; xhr.send(data); //处理响应 xhr.onreadystatechange = function() &#123; if (xhr.status == 200 &amp;&amp; xhr.readyState == 4) &#123; var result = xhr.responseText; result = JSON.parse(result) callback(result); &#125; &#125;;&#125;]]></content>
      <categories>
        <category>JavaScript Base</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解闭包、作用域]]></title>
    <url>%2F2018%2F08%2F22%2Fclosure2%2F</url>
    <content type="text"><![CDATA[局部作用域和垃圾回收机制1234567891011function a() &#123; var b = 12;&#125;// a();function c() &#123; d = 12;&#125;c();// delete window.d;console.dir(window.d) js的垃圾回收机制(GC:Garbage Collecation)会定期清除无用的变量，释放内存空间，首先释放的就是生命周期结束的变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，所以，在函数执行完之后打印b是会报错的此处说明一下函数c内部的情况，声明变量不加var，为隐式声明，可以理解为window.d = 12；注意虽然是叫隐式声明，但是b此时并不是一个变量，而是window的一个属性，下面会专门找时间把变量和属性的区别描述清楚； 全局对象的属性和函数声明（这个属于插一曲）12345678var e = 123;window.f = 1213console.log(f)delete window.edelete window.fconsole.dir(e)console.log(window); 全局函数声明虽然也是挂载到window下的一个属性，但是函数声明和属性的区别是，函数声明拥有不可删除性，通过delect方法无法删除 局部作用域和闭包1234567891011//闭包案例function z() &#123; var num = 0; return function() &#123; return num++ &#125;&#125;var y = z();console.dir(z)console.log(y())console.log(y()) 调用一次返回值+1；正常函数调用完之后，局部作用域内声明的变量会被清除，但是如果在局部作用域函数有函数引用变量，形成闭包环境，该变量则不会清除，就会挂载到该局部作用域；所以函数调用一次就会增加一次形成一个缓存的作用，这也是为什么闭包会容易造成内存溢出的原因；//即使是局部作用域的函数未清除，全局作用域仍然无法获取该变量；所以这也是自执行函数IFEE能够形成自己独立区域的原因，防止变量污染； 块级作用域1234567891011121314//所谓的块级作用域就是&#123;&#125;&#123; var aa = 1&#125;console.log(aa) //1;//使用var声明变量没有块级作用域，常见的还有for循环中的变量i值&#123; let bb = 1; console.log(bb) //1;&#125;console.log(bb) //: bb is not defined// 使用es6的let和const可以生成一个块级作用域，所以之前的自调用函数，可以使用&#123;&#125;代替]]></content>
      <categories>
        <category>JavaScript Advanced</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Closure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的jQuery]]></title>
    <url>%2F2018%2F08%2F18%2Fmine-jQuery%2F</url>
    <content type="text"><![CDATA[序这个可能是一篇长博客，打算模拟jQuery的写法已经很长时间了，也看过jQuery的源码，当时看的时候晦涩难懂，基础实在不好，近一年时间一直用框架开发，忽然看到了一条新闻：2018年7月25日，Mislav Marohnić发了一条推文，宣布GitHub.com前端已经前端已经彻底删除了jQuery。而且，还自问自答地解释（低调炫耀），删除jQuery之后也没用其他框架，而是全部依赖原生API。突然才发现，原来jQuery已经距离我也越来越遥远了，这个也算是一种缅怀吧； 模拟主要思路模拟jquery首先看他的主要用法：12345$("#btn1") //获取元素$("#btn1").click(function()&#123;&#125;); //绑定事件$("#btn1").css() //设置css样式$("#btn1").text() //设置或返回所选元素的文本内容$("#btn1").html() //设置或返回所选元素的内容（包括 HTML 标记） 主要思路 $是一个方法，参数是id，css，tagName都可以，返回值为dom元素； jQuery内部隐式迭代，所以返回值是一个dom集合； css，html，click都是方法，挂在到$方法的返回值；综上所述，所谓的$以及调用之后的样子应该是 1234567891011121314151617181920212223// 第一 $是一个函数function $()&#123; return doms //dom集合&#125;// 第二 实现所有方法在一个集合内部var obj =&#123; css:function()&#123;&#125;, text:function()&#123;&#125;,&#125;//第三实现将$函数返回值继承obj，//继承方法又很多，常用原型链继承的方法function init()&#123;&#125;init.prototype = obj;function $()&#123; return new init() //dom集合&#125;// 第四实现返回值内部为所有dom对象的操作// 借助call和apply特殊的方法function init()&#123; [].push.apply(this, document.querySelectorAll(select))&#125; 实现主要逻辑代码123456789101112131415161718192021222324(function(w) &#123; //为了以后能方便借用数组的各种方法，提前存到变量中，全局都是用这一个数组，节约空间 function jQuery(select) &#123; return new init(select) &#125; //模拟jQuery中的Sizzle引擎，利用选择器获取元素 function Sizzle(select) &#123; return document.querySelectorAll(select); &#125; function init(select) &#123; [].push.apply(this, Sizzle(select)); return this; &#125; init.prototype = &#123; css: function() &#123; &#125; &#125; window.jQuery = window.$ = jQuery;&#125;)(window) 写完之后基本就可以使用了，下次将方法逐个实现；]]></content>
      <categories>
        <category>HTML/CSS Advanced</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于递归-树状结构]]></title>
    <url>%2F2018%2F08%2F17%2Fabout-recursion%2F</url>
    <content type="text"><![CDATA[关于需求树状结构数据，需要为每一层增加一个索引值，第一层数据1，第二层2，以此类推；123456789101112131415161718var tree = [&#123; a: 1, children: [&#123; a: 1, children: [&#123; a: 1, &#125;] &#125;]&#125;, &#123; a: 1, children: [&#123; a: 1, children: [&#123; a: 1, &#125;] &#125;]&#125;] 具体结果看下代码1234567891011121314151617181920212223var tree = [ &#123; count:1, a: 1, children: [&#123; count:2, a: 1, children: [&#123; a: 1, count:3, &#125;] &#125;]&#125;, &#123; count:1, a: 1, children: [&#123; count:2, a: 1, children: [&#123; a: 1, count:3, &#125;] &#125;]&#125;] 关于解决思路思路1树状结构需要层层设置，一般想到的就是递归，关于count设置一个全局变量，递归一层，加一次；1234567891011121314var count = 0;function fn1(arr) &#123; count++ for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].count = count; if (arr[i].children) &#123; fn1(arr[i].children) &#125; &#125;&#125;fn1(arr)console.log(arr) 但是递归的顺序并非我们想要的那种，count++执行的时间和想要的不一致 思路2模拟for循环实现结构，考虑再次更改为递归 123456789for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].count = 1; if (arr[i].children) &#123; for (var k = 0; k &lt; arr[i].children.length; k++) &#123; // console.log(arr) arr[i].children[k].count = 2; &#125; &#125;&#125; 这是实现的基本思路，里面赋值的count可以理解为在for循环这个作用域内，是不改变的，每次递归一次，增加1,通过自执行函数缓存count，每次递归加1 更改版本12345678910function fn(arr, c) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].c = c; if (arr[i].children) &#123; (function(c) &#123; fn(arr[i].children, c += 1) &#125;)(c) &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript Advanced</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Recursive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[循环结构]]></title>
    <url>%2F2018%2F08%2F01%2Floop-sructure%2F</url>
    <content type="text"><![CDATA[while循环语法while (条件){ 需要执行的代码} 案例12345while (i&lt;5) &#123; x=x + "The number is " + i + "&lt;br&gt;"; i++; &#125; do/while 循环do/while 循环是 while 循环的变体。该循环会执行一次代码块，在检查条件是否为真之前，然后如果条件为真的话，就会重复这个循环。 语法do { 需要执行的代码 }while (条件); 案例下面的例子使用 do/while 循环。该循环至少会执行一次，即使条件是 false，隐藏代码块会在条件被测试前执行：123456do &#123; x=x + "The number is " + i + "&lt;br&gt;"; i++; &#125;while (i&lt;5); break和continuebreak 语句跳出循环后，会继续执行该循环之后的代码（如果有的话）： 1234567for (i = 0; i &lt; 10; i++) &#123; if (i == 3) &#123; break; &#125; console.log(i)&#125;//0 1 2 continue 语句中断循环中的迭代，如果出现了指定的条件，然后继续循环中的下一个迭代。12345for (i = 0; i &lt;= 10; i++) &#123; if (i == 3) continue; console.log(i)&#125;// 0 1 2 4 5 6 7 8 9 10 for和for in在遍历数组上的异同for循环和for in循环都可以遍历获取到数组的内容； for循环获取数组下标的typeof类型为number； for in 循环获取数组下标的typeof类型为string；1234567891011var arr = ['a','b','c'];for(var i = 0;i &lt; arr.length;i++)&#123; console.log(typeof(i));//number console.log(arr[i]);//a,b,c&#125; var att = ['a','b','c'];for(var j in att)&#123; console.log(typeof(j));//string console.log(att[j]);//a,b,c&#125; 在遍历对象上的异同for循环不能用于循环对象，因为for循环无法获取obj.length，所以for循环只能用于数组操作；for in 循环可以获取对象的键值，可以操作数组，还可操作对象；12345678910111213141516var obj = new Object(&#123; name:"Simon", age:"16", city:"BJ"&#125;); console.log(obj.length);//undefinedfor(var i = 0;i &lt; obj.length;i++)&#123; console.log(i);//空的 console.log(obj[i]);//空的&#125; for(var j in obj)&#123; console.log(j);//name,age,city console.log(obj[j]);//simon,16,BJ&#125; 为什么不建议for in 循环数组 如果原生Array类被其他的js脚本库进行了原型扩展，那么用for in遍历扩展后的Array对象的逻辑将与遍历原生Array对象的逻辑发生差异。 12345678var arr = [1]Array.prototype.test = function() &#123;&#125;console.dir(arr)for (const key in arr) &#123; console.log(key) //i test&#125;]]></content>
      <categories>
        <category>HTML/CSS Base</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数值类型]]></title>
    <url>%2F2018%2F08%2F01%2FtoNumber%2F</url>
    <content type="text"><![CDATA[Number()：概述：Number 对象由 Number() 构造器创建，是经过封装的能让你处理数字值的对象。在非构造器上下文中 (如：没有 new 操作符)，Number 能被用来执行类型转换。 特点： 1、如果是Boolean值，true和false值将分别被转换为1和0。 2、如果是数字值，只是简单的传入和返回。 3、如果是null值，返回0。 4、如果是undefined，返回NaN。 5、如果是字符串： a. 如果字符串中只包含数字时，将其转换为十进制数值，忽略前导0 b. 如果字符串中包含有效浮点格式，如“1.1”，将其转换为对应的浮点数字，忽略前导0 c. 如果字符串中包含有效的十六进制格式，如“0xf”，将其转换为相同大小的十进制数值 d. 如果字符串为空，将其转换为0 e. 如果字符串中包含除上述格式之外的字符，则将其转换为NaN 如果是对象，则调用对象的valueOf（）方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString（）方法，然后再依照前面的规则转换返回的字符串值。 12345var num1 = Number("Hello world"); ·//NaNvar num2 = Number(""); //0var num3 = Number("0000011"); //11var num4 = Number(3.14fasdasf); //Uncaught SyntaxError: Invalid or unexpected tokenvar num5 = Number("3.14fasdasf"); //NaN parseInt():概述：parseInt() 函数将给定的字符串以指定基数（radix/base）解析成为整数。 语法：parseInt(string, radix); 参数：string：要被解析的值。如果参数不是一个字符串，则将其转换为字符串。字符串开头的空白符将会被忽略。 radix：一个2到36之间的整数值，用于指定转换中采用的基数。比如参数”10”表示使用我们通常使用的十进制数值系统。总是指定该参数可以消除阅读该代码时的困惑并且保证转换结果可预测。当忽略该参数时，不同的实现环境可能产生不同的结果。 特点： 1、如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN。转换空字符串也会返回NaN。 2、开头和结尾的空白符允许存在，会被忽略，直到找到第一个非空格字符。 3、如果第一个字符是数字字符，parseInt() 会继续解析第二个字符，直到解析完所有后续字符串或者遇到了一个非数字字符。遇到不能解析的字符和其后的字符都将被忽略。接着返回已经解析的整数部分。 4、parseInt()方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。 5、基是由parseInt()方法的第二个参数指定的，所以要解析十六进制的值，当然，对二进制、八进制，甚至十进制（默认模式），都可以这样调用parseInt()方法。 实例：12345parseInt(101010, 2); //42var num1 = parseInt("AF",16); //175var num2 = parseInt("AF"); //NaNvar num3 = parseInt("10",2); //2 (按照二进制解析)var num4 = parseInt("sdasdad"); //NaN parseFloat():概述：parseFloat()方法将参数中指定的字符串解析成为一个浮点数字并返回. 语法：parseFloat(string) 特点： 1、parseFloat是个全局函数,不属于任何对象。 2、如果在解析过程中遇到了正负号(+或-),数字(0-9),小数点,或者科学记数法中的指数(e或E)以外的字符,则它会忽略该字符以及之后的所有字符,返回当前已经解析到的浮点数. 3、字符串首位的空白符会被忽略.如果参数字符串的第一个字符不能被解析成为数字,则parseFloat返回NaN. 4、字符串中第一个小数点是有效的，而第二个小数点就是无效的了，它后面的字符串将被忽略。 5、parseFloat() 只解析十进制，因此它没有第二个参数指定基数的用法 6、如果字符串中包含的是一个可解析为正数的数（没有小数点，或者小数点后都是零），parseFloat() 会返回整数。 实例：123456var num1 = parseFloat("123AF"); //123var num2 = parseFloat("0xA"); //0var num3 = parseFloat("22.5"); //22.5var num4 = parseFloat("22.3.56"); //22.3var num5 = parseFloat("0908.5"); //908.5 区别Number()、parseInt() 和parseFloat() 的区别： Number()的强制类型转换与parseInt()和parseFloat()方法的处理方式相似，只是它转换的是整个值，而不是部分值。如“3.4.5”，用Number()进行强制类型转换将返回NAN, 如果确定字符串值能被完整地转换，Number()将判断是调用parseInt()还是parseFloat()。 parseFloat() 所解析的字符串中第一个小数点是有效的，而parseInt() 遇到小数点会停止解析，因为小数点并不是有效的数字字符。 parseFloat() 始终会忽略前导的零，十六进制格式的字符串始终会被转换成0，而parseInt() 第二个参数可以设置基数，按照这个基数的进制来转换。]]></content>
      <categories>
        <category>JavaScript Base</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>dataType</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逻辑运算符]]></title>
    <url>%2F2018%2F07%2F31%2ForAndFo%2F</url>
    <content type="text"><![CDATA[简介 运算符 描述 &amp;&amp; and ll or ! not 这个傻子都知道 关于true和false在javascript中，数据类型可以分为“真值”和“假值”。真值转换为bool时值为true；假值转换为bool时值为false 12345678console.log(Boolean("")) //falseconsole.log(Boolean(0)) //falseconsole.log(Boolean(1)) //trueconsole.log(Boolean(null)) //falseconsole.log(Boolean(undefined)) //falseconsole.log(Boolean([])) //trueconsole.log(Boolean(&#123;&#125;)) //trueconsole.log(Boolean(function() &#123;&#125;)) //true 关于短路 如果&amp;&amp;左侧表达式的值为真值，则返回右侧表达式的值；否则返回左侧表达式的值。 如果||左侧表达式的值为真值，则返回左侧表达式的值；否则返回右侧表达式的值。 1234console.log('' &amp;&amp; '1')console.log(2 &amp;&amp; 0)console.log('' || '1')console.log(2 || 0) 关于应用场景1假设对成长速度显示规定如下： 成长速度为5显示1个箭头； 成长速度为10显示2个箭头； 成长速度为12显示3个箭头； 成长速度为15显示4个箭头； 其他都显示都显示0各箭头。 使用分支结构：if、switch123456789101112131415161718192021222324252627282930var add_level = 0; if(add_step == 5)&#123; add_level = 1; &#125; else if(add_step == 10)&#123; add_level = 2; &#125; else if(add_step == 12)&#123; add_level = 3; &#125; else if(add_step == 15)&#123; add_level = 4; &#125; else &#123; add_level = 0; &#125;var add_level = 0; switch(add_step)&#123; case 5 : add_level = 1; break; case 10 : add_level = 2; break; case 12 : add_level = 3; break; case 15 : add_level = 4; break; default : add_level = 0; break;&#125; 使用运算符 123add_level = (add_step==5 &amp;&amp; 1) || (add_step==10 &amp;&amp; 2) || (add_step==12 &amp;&amp; 3) || (add_step==15 &amp;&amp; 4) || 0;// 或者var add_level=&#123;'5':1,'10':2,'12':3,'15':4&#125;[add_step] || 0; 场景2 成长速度为&gt;12显示4个箭头； 成长速度为&gt;10显示3个箭头； 成长速度为&gt;5显示2个箭头； 成长速度为&gt;0显示1个箭头； 成长速度为&lt;=0显示0个箭头。 那么用switch实现起来也很麻烦了，而且使用对象也没办法了，现在就到了展现真实实力的机会了1var add_level = (add_step&gt;12 &amp;&amp; 4) || (add_step&gt;10 &amp;&amp; 3) || (add_step&gt;5 &amp;&amp; 2) || (add_step&gt;0 &amp;&amp; 1) || 0; 场景3短路的应用12345678910a=a||"defaultValue"; if(!a)&#123; a="defaultValue"; &#125; if(a==null||a==""||a==undefined)&#123; a="defaultValue"; &#125;//防止回调函数未传报错callback&amp;&amp;callback()]]></content>
      <categories>
        <category>HTML/CSS Base</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Closure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型&数据类型检测]]></title>
    <url>%2F2018%2F07%2F27%2Fdata-type%2F</url>
    <content type="text"><![CDATA[1.数据类型分类1.1基本类型和复杂类型 5个基本类型：undefined，null，number，string，boolean 1个复杂类型：object1.2值类型和引用类型 值类型：字符串（string）、数值（number）、布尔值（null）、none、undefined 引用类型：对象（Object）、数组（Array）、函数（Function）值类型： 1、占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。） 2、保存与复制的是值本身 3、使用typeof检测数据的类型 4、基本类型数据是值类型引用类型： 1、占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。） 2、保存与复制的是指向对象的一个指针 3、使用instanceof检测数据类型 4、使用new()方法构造出的对象是引用型1.3 symbol已经有的6种数据类型: Undefined,Null,布尔值,字符串,数值,对象，现在ES6新加入一种数据类型——Symbol. 我们先来看看它的最大特点: 独一无二。 有这样一种场景，我们想区分两个属性，其实我们并不在意，这两个属性值究竟是什么，我们在意的是，这两个属性绝对要区分开来！ 2.数据类型判断2.1typeOf12345678910111213var a = 123;console.log(typeof a == "number"); //truevar a = '123';console.log(typeof a == "string"); //truevar a = true;console.log(typeof a == "boolean"); //truevar a = undefined;console.log(typeof a == "undefined"); //truevar a = null;console.log(a == null); //true/*复杂类型*/var a = function()&#123;&#125;;console.log(typeof a == "function"); //true 对于其他引用类型的对象，typeof不能检测区分，都会返回Object，如日期类型，正则表达式类型等，因此我们不能区分到底检测的是什么（用下文其他方法检测） typeof 方法函数封装123function typeOf(obj)&#123; return (obj === &apos;null&apos;) ? &apos;null&apos; : (typeof obj)&#125; 在这最后，补充一个特殊的NaN 1console.log(typeof NaN === &quot;number&quot;); //true 2.2 instanceofinstanceof 运算符可以用来检测一个对象是不是另一个对象的实例 语法：object1 instanceof object2 参数：object1-一个对象，constructor-另一个对象 返回值类型： 布尔值Boolean 也就是说，通过实例对象的原型链可以访问构造函数对象的原型对象上，这也就是instanceof的工作原理，这也说明了，instanceof并不关心对象的本身结构，只是关心对象与构造函数的关系。 1234567891011121314var a = new Date();console.log(a instanceof Date); //trueconsole.log(a instanceof Object); //truevar a = new RegExp('123');console.log(a instanceof RegExp); //trueconsole.log(a instanceof Object); //truevar a = function()&#123;&#125;;console.log(a instanceof Function); //trueconsole.log(a instanceof Object); //truevar a = [];console.log(a instanceof Array); //trueconsole.log(a instanceof Object); //truevar a = &#123;&#125;;console.log(a instanceof Object); //true 这里我列出了比较常用的实例，如果大家真的对instanceof比较关心的话，点击这里MDN文档 2.3 constructor属性constructor 属性返回对创建此对象的构造函数的引用。返回值类型： 对象Object这里说明一点的是，我们平时创建的，如： var a = 1, var b = ‘123’…，其实都是引用他们相对应的构造函数从而创建出来他们对于的类型，而不是表面我们看到的直接创建。各个类型检验方法如下： 12345678910111213141516171819202122232425262728/*5大基本类型*/var a = 123;console.log(a.constructor == Number); //truevar a = '123';console.log(a.constructor == String); //truevar a = true;console.log(a.constructor == Boolean); //truevar a = undefined;console.log(a &amp;&amp; a.constructor); //undefinedvar a = null;console.log(a &amp;&amp; a.constructor); //null /*复杂类型*/var a = function()&#123;&#125;;console.log(a.constructor == Function); //truevar a = new Date();console.log(a.constructor == Date); //truevar a = new Object();console.log(a.constructor == Object); //truevar a = &#123;&#125;;console.log(a.constructor == Object); //truevar a = new Array();console.log(a.constructor == Array); //truevar a = [];console.log(a.constructor == Array); //truevar a = new RegExp('abc');console.log(a.constructor == RegExp); //truevar a = /^abc$/;console.log(a.constructor == RegExp); //true 2.4 toString()方法这个方法检测对象类型最安全，最准确的方法。返回值类型：字符串String 1234567891011121314151617181920212223242526272829303132/*toString 检测类型函数*/function toStringType(obj)&#123; return Object.prototype.toString.call(obj).slice(8, -1);&#125;/*5大基本类型*/var a = 123;console.log(toStringType(a)); //"Number"var a = '123';console.log(toStringType(a)); //"String"var a = true;console.log(toStringType(a)); //"Boolean"var a = undefined;console.log(toStringType(a)); //"Undefined"var a = null;console.log(toStringType(a)); //"Null" /*复杂类型*/var a = function()&#123;&#125;;console.log(toStringType(a)); //"Function"var a = new Date();console.log(toStringType(a)); //"Date"var a = new Object();console.log(toStringType(a)); //"Object"var a = &#123;&#125;;console.log(toStringType(a)); //"Object"var a = new Array();console.log(toStringType(a)); //"Array"var a = [];console.log(toStringType(a)); //"Array"var a = new RegExp('abc');console.log(toStringType(a)); //"RegExp"var a = /^abc$/;console.log(toStringType(a)); //"RegExp" 如果你觉得返回的字符串大小写比较麻烦的话，你可以全部转化成小写代码如下： 123function toStringType(obj)&#123; return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();&#125;]]></content>
      <categories>
        <category>HTML/CSS Base</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>dataType</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高阶函数]]></title>
    <url>%2F2018%2F07%2F27%2Fhigher-function%2F</url>
    <content type="text"><![CDATA[1.概念 作为参数的函数 作为返回值的函数 都可以称为高阶函数 2.回调函数回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。 3.函数柯里化Currying把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术 12345678function currying(fn) &#123; var slice = Array.prototype.slice, __args = slice.call(arguments, 1); return function () &#123; var __inargs = slice.call(arguments); return fn.apply(null, __args.concat(__inargs)); &#125;;&#125; 柯里化特性决定了它这应用场景。提前把易变因素，传参固定下来，生成一个更明确的应用函数。最典型的代表应用，是bind函数用以固定this这个易变对象。 1234567Function.prototype.bind = function(context) &#123; var _this = this, _args = Array.prototype.slice.call(arguments, 1); return function() &#123; return _this.apply(context, _args.concat(Array.prototype.slice.call(arguments))) &#125;&#125; 4.案例1234567891011121314151617181920212223242526function currying(fn) &#123; var slice = Array.prototype.slice, __args = slice.call(arguments, 1); console.log(__args) return function () &#123; var __inargs = slice.call(arguments); console.log(__inargs) console.log(__args.concat(__inargs)) return fn.apply(null, __args.concat(__inargs)); &#125;;&#125;function square(i) &#123; console.log(i) return i * i;&#125;function dubble(i) &#123; return i *= 2;&#125;function map(handeler, list) &#123; return list.map(handeler);&#125;var mapSQ = currying(map, square);console.log(mapSQ([1, 2, 3, 4, 5]));]]></content>
      <categories>
        <category>JavaScript Advanced</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CallBack</tag>
        <tag>Currying</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流&函数防抖]]></title>
    <url>%2F2018%2F07%2F24%2Fdebounce%2F</url>
    <content type="text"><![CDATA[1.函数防抖说函数防抖，debounce。其概念其实是从机械开关和继电器的“去弹跳”（debounce）衍生 出来的，基本思路就是把多个信号合并为一个信号。 单反也有相似的概念，在拍照的时候手如果拿不稳晃的时候拍照一般手机是拍不出好照片的，因此智能手机是在你按一下时连续拍许多张， 能过合成手段，生成一张。翻译成JS就是，事件内的N个动作会变忽略，只有事件后由程序触发的动作只是有效。 12345678910111213141516171819202122// 函数防抖function debounce(func, delay) &#123; var timeout; return function (e) &#123; console.log("清除", timeout, e.target.value) clearTimeout(timeout); // console.log(arguments) var context = this, args = arguments console.log("新的", timeout, e.target.value) timeout = setTimeout(function () &#123; console.log("----") func.apply(context, args); &#125;, delay) &#125;;&#125;;var validate = debounce(function (e) &#123; console.log("change", e.target.value, new Date - 0)&#125;, 1000);// 绑定监听document.querySelector("input").addEventListener('input', validate); 实现思路如下，将目标方法（动作）包装在setTimeout里面，然后这个方法是一个事件的回调函数，如果这个回调一直执行，那么这些动作就一直不执行。为什么不执行呢，我们搞了一个clearTimeout，这样setTimeout里的方法就不会执行！ 为什么要clearTimeout呢，我们就需要将事件内的连续动作删掉嘛！待到用户不触发这事件了。那么setTimeout就自然会执行这个方法。 那么这个方法用在什么地方呢，就是用于input输入框架的格式验证，假如只是验证都是字母也罢了，太简单了，不怎么耗性能，如果是验证是否身份证，这性能消耗大，你可以隔170ms才验证一次。这时就需要这个东西。或者你这个是自动完全，需要将已有的输入数据往后端拉一个列表，频繁的交互，后端肯定耗不起，这时也需要这个，如隔350ms。 2.函数节流节流的概念可以想象一下水坝，你建了水坝在河道中，不能让水流动不了，你只能让水流慢些。换言之，你不能让用户的方法都不执行。如果这样干，就是debounce了。为了让用户的方法在某个时间段内只执行一次，我们需要保存上次执行的时间点与定时器。函数节流会用在比input, keyup更频繁触发的事件中，如resize, touchmove, mousemove, scroll。throttle 会强制函数以固定的速率执行。因此这个方法比较适合应用于动画相关的场景。 12345678910111213141516171819202122232425262728293031// 函数节流function throttle(fn, threshhold) &#123; var timeout var start = new Date; var threshhold = threshhold || 160 return function () &#123; var context = this, args = arguments, curr = new Date() - 0 clearTimeout(timeout)//总是干掉事件回调 if (curr - start &gt;= threshhold) &#123; console.log("now", curr, curr - start)//注意这里相减的结果，都差不多是160左右 fn.apply(context, args) //只执行一部分方法，这些方法是在某个时间段内执行一次 start = curr &#125; else &#123; //让方法在脱离事件后也能执行一次 timeout = setTimeout(function () &#123; fn.apply(context, args) &#125;, threshhold); &#125; &#125;&#125;var mousemove = throttle(function (e) &#123; console.log(e.pageX, e.pageY)&#125;,1000);// 绑定监听document.querySelector("#panel").addEventListener('mousemove', mousemove);function test (a,b,c)&#123; console.log(arguments)&#125;test(4,2,3) 区别：函数防抖可以理解为在规定时间内如果屏蔽掉所有的行为操作，最后执行一次；函数节流可以理解为你触发操作后，隔一段时间执行一次，减少执行的频率，防止页面假死； 无损耗防抖无论节流还是防抖都会对用户的操作有所损耗，节流，时间内不执行，防抖，只进行一次，目前有这样的一个需求，在不损耗用户操作的情况下，如何处理？ 保证每次用户的操作都会执行，或马上执行，或延迟执行 1234567891011121314151617181920212223242526272829303132333435363738// 函数防抖function throttle(fn, threshhold) &#123; var timeId var start = new Date; var threshhold = threshhold || 160 var queue = 0; //缓存触发次数 return function() &#123; var context = this, args = arguments, curr = new Date() - 0 timeId &amp;&amp; clearInterval(timeId) //清理之前注册的计时器 console.count(); if (curr - start &gt;= threshhold) &#123; fn.apply(context, args) start = curr &#125; else &#123; queue++ //在没有调用函数的情况下缓存次数 console.log(queue) timeId = setInterval(() =&gt; &#123; //启用计时器 fn.apply(context, args) queue-- console.log('计时器' + queue) if (queue &lt;= 0) &#123; //递减为0的时候清理计时器 timeId &amp;&amp; clearInterval(timeId) &#125; &#125;, threshhold); &#125; &#125;&#125;var count = 0;var mousemove = throttle(function(e) &#123; count++ console.log(count) // console.count()&#125;, 500);// 绑定监听document.addEventListener('scroll', mousemove);]]></content>
      <categories>
        <category>HTML/CSS Advanced</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Closure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析闭包]]></title>
    <url>%2F2018%2F07%2F24%2Fclosure%2F</url>
    <content type="text"><![CDATA[闭包的概念：函数的闭包形成闭包；封闭的区域（可以调用其他作用域变量的函数）；闭包的组成：内层函数本身；内层函数所处的作用域； 闭包作用：1. 形成隔离的封闭空间；123456//函数里面的num不会影响外面num的值；var num = 100;(function()&#123; var num = 1000;&#125;)()console.log(num) 2. 延长变量的声明周期；3. 匿名自制行环境–沙箱 插件常用的内部变量外放的操作，将window和document作为实参放入沙箱之内，防止内部变量对于外部的影响 减少作用域链； 1234(function(window, doc)&#123; if (typeof exports !== 'undefined') exports.touchScroll = iScroll; else window.touchScroll = iScroll;&#125;)(window, document); 4. 缓存变量123456789var arr = []; for(var i=0;i&lt;10;i++)&#123; arr[i] = (function (n)&#123; return function()&#123; console.log(n) &#125; &#125;)(i) &#125;; arr[3](); //结果是3； 5.实现类和继承123456789101112131415161718192021222324252627function Person()&#123; var name = "default"; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125; &#125;; var p = new Person(); p.setName("Tom"); alert(p.getName()); var Jack = function()&#123;&#125;; //继承自Person Jack.prototype = new Person(); //添加私有方法 Jack.prototype.Say = function()&#123; alert("Hello,my name is Jack"); &#125;; var j = new Jack(); j.setName("Jack"); j.Say(); alert(j.getName()); 6.大量封装函数12345678910111213141516171819var person = function()&#123; // var num = '0'; return &#123; sum : function (num) &#123; var sum = 0; for(var i=0;i&lt;=num;i++)&#123; sum+=i; &#125; return sum; &#125;, mul : function (num) &#123; var mul = 1; for(var i = 1;i&lt;=num;i++)&#123; mul*=i; &#125; return mul; &#125; &#125;&#125;(); 7.案例1234567var arr=[]; for(var i=0;i&lt;3;i++)&#123; arr[i]=(function(j)&#123;return function()&#123;console.log(j)&#125;&#125;)(i) &#125; arr[0](); arr[1](); arr[2](); 1234567//生成随机数 function getNum()&#123; var num=parseInt(Math.random()*10+1); return function()&#123; return num; &#125; &#125;;]]></content>
      <categories>
        <category>JavaScript Base</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Closure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量提升]]></title>
    <url>%2F2018%2F07%2F20%2Fvariable-lifting%2F</url>
    <content type="text"><![CDATA[变量提升是JS在非严格模式下，JS解析的时候出现的一种情况 JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。 JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。 1.变量提升 12345console.log(first) //undefinedvar first = 124;/*正常var变量声明之后会被提升到最顶端，但是是声明提前，赋值不提前，所以为undefined*/ 2.函数提升 12345678second(); //123function second() &#123; console.log(123)&#125;/*征程通过function声明之后函数会被提升到最顶端，可以直接在声明之前调用*/ 3.函数提升 1234567// third(); //14-变量提升.html:28 Uncaught TypeError: third is not a functionvar third = function () &#123;console.log('第三种')&#125;/*页面报错，因为var声明变量，声明提前，赋值不提前，所以trird为undefined，所以报错；*/ 4.函数和变量提升对比 1234567891011121314151617181920console.log(fifth) //ƒ fifth()&#123;// console.log(123)// &#125;var fifth = 123;function fifth() &#123;console.log(123)&#125;/*函数和变量同时声明，函数覆盖变量，在进行变量提升；*/console.log(six) //ƒ six()&#123;// console.log(123)// &#125;function six() &#123;console.log(123)&#125;var six = 123;/*函数和变量同时声明，函数覆盖变量，在进行变量提升；*/]]></content>
      <categories>
        <category>JavaScript Base</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
