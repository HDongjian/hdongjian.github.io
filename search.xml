<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript的面向对象]]></title>
    <url>%2F2019%2F01%2F18%2Foop_base%2F</url>
    <content type="text"><![CDATA[面向对象（oop）Class类可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已 基本使用123456789class Person &#123; constructor(age, name) &#123; this.age = age; this.name = name; &#125;&#125;console.log(new Person(12, '张三')) 构造器–constructor 构造器：每一个类中都有一个构造器，如果我们程序员没有手动指定构造器，那么可以认为类内部有一个隐形的，看不见的空构造器类似于constructor(){} 作用：就是每当new这个类的时候，必然会优先执行构造器中的代码 静态方法&amp;静态属性类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用 构造函数 123456function PersonC()&#123;&#125;PersonC.a = 1;PersonC.b = function()&#123; &#125; Class类 12345678910class Person &#123; constructor(age, name) &#123; this.age = age; this.name = name; &#125; static a = 12 static b()&#123; &#125;&#125; 静态方法或者静态属性无法通过实例之后的对象来调用，因为这是挂载到类或者构造函数上面的，只能通过Person.a或者PersonC.a来获取或者调用 实例方法&amp;实例属性通过new出来的实例，访问到的属性或者方法，叫做实例方法或者实例对象 1234567891011121314151617//构造函数function PersonC()&#123;&#125;PersonC.prototype.c = function()&#123;&#125;//class类class Person &#123; constructor(age, name) &#123; this.age = age; this.name = name; &#125; c()&#123; &#125;&#125; 继承Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 基本使用1234567891011class Person &#123; constructor(age, name) &#123; this.age = age; this.name = name; &#125;&#125;class Chiness extends Person&#123;&#125;console.log(new Chiness(12,'李四')) 关于super方法在以上代码中如果我们在Chiness中值只调用配置constructor函数，就会报错 1234567891011121314151617class Chiness extends Person&#123; constructor()&#123; &#125;&#125;// missing super() call in constructorclass Chiness extends Person&#123; constructor()&#123; super() &#125;&#125;console.log(new Chiness(12,'李四'))//Chiness &#123;age: undefined, name: undefined&#125; 但是如果我们调用了，不会报错，但是实例对象中的age和name属性的值为undefined 就会提醒我们调用super方法 为什么必须调用super? 答：如果一个子类，通过extends关键字继承了父类，那么，子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。 根据以上说法，如果想在构造器中使用this也必须是在super调用之后 super方法是什么? 答:super是一个函数，而且它是父类的构造器，子类中的super就是其中父类中，constructor构造器的一个引用 为什么调用之后实例对象中的age和name属性的值为undefined? 答:super是一个函数，而且它是父类的构造器,所以如果只调用，不传递参数，所以实例对象中的age和name属性的值为undefined 正确用法 1234567class Chiness extends Person&#123; constructor(age,name)&#123; super(age,name) &#125;&#125;console.log(new Chiness(12,'李四')) 关于子类独有属性123456789class Chiness extends Person&#123; constructor(age,name,id)&#123; super(age,name) this.id = id; &#125;&#125;console.log(new Chiness(12,'李四',12))]]></content>
      <categories>
        <category>JavaScript进阶</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bug第一弹]]></title>
    <url>%2F2019%2F01%2F17%2Fbugs_1%2F</url>
    <content type="text"><![CDATA[SSO拦截登陆后页面报错功能场景校验登录通过cookie中特定cookie，如果没有，所有请求会报403，通过axios的钩子函数检测异常跳转到指定登录页面 12345678910111213141516171819// 请求后的钩子函数HTTP.interceptors.response.use(function (config) &#123; // console.log(location.href.split('?')[0] + '?' + encodeURIComponent(location.href.split('?')[1])) return config;&#125;, function (error) &#123; if (error.response.status === 401) &#123; Cookie.remove('userData') localStorage.clear(); sessionStorage.clear(); console.log(location.href) if (error.response.data.indexOf('jumpto') === -1) &#123; location.href = error.response.data + '&amp;jumpto=' + location.href &#125; else &#123; location.href = error.response.data &#125; &#125; return Promise.reject(error)&#125;) 问题原因在指定jumpto跳转，后天未将参数中&amp;符号后面的参数带来，导致页面参数不足报错 解决方法解析url路径？参数，通过incode方法解析，去除&amp;符号，页面在通过decode方法解析 1234567891011121314151617181920212223// 请求后的钩子函数HTTP.interceptors.response.use(function (config) &#123; // console.log(location.href.split('?')[0] + '?' + encodeURIComponent(location.href.split('?')[1])) return config;&#125;, function (error) &#123; if (error.response.status === 401) &#123; Cookie.remove('userData') localStorage.clear(); sessionStorage.clear(); console.log(location.href) if (error.response.data.indexOf('jumpto') === -1) &#123; if (location.href.indexOf('/approval') &gt;= 0) &#123; location.href = error.response.data + '&amp;jumpto=' + location.href.split('?')[0] + '?' + encodeURIComponent(location.href.split('?')[1]); &#125; else &#123; location.href = error.response.data + '&amp;jumpto=' + location.href &#125; &#125; else &#123; location.href = error.response.data &#125; &#125; return Promise.reject(error)&#125;) web和app共有页面无法区分设备功能场景移动端和app端有相同功能页面，需要判断当前设备，并打开相应页面 代码12345678910111213141516171819common.judegWebOrApp = () =&gt; &#123; var userAgentInfo = navigator.userAgent.toLowerCase(); var Agents = ["zhushou", "android", "iphone", "symbianos", "windows phone", "ipad", "ipod"]; var flag = true; for (var i = 0; i &lt; Agents.length; i++) &#123; if (userAgentInfo.indexOf(Agents[i]) &gt; 0) &#123; flag = false; break; &#125; &#125; var params = location.href.split('?')[1]; var nowPage = location.href.indexOf('app'); console.log(flag,nowPage) if (flag &amp;&amp; nowPage &gt;= 0) &#123;//web端 location.href = "/web/approval?"+params; &#125; else if (!flag &amp;&amp; nowPage &lt; 0) &#123;//app端 location.href = "/app/approval?" + params; &#125;&#125; 通过app的webview加载H5页面在iphone6s和iphoneSE中吸底偶尔不出现bug原因在浏览器中测试没有问题，经过测试，在webview中，获取的高度iphone6s和iphoneSE获取的页面高度比真实高度高64px，导致吸底消失 解决措施判断是否是iphone手机，并判断宽度，符合iphone6s以及iphonese尺寸的，采取设置top值而不是botom值 12345678910111213var docEl = document.clientWidth ? document : document.documentElement;var height = docEl.clientHeight;var width = docEl.clientWidth;var reduce = 98 / 30 * width / 25;setTimeout(() =&gt; &#123; this.xiBot = this.$refs.botTab; if(!this.xiBot) return; if (width == 320) &#123; this.xiBot.style.top = 548 - reduce + 'px'; &#125; else if (width == 375 &amp;&amp; height &lt; 690) &#123; this.xiBot.style.top = 647 - reduce + 'px'; &#125;&#125;, 500); webview中ios系统页面不出现具体场景在app中内嵌网页，安卓端没问题，在ios上会出现偶数次打开页面空白现象，但是页面中去除本身app头部的方法已经执行，也就是说页面正常加载，但是页面呈现空白； bug原因在vue的router.beforeEach钩子函数中调用了函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* 路由拦截（钩子）*/router.beforeEach((to, from, next) =&gt; &#123; //重置到页面顶端 document.body.scrollTop = 0; document.documentElement.scrollTop = 0; //去除桔子堆头部 api.appDelHeader(); //判断路径是否是403和选择地址页面 if (to.path === '/403' || to.path === '/FoodAddress') &#123; next(); return; &#125; //判断是否校验checkCode if (api.mall.on) &#123; login.checkLogin(() =&gt; &#123;//失败时候的回调 next('/403'); return; &#125;, () =&gt; &#123;//成功的回调 if (!api.checkUA() &amp;&amp; api.mall.isCheckUA) &#123; next('/403'); &#125; else if (localStorage.getItem('arriveAddress') &amp;&amp; localStorage.getItem('menuId')) &#123; // 已选择了默认区域 next(); &#125; else &#123; console.log('重新获取地址') getArea();//就是这个方法，实参未传 &#125; &#125;); &#125;&#125;)//获得区域列表const getArea = function (next, to) &#123; api.get(&#123; data: &#123; flag: 1 &#125;, url: "/area/queryList", object: Vue, errorIfo: "获取区域失败", then: (data) =&gt; &#123; // data = null; if (data &amp;&amp; data.menuId &amp;&amp; data.arriveAddress) &#123; localStorage.setItem('menuId', data.menuId); localStorage.setItem('arriveAddress', data.arriveAddress) localStorage.setItem('floorId', data.floorId)//localStorage保存楼层信息 if (to.path == '/confirmPrepareMeal') &#123; next(); return; &#125; else &#123; next('/HomeIndex'); &#125; &#125; else &#123; next('/FoodAddress'); &#125; &#125; &#125;)&#125; 按照上面问题应该导致报错，但是web端测试没问题，安卓没问题，ios偶尔出现，很奇怪 时间控件国际化无法重新渲染问题场景时间控件可以使用中英文，但是一经渲染，后期无法局部更新，导致点击切换语言按钮时候无法更改控件内容 解决措施检测中英文切换操作，采用if重新渲染时间控件 123456789watch: &#123; '$i18n.locale': function (value) &#123; this.dataPicker = false; setTimeout(() =&gt; &#123; this.dataPicker = true; this.showData = this.$t('message.myAppoint.today'); &#125;, 10); &#125;,&#125;, ios时间处理失效问题场景提交表单需要校验时间，如果时间小于当前时间，则默认取当前时间，此时需要时间戳对比 12345678910111213141516171819202122232425//选择时间完成chooseTime(time) &#123; this.cancelTime(time); this.modalData.timeModal = false; this.initialCache("ok");&#125;,//控制时间大小cancelTime(time) &#123; if (this.setTimeToSeconds(time) - this.setTimeToSeconds() &gt; 1000) &#123; this.cacheData.visitingTime = time; &#125; else &#123; this.cacheData.visitingTime = new Date(); &#125;&#125;,//设置时间setTimeToSeconds(time) &#123; // var seconds = this.$moment(time).format('YYYY-MM-DD HH:mm'); // return parseInt(new Date(seconds).getTime()); if (time) &#123; return new Date(time).getTime(); &#125; else &#123; return new Date().getTime(); &#125;&#125;, bug原因new Date(‘时间字符串’)，ios对于时间字符串格式支持较少，不支持2018-02-02此格式的数据，支持/不支持-，导致时间戳校验失败 12345678910111213141516171819202122232425262728//选择时间完成chooseTime(time) &#123; console.log(time) time = this.$moment(time).format('YYYY/MM/DD HH:mm:ss') console.log(time) this.cancelTime(time); this.modalData.timeModal = false; this.initialCache("ok");&#125;,//控制时间大小cancelTime(time) &#123; if (this.setTimeToSeconds(time) - this.setTimeToSeconds() &gt; 1000) &#123; this.cacheData.visitingTime = time; &#125; else &#123; this.cacheData.visitingTime = new Date(); &#125;&#125;,//设置时间setTimeToSeconds(time) &#123; // var seconds = this.$moment(time).format('YYYY-MM-DD HH:mm'); // return parseInt(new Date(seconds).getTime()); if (time) &#123; return new Date(time).getTime(); &#125; else &#123; return new Date().getTime(); &#125;&#125;, 超小字符实现方式问题场景设计图要求一个按钮字体大小为10px，但是谷歌浏览器最小字符为12px 实现场景12345678910.repeat-post &#123; border: 1px solid #FC9153; border-radius: 4px; background-color: #fff; height: 25px; font-size: 12px; width: 65px; color: #FC9153; transform: scale(.8,.9);//采用缩放属性实现 transform-origin: left; 安卓键盘遮挡输入框问题场景安卓在获取焦点弹起键盘会自动将也页面上滑，将input框置于可视位置，但是如果body有滚动条的情况下，则input框位置靠下就会被遮挡 解决措施在input获取焦点的情况下现将页面上移到顶部 12345//滚动条到初始状态scollTopZero() &#123; document.body.scrollTop = 0; document.documentElement.scrollTop = 0;&#125;, 取餐时间内无法取餐问题场景正常订餐时间是00：00到下午16：30，但是在0点到8点区间无法点餐；问题原因：后台返回的当前时间currentDate是一个日期字符串，与北京时区不同，有8个小时的时间差，前台处理的时候只是取了日期，导致当天8点之前的日期是昨天的时期 解决措施123456Gray.prototype.toSeconds = function (time, currentTime) &#123; time = moment(time).format('HH:mm:ss'); currentTime = moment(currentTime).format('YYYY/MM/DD'); var time2 = new Date(currentTime + ' ' + time).getTime(); return time2;&#125; 显示时间和取餐时间不一致问题场景后台提示的下单时间是00：00到下午4：30 在EP部分有一个的电脑时间显示有误，其他人没有问题 1Thu Mar 22 2018 21:21:47 GMT+0800 (中国标准时间) 解决措施导致此问题原因为该人电脑时区设置的是美国，导致浏览器解析new Date的时候和正常时区不一致将电脑时区调整好即可 IOS系统中div盒子内设置滚动条，偶尔会滑动失效问题场景在餐品页面内，有餐品列表，偶尔会出现滑动失效的问题，在苹果手机 解决措施 采用body整体布局 使用iscroll插件解决 将此盒子设置为fixed定位 iphonx的兼容问题问题场景一个侧边栏，点击从右侧划出的时候iphonex底部有空白，只有这个是这样的 解决措施布局问题，原来次侧边栏和遮挡层在一个div中，点击的时候显示此div，并给遮挡层和侧边栏加入动画效果；现在取消外层div即可]]></content>
      <categories>
        <category>Bugs</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【持续更新】关于Hexo优化]]></title>
    <url>%2F2019%2F01%2F16%2Fabout_hexo%2F</url>
    <content type="text"><![CDATA[基本命令 hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 增加站内搜索功能安装插件在自己博客根目录下（我的目录：D:\workspace\hexo），执行如下命令 1cnpm install hexo-generator-searchdb --save 修改站点配置文件修改根目录下的_config.yml（我的目录：D:\workspace\hexo_config.yml），在最底部添加如下配置 12345search: path: search.xml field: post format: html limit: 10000 修改主题配置文件修改主体下的themes\next_config.yml配置文件（我的目录：D:\workspace\hexo\themes\next_config.yml），搜索local_search，修改enable为true 1234567local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 预览效果开启本地server123hexo cleanhexo ghexo s 增加博客置顶功能（自定义排序）修改node_modules下代码找到node_modules/hexo-generator-index/lib/generator.js文件 将内部代码替换成 1234567891011121314151617181920212223242526272829303132'use strict';var pagination = require('hexo-pagination');module.exports = function(locals) &#123; var config = this.config; var posts = locals.posts.sort(config.index_generator.order_by); posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; var path = config.index_generator.path || ''; return pagination(path, posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 使用在文章添加 top 标签可以设置置顶顺序顺序根据top的值来决定 123456---title: 文章名date: 文章发布时间tags: 文章标签top: 100(文章置顶)--- Next主题设定代码高亮格式需要改动的有hexo的配置文件_config.yml，以及next主题的配置文件themes/next/_config.yml文件 更改hexo的配置文件查找highlight关键字，更改一下属性为true12345highlight: enable: true line_number: true auto_detect: true tab_replace: 更改next主题配置文件搜索highlight_theme关键字，这个属性有四个值： normal ：默认值 night ：黑色 night eighties ：个人感觉跟第二个差不太多 night blue ： 底部是蓝色，跟sublime text3默认配色差不多 night bright ： 有点闪瞎眼的感觉 具体使用哪个看个人喜好吧，本人night 增加显示文章更新时间在next主题的配置文件themes/next/_config.yml文件中搜索post_meta关键字，将属性updated_at该为true 12345post_meta: item_text: true created_at: true updated_at: true categories: true]]></content>
      <categories>
        <category>周边</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识React]]></title>
    <url>%2F2019%2F01%2F08%2Fn_reactBase%2F</url>
    <content type="text"><![CDATA[React简介 React起源于Facebook的内部项目，因为该公司对市场上所有的JavaScript MVC框架，都不满意，就决定自己写一套，用来架设Instagram(照片交友)的网站，做出来以后，发现这套东西很好用，就在2013年5月开源了； Angular1 2009年谷歌 由于React的设计思想独特，属于革命性的创新，性能出众，代码逻辑却非常简单，所以，越来越多的人开始关注和使用，认为他可能将来是Web开发的主流工具 清楚两个概念 library（库）：小而巧的库，有点事船小好调头，可以很方便的从一个库切换到另外的库，但是代码几乎不会改变； framework（框架）：大而全的是框架，框架提供了一整套的解决方案，所以，如果在项目中间，想切换到另外的框架，往往是比较困难的； 前端的三大主流框架 Angular.js：出来的较早的前端框架，学习曲线比较陡，NG1学起来比较麻烦，NG2-NG5开始，进行了一系列的改革，也提供了组件化开发的概念，从NG2开始，也支持使用了TS进行编辑； Vue.js：最火（关注的人比较多）的一门前端框架，它是中国人开发的，对我们来说，文档比较友好一些； React.js:最流行（用的人比较多）的一门框架，因为它的设计很优秀； React与Vue的对比组件化方面 什么是模块化：从代码的角度来进行分析的，把一些可复用的代码，抽离为单个的模块，便于项目的维护和开发； 什么是组件化：是从UI界面的角度来进行分析的，把一些可复用的UI元素，抽离为单独的组件，便于醒目的维护和开发； 组件化的好处：随着项目规模的增大，手里的组件越来越多，很方便的能把现有的组件，拼接为一个完整的页面； Vue是如何实现组件化的：通过.vue文件； React如何实现组件化：一般都是通过JS来实现的 开发团队方面 React是由FaceBook前端官方团队进行维护和更新的，因此，React的维护开发团队，技术实力比较雄厚= Vue：第一版，主要是由作者尤雨溪专门进行维护的，当Vue更新到2.x版本之后，也有了以尤雨溪为主的开源小团队，进行维护和开发 社区方面 在社区方面，React由于诞生的比较早，所以社区比较强大，一些常见的问题，坑，最优的解决方案，文档，博客，在社区中都是很方便的就能找到； Vue是近两年才火起来的，所以他的社区性对于React来说要小一些，可能有的一些坑，没人踩过； 移动APP开发体验方面 Vue，结合Weex这门技术，提供了迁移到移动端APP开发的体验 React 结合ReactNative也提供了无缝迁移到移动App的开发体验 为什么要学习React 设计很优秀，一切基于JS并且实现了组件化的思想 开发团队实力强悍，不必担心断更的情况； 社区强大，很多问题都能找到直接的解决方案 提供了无缝转到ReactNative的开发体验，让我们的技术能力得到了拓展，增强了我们的核心竞争力 很多企业中，前端项目的技术选型采用的是React.js React中的几个核心概念虚拟DOM（Vitual Document Object Model） Dom的本质 浏览器中的概念，用JS对象来表示页面上的元素，并提供了操作DOM对象的API； React中的虚拟DOM 是框架中的概念，是程序员用JS对象来模拟页面中的DOM和DOM嵌套； 虚拟DOM的目的 为了实现页面中，DOM元素的高效更新 Dom和虚拟DOM的区别 DOM：浏览器中提供的概念，用JS对象，表示页面中的元素，并提供了操作元素的API 虚拟DOM：是框架中的概念，是开发框架的程序员，手动用JS对象来模拟DOM元素和嵌套关系； 本质：用JS对象来模拟DOM元素和嵌套关系 目的：是为了实现页面元素的高效更新； Diff算法 tree diff 新旧两颗DOM树，逐层对比的过程，就是Tree Diff,当整颗DOM逐层对比完毕，则所有需要被按时更新的元素，必然能够找到 component diff 在进行Tree Diff的时候，每一层，组件级别的对比，叫做Component Diff; 如果对比前后，组件的类型相同，则暂时认为此组件不需要被更新； 如果对比之后，组件类型不同，则暂时认为此组件不需要被更新 element diff 在进行组件对比的会后，如果两个组件类型相同，则需要进行元素的对比，这叫做element diff； 创建基本的webpack4.x项目 运行npm init -y 快速初始化项目 在根目录创建src源代码以及dist产品目录 在src下创建index.html和main.js(入口文件) 执行命令安装依赖 12cnpm i webpack wepack-cli webpack-dev-server html-webpack-plugin -D 新建 webpack.config.js 123456789101112131415const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: "development", entry: "./src/index.js", output: &#123; path: __dirname, filename: './dist/bundle.js' &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: "./src/index.html" &#125;) ],&#125; 执行命令 webpack-dev-server JSX语法JSX语法就是符合xml规范的JS语法，语法格式相对来说，要比HTML严谨的多 使用jsx语法 安装babel插件 123cnpm i babel-core babel-loader babel-plugin-transform-runtime babel-preset-env babel-preset-stage-0 -Dcnpm i babel-loader@7.1.5 -D 安装能够识别转换jsx的包 1cnpm i babel-preset-react -D 新建.babelrc 1234&#123; "presets":["env","stage-0","react"], "plugins":["transform-runtime"]&#125; 配置 webpack.config.js 123456789module:&#123; rules:[ &#123; test:/\.js|jsx$/, use:'babel-loader', exclude:/node_modules/ &#125; ]&#125; jsx注意事项 jsx语法本质:并不是直接把jsx渲染到页面上，而是内部先转换成了createElement的形式，在渲染的 在jsx中混合写入js表达式：在jsx语法中，要把js代码写到{}中 在jsx中添加类名：使用className来替代class 在jsx中为label添加for属性：使用htmlFor 在jsx语法中，标签必须成对出现，如果是单标签，则必须自闭 当编译引擎，在编译jsx代码的时候，如果遇到了&lt;就会把它当做html代码去编译，如果遇到了{}就会作为普通js代码去编译 React中创建组件使用构造函数来创建组件声明组件123456function Hello(props)&#123; //注意，不论在vue还是react中，组件props永远都是只读的，不能被重新赋值 return &lt;div&gt;HELLO--&#123;props.name&#125;--&#123;props.age&#125;&lt;/div&gt;&#125; 使用组件12&lt;Hello &#123;...li&#125;&gt;&lt;/Hello&gt; 注意事项 组件名称必须大写 组件传参可以使用...展开运算符进行传参 可以将组件封装到单独的js文件中，但是必须引入React对象 关于路径配置 如果引入文件需要省略后缀名可以在webpack中做如下配置 1234resolve:&#123; extensions:['.js','.jsx','.json'],//表示，这几个文件的后缀名可以省略不写，会按照书写顺序来解析&#125;, 关于引用路径中的@符号 123alias:&#123; '@':path.join(__dirname,'./src')//这样，@就表示项目根目录中src的这一层路径&#125; 使用Class类来创建组件基本使用123456789101112class Movie extends React.Component&#123; render()&#123; return &lt;div&gt;movie组件&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;div&gt; &lt;Movie&gt;&lt;/Movie&gt;&lt;/div&gt;,document.getElementById('app')); 传参组件内可以直接通过this.props接受父组件传递的参数 12345678910class Movie extends React.Component&#123; render()&#123; return &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;div&gt; &lt;Movie &#123;...li&#125;&gt;&lt;/Movie&gt;&lt;/div&gt;,document.getElementById('app')); 状态这个this.state就相当于vue中的data(){return{}}状态和props相比，是可以更改的 123456789101112131415161718class Movie extends React.Component&#123; constructor()&#123; super(); this.state=&#123; msg:"大家好" &#125; &#125; render()&#123; return &lt;div&gt;&#123;this.props.name&#125;---&#123;this.state.msg&#125;&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;div&gt; &lt;Movie &#123;...li&#125;&gt;&lt;/Movie&gt;&lt;/div&gt;,document.getElementById('app')); 两种组件方式的对比 注意：使用class关键字创建的组件，有自己的私有数据this.state和生命周期注意：使用function创建的组件，只有props，没有自己的私有属性和声明周期 用构造函数创造出来的组件叫做无状态组件 用class关键字创造出来的组件，叫做有状态组件 什么情况下使用有状态组件？什么情况下使用无状态组件？ 如果一个组件需要有自己的私有数据，推荐使用class 如果一个组件不需要有私有数据，则推荐使用构造函数 React官方说，无状态组件，由于没有自己的state和声明周期，所以运行效率会比有状态组件稍微高一些 有状态组件和无状态组件之间的本质区别就是：有无state属性，有无声明周期函数 组件中的props和state/data之前的区别 props中的数据都是外界传递进来的 state、data中的数据，都是组件私有的； props中的数据都是只读，不能重新赋值 state/data中的数据，都是可读可写的]]></content>
      <categories>
        <category>JavaScript进阶</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Ne</tag>
        <tag>MVVM</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玲珑金管家-后台管理系统]]></title>
    <url>%2F2018%2F12%2F12%2Fl_back%2F</url>
    <content type="text"><![CDATA[项目构建实现方式通过vue-cli实现基本项目的搭建 自定义配置方面打包命令区分环境 package.json中设置打包命令 1"uat": "node build/uat.js", 新建打包配置文件 在webpack.prod.conf配置不同的环境变量 在config里面新建相对应的环境变量 1234'use strict'module.exports = &#123; NODE_ENV: '"uat"'&#125; 在项目中使用process.env.NODE_ENV来获取不同的环境变量； 配置代理地址 在config/index.js里面配置 配置方式 1234567891011proxyTable: &#123; '/hyacp': &#123; // '*': &#123; target: 'https://yunyingtest.huanyueguoji.com', // target: 'http://192.168.1.168:8091/', changeOrigin: true, pathRewrite: &#123; '^/hyacp': '/hyacp' &#125; &#125;&#125;, 基本作用 用于请求后台数据==》调用接口 解决可能会存在的跨域问题； vue相关配置vue的use方法1Vue.use(iView) 基本原理就是通过模块化外放一个变量，内置有一个install方法，vue调用use方法的时候，可以理解为调用了install，并且将vue实例作为实参传递进去 12345export default &#123; install: function(Vue) &#123; &#125;&#125; axios的相关配置 通过axios的create方法统一配置axios的配置项 通过promise封装axios来区别后天返回的成功或失败(在状态值为200的成功) 在axios的请求钩子函数中统一处理请求数据 路由此项目除了登录页，其他页面都是有相同的菜单栏，所以使用路由嵌套的方式在app.vue中为1级路由；在home.vue中为2级路由； 关于vuex 数据共享； 数据发生改变之后，凡是用到这个数据的地方都会发生改变； 在咱们项目中vuex的数据：menu的层级数据； vuex使用步骤 声明实例化 12345678Vue.use(Vuex);export default new Vuex.Store(&#123; state, getters, actions, mutations,&#125;) 在vue实例化的时候挂载到vue 1234567const vm = new Vue(&#123; el: '#app', router, store, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 关于四个属性 status：存放变量（状态） mutations：存储更改变量的方法 action：涉及到异步； 获取变量 1234567891011import &#123; mapState, mapMutations, mapGetters, mapActions &#125; from 'vuex' computed: mapState(&#123; power: state =&gt; state.power, shrinked: state =&gt; state.shrinked, tabData: state =&gt; state.tabData &#125;), //通过this.power获取到相应变量 computed: &#123; ...mapState(['pSwiperModal', 'pSwiperPicList']) &#125;, 更改变量（状态）通过mapMutations等方法将函数挂载到method下面就可以了直接调用了 1234567...mapMutations([ 'setPowerM', 'pathPushM', 'setTabList', 'setTabChoosed', 'setPermList' ]), 项目页面搭建home.vuehome文件主要有layout.vue组成，包括左侧菜单，右侧头部，右侧主要内容，这些主要有插槽来实现的 vue插槽 确定插槽位置 1&lt;slot name='logo'&gt;&lt;/slot&gt; 设置插槽的主要内容template、组件、div都可以作为插槽，主要设置slot属性即可12&lt;e-menu slot='menu' :openNames='openNames'&gt;&lt;/e-menu&gt; 左侧菜单 这个是有ivew的menu功能实现的 最多实现三级菜单 数据由后台接口或者menu.js的all属性（关闭权限之后）提供 数据渲染步骤 在router/index.js中判断权限开关是否打开 打开的情况下请求接口获取权限list数据，使用方法分出层级结构，将数据赋值给menu.js中的list属性 在关闭的情况下，直接获取menu.js的all属性的值，赋值给menu.js的list属性 在home.vue中获取menu.js的值并通过vuex保存； 在menu.vue中获取vuex中的数据，渲染页面 menu.vue需求 在右侧打开一系列菜单 保存菜单中的操作； 实现 新建一个vue文件(menu.vue)用来展示选项卡； 新建一个list数据(vuex)用来存放选项卡数据； 新建一个标志位用来判断当前那个选项卡展示(vuex:choosed)； 点击菜单需要为list增加数据并且改变标志位的值； 获取点击菜单的key判断在一开打的选项卡中有无该key值 有，直接将choosed的值改为该key值； 没有，将list中push该菜单，并且改变choosed的值； 不管又或者没有，都需要获取该菜单的fakId来记录哪一个菜单被打开(openNames)； 点击关闭选项卡功能的时候，为list删除数据并且改变标志位的值； 获取点击的选项卡的index值； 通过方法从list数据中删除该选项卡； 判断如果删的此index还在选中此index值 如果index值不在，选中index-1的值； 需要在本地以及vuex中缓存数据； 删除也好或者增加也好都是通过调用vuex的方法来实现的 并且更改vuex数据的同时更改session中的数据； 在session中存数据的目的是页面刷新之后能够记录打开的选项卡 在home.vue中会先去session中获取数据然后存储到vuex中 在展示当前选中组件的时候，需要找一个文件注册所有的组件:config/components.js 在展示选项卡标题部分需要对于超出页面宽度的滑动处理； 点击选项卡改变显示 点击选项卡获取此key值fakid 然后改变choosed的值和fakId来记录哪一个菜单被打开 阻止架构 权限管理 负责的是所有的菜单，按钮，接口的访问权限 角色管理 权限匹配到每个角色身上 员工管理 匹配相应的角色和部门 部门管理 有一个城市的属性 作用是为每一个员工增加一个城市的属性 风控管理整个权限控制 菜单是由后台接口返回的权限list数据+breadcrumbs.js的本地配置来实现的 首先从后台获取数据之后做层级处理 渲染左侧菜单 打开以及关闭选项卡的时候，是获取到点击的目录key值，循环breadcrumbs.js数据，找到相同key值push到tabData.list中 breadcrumb数据中有一个action用来区分相同组件不同菜单的； 打开风控详情部分 这个不同于菜单，这个页面是不存在与权限树中的 当打开多个详情页面时，使用由一些id组成的对象转化的字符串来作为选中的key值； 列表的按钮以及详情中的tab权限控制 在menu.js中为风控页面配置相应的key值 循环遍历后台返回的权限树，新建一个由所有权限key组成的list； 当我们判断该按钮或者tab菜单是否展示的时候，首先找到这个菜单或者tab相对应的key，然后去list去找，有，展示，没有则不展示 详情-审核决策页面 除了上述说的由后台返回的list还有在不同情况下展示按钮的控制 主要是由detailStatus来控制的 实地和背调操作 先用接口获取checkbox列表渲染弹窗 checkbox里面有一个其它选项，选择之后可以自定义添加类型 类型有文件和图片两种可选（发起补件的情况下只有图片类型） 考察结果 先用接口获取需要提交的文件列表并且区分image和input类型 通过循环处理resultGetData来储存提交好的图片和文字 上传图片进行压缩处理小于1M 上传成功之后将图片以及文字信息处理成list并转化成字符串以imgdata传给后台]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式进阶]]></title>
    <url>%2F2018%2F12%2F03%2Fregular_advanced%2F</url>
    <content type="text"><![CDATA[关于分组分组在正则中用的还是比较广的，我所理解的分组 就是一对括号（） ，每一对括号 就代表了一个分组，分组可以分为：捕获性分组和非捕获性分组 捕获性分组关于捕获性分组字面意思就是可以捕获的分组类型，比如 123console.log(/(\d)(-)/.test('1-'))//trueconsole.log(RegExp.$1) //1console.log(RegExp.$2) //- 捕获性分组会在 比如$1, match exec这样的函数中以第二项，第三项的形式得到相应分组的结果 案例12345// var reg = /test(\d+)/;var reg = /test(\d+)/g;var str = 'new test001 test002';console.log(str.match(reg)); //["test001", "001", index: 4, input: "new test001 test002"]console.dir(RegExp) 非捕获性分组–(?:)非捕获性分组也就是 有些地方需要用到一对括号，但是又不想让他成为一个捕获性分组也就是不想让这个分组被类似 macth exec 这样的函数所获取到通常在括号内部的前面加上?: 也就是 (?:pattern)这样就变成了一个非捕获性分组,比如 123console.log(/(\d)(?:-)/.test('1-')) //trueconsole.log(RegExp.$1)//1console.log(RegExp.$2)//空值 非捕获性分组–断言javascript只支持零宽先行断言,所以关于JS中的正则表达式的断言，说的一般就是零宽，而零宽先行断言又可以分为正向零宽先行断言，和负向零宽先行断言。 零宽度断言零宽断言正如它的名字一样，是一种零宽度的匹配，它匹配到的内容不会保存到匹配结果中去，最终匹配结果只是一个位置而已。 作用是给指定位置添加一个限定条件，用来规定此位置之前或者之后的字符必须满足限定条件才能使正则中的字表达式匹配成功。 正向零宽断言代表符号符号：?= 案例解析 简单了解 1234var str = "abZW863";var reg = /ab(?=[A-Z])/;console.log(str.match(reg));// "ab" 在以上代码中，正则表达式的语义是:匹配后面跟随任意一个大写字母的字符串”ab”。最终匹配结果是”ab”，因为零宽断言”(?=[A-Z])”并不匹配任何字符，只是用来规定当前位置的后面必须是一个大写字母。 案例进阶 如果在上述案例的基础上我想要匹配上ZW应该怎么写； 1234var str = "abZW863";var reg = /ab(?=[A-Z]+)[A-Z]+/;console.log(str.match(reg));//"abZW" 案例3 1234var str="&lt;div&gt;antzone";var reg=/^(?=&lt;)&lt;[^&gt;]+&gt;\w+/;console.log(str.match(reg));//"&lt;div&gt;antzone" 解析过程： 首先^符号表示位置，从0开始匹配，匹配成功，让后将控制权交给(?=&lt;) 由于^是零宽度，所以(?=&lt;)还是从0开始匹配，要求第一个位置的必须是&lt;,所以也成功 由于(?=&lt;)也是零宽度，&lt;还是从0开始匹配，第一个&lt;成功； 后面就没啥好说的了； 负向零宽断言代表符号符号：?! 案例解析 案例1 1234var str = "abZW863";var reg = /ab(?![A-Z])/;console.log(str.match(reg));// null 正则表达式的语义是:匹配后面不跟随任意一个大写字母的字符串”ab”。正则表达式没能匹配任何字符，因为在字符串中，ab的后面跟随有大写字母。 案例2 123var str="abZW863ab88";var reg=/ab(?![A-Z])/g;console.log(str.match(reg)); 首先由正则表达式的字符”a”获取控制权，从位置0处开始匹配，匹配字符”a”成功 然后控制权转交给”b”，从位置1处开始匹配，配字符”b”成功，然后控制权转交给”(?[A-Z])”，它从位置2处开始匹配，它要求所在位置的右边不能够是任意一个大写字母，而位置的右边是大写字母”Z”,匹配失败 然后控制权又重新交给字符”a”，并从位置1处开始尝试，匹配失败，然后控制权再次交给字符”a”，从位置2处开始尝试匹配 依然失败，如此往复尝试，直到从位置7处开始尝试匹配成功，然后将控制权转交给”b”,然后从位置8处开始尝试匹配，匹配成功，然后再将控制权转交给”(?[A-Z])”，它从位置9处开始尝试匹配，它规定它所在的位置右边不能够是大写字母，匹配成功，但是它并不会真正匹配ab后面的字符，所以最终匹配结果是”ab”。 案例3 1var reg = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;6,12&#125;$/; 关于贪婪模式和非贪婪模式介绍贪婪与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配。非贪婪模式只被部分NFA引擎所支持。 属于贪婪模式的量词，也叫做匹配优先量词，包括： “{m,n}”、“{m,}”、“?”、“*”和“+”。 在一些使用NFA引擎的语言中，在匹配优先量词后加上“?”，即变成属于非贪婪模式的量词，也叫做忽略优先量词，包括： “{m,n}?”、“{m,}?”、“??”、“*?”和“+?”。 案例12console.log('abcadc'.match(/a.+c/g)) //["abcadc"]console.log('abcadc'.match(/a.+?c/g)) // ["abc", "adc"]]]></content>
      <categories>
        <category>JavaScript进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式基础]]></title>
    <url>%2F2018%2F11%2F30%2Fregular-base%2F</url>
    <content type="text"><![CDATA[关于正则表达式简介正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。 正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 123var str = "abc123def";var patt1 = /[0-9]+/;document.write(str.match(patt1)); 为什么要用正则表达式典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。 通过使用正则表达式，可以： 测试字符串内的模式。 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 替换文本。 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 基于模式匹配从字符串中提取子字符串。 可以查找文档内或输入域内特定的文本。 元字符常用元字符汇总表 符号 描述 . 表示出了\n以外任意的一个单个的字符串； \d 匹配一个数字字符。等价于 [0-9] \D 匹配一个非数字字符。等价于 [^0-9]。 \s 匹配任何空白字符，包括空格、制表符、换页符等等 \S 匹配任何非空白字符 \w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’ \W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’ 特殊的元字符 –限定符 符号 描述 * 匹配前面的子表达式零次或者多次。 + 匹配前面的子表达式一次或者多次。 ？ 匹配前面的子表达式零次或者一次。 {n} 匹配确定的n次。 {n,} 至少匹配n次。 {n,m} 最少匹配n次，且最多能匹配m次。 其他特殊符号 符号 描述 [] 查找方括号之间的任何字符,可以理解为一个范围，或者表示一个单独字符 [a-z] 表示小写字母 [A-Z] 表示大写字母 [0-9] 表示数字 [a-zA-Z0-9] 表示所有数字和字母 [\u4e00-\u9fa5] 校验中文 \ 将下一个字符标记为一个特殊字符、或一个原义字符：转义 ^ 表示以什么开始或者取反 $ 表示以什么结束 竖线 指明两项之间的一个选择（优先级最低） () 小括号：提升优先级别的；作用：分组 从最左边算起 案例1234567console.log(/./.test('除了换行以外的任意字符'))console.log(/.*/.test(''))console.log(/.+/.test(''))console.log(/b|(ara)/.test('abra'))console.log(/^b|(ara)$/.test('abra'))console.log(/[a-z]&#123;2,3&#125;/.test('ar'))console.log(/\w&#123;2&#125;/.test('abc23')) RegExp 对象简介正则表达式是描述字符模式的对象。 正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。 使用关于参数 pattern（模式） 描述了表达式的模式 modifiers(修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 构造函数1var patt=new RegExp(pattern,modifiers); 使用字面量12var patt=/pattern/modifiers; 对象方法test()方法test() 方法用于检测一个字符串是否匹配某个模式.如果字符串中有匹配的值返回 true ，否则返回 false。 12345//关于严格模式var reg = new RegExp(/^\d&#123;5&#125;$/);console.log(reg.test('12345')) //trueconsole.log(reg.test('123456')) //false exec()方法exec() 方法用于检索字符串中的正则表达式的匹配。 如果字符串中有匹配的值返回该匹配值，否则返回 null。 12console.log(/\d/.exec('adf12')) toString()返回正则表达式的字符串值。 12var res = /\d/.toString();console.log(res) // /\d/ 支持正则的String方法replace()replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 123var str = "Mr Blue has a blue house and a blue car";console.log(str.replace(/blue/, "red"))console.log(str.replace(/blue/g, "red")) search()用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。 1console.log('1212adfvafed'.search(/\d/)) //0 match()可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 1234var str = "The rain in SPAIN stays mainly in the plain";var n = str.match(/ain/gi);console.log(n) split()用于把一个字符串分割成字符串数组。 123var str = "The rain in SPAIN stays mainly in the plain";var n = str.match(/ain/gi);]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wepy基本使用]]></title>
    <url>%2F2018%2F11%2F29%2Fn_wcwepy%2F</url>
    <content type="text"><![CDATA[1. wepy-介绍&nbsp; &nbsp; WePY (发音: /‘wepi/)是一款腾讯团队于2016年11月发布的小程序组件化框架，通过预编译的手段让开发者可以选择自己喜欢的开发风格去开发小程序。 官网 1.1. 特性 类Vue开发风格 支持自定义组件开发 支持引入NPM包 支持Promise 支持ES2015+特性，如Async Functions 支持多种编译器，Less/Sass/Stylus/PostCSS、Babel/Typescript、Pug 支持多种插件处理，文件压缩，图片压缩，内容替换等 支持 Sourcemap，ESLint等 小程序细节优化，如请求列队，事件优化等 1.2. 优秀案例&nbsp; &nbsp; 腾讯疫苗查询小程序、 腾讯翻译君小程序、 腾讯地图小程序、 玩转故宫小程序、 手机充值+、 手机余额查询、 手机流量充值优惠、 友福图书馆（开源）、 素洁商城（开源）、 NewsLite（开源）、 西安找拼车（开源）、 深大的树洞（开源）、 求知微阅读（开源）、 给你的 iPhone X 换个发型、 天天跟我买、 坚橙、 群脱单、 米淘联盟、 帮助圈、 众安保险福利、 阅邻二手书、 趣店招聘、 满熊阅读（开源： 微信小程序、支付宝小程序）、 育儿柚道、 平行进口报价内参、 GitHub掘金版、 班级群管、 鲜花说小店、 逛人备忘、 英语助手君、 花花百科、 独角兽公司、 爱羽客羽毛球、 斑马小店、 小小羽球、 培恩医学、 农资优选、 公务员朝夕刷题、 七弦琴小助手、 七弦琴大数据、 爽到家小程序、 应用全球排行（开源）、 we川大（开源）、 聊会儿、 … 1.3. 前置知识 node&amp;npm vue es6 微信小程序 2. 快速项目搭建2.1. 全局安装WePY的安装或更新都通过npm进行。 1npm install wepy-cli -g 2.2. 创建空项目 1.7.0版本之前的请查询官网完成创建 1wepy init empty my-project 2.3. 编译并监控项目等待创建成果后，进入到项目目录 1cd my-project 安装依赖 1npm install 编译并监控项目 1wepy build --watch 此时，可以看到目录下多了一个dist文件夹，该文件夹便是经过wepy编译后的小程序源代码，也就是我们可以用小程序开发者工具直接监控的项目代码。 2.4. WePY项目的目录结构123456789101112131415161718192021├─dist 小程序文件夹│ └─pages 小程序页面文件夹│ index.js 首页的js文件│ index.json 首页的配置文件│ index.wxml 首页的标签文件 │ index.wxss 首页的样式文件│—node_modules node包 │─src wepy的项目源代码│ │ app.wpy wepy的小程序的全局组件│ │ │ └─pages wepy的页面组件文件夹│ index.wpy wepy的小程序的首页组件│ .editorconfig 代码格式的配置文件│ .gitignore 告诉git哪些文件需要忽略│ .prettierrc 代码格式化的配置文件│ .wepycache wepy项目的缓存文件 防止build时 重复编译npm目录│ .wepyignore wepy编译工具的忽略清单│ package-lock.json npm的项目描述文件│ package.json npm的项目描述文件│ project.config.json 小程序项目内的配置文件│ wepy.config.js wepy的编译配置文件 &nbsp;&nbsp; dist为小程序运行目录，因此千万不要手动去编辑或者修改!! 3. 开发环境配置3.1. 小程序开发者工具配置由于统一使用wepy进行开发，因此关于开发者工具的配置也需要直接在wepy项目中直接进行配置。通过project.config.json即可进行配置，默认不需要修改。 12345678910111213&#123; &quot;description&quot;: &quot;project description&quot;, &quot;setting&quot;: &#123; &quot;urlCheck&quot;: true, &quot;es6&quot;: false, &quot;postcss&quot;: false, &quot;minified&quot;: false &#125;, &quot;compileType&quot;: &quot;miniprogram&quot;, &quot;appid&quot;: &quot;touristappid&quot;, &quot;projectname&quot;: &quot;Project name&quot;, &quot;miniprogramRoot&quot;: &quot;./dist&quot;&#125; es6: 对应关闭ES6转ES5选项，关闭。 重要：未关闭会运行报错。 postcss: 对应关闭上传代码时样式自动补全选项，关闭。 重要：某些情况下漏掉此项也会运行报错。 minified: 对应关闭代码压缩上传选项，关闭。重要：开启后，会导致真机computed, props.sync 等等属性失效。 urlCheck: 对应不检查安全域名选项，开启。 如果已配置好安全域名则建议关闭。 3.2. 代码高亮配置wepy推荐开发者使用较为成熟的编辑器来代替 微信开发者工具 ， 微信开发者工具 只用来做显示界面使用。 这里推荐 使用vs code ，如需要其他编辑器，其他编辑器配置 在 Code 里先安装 Vue 的语法高亮插件 Vetur。 打开任意 .wpy 文件。 点击右下角的选择语言模式，默认为纯文本。 在弹出的窗口中选择 .wpy 的配置文件关联...。 在选择要与 .wpy 关联的语言模式 中选择 Vue。 3.3. 启用promise因为不想陷入异步的回调地狱中，所以在一些复杂的业务当中，我们推荐使用 promise 或者 async-function 来代替传统的回调。因此需要在项目中单独进行配置。 3.3.1. 进入项目根目录，安装polyfill1npm install wepy-async-function --save 3.3.2. 在app.wpy中导入polyfill1import 'wepy-async-function'; 3.3.3. 在app.wpy中开启promise123456export default class extends wepy.app &#123; constructor () &#123; super(); this.use('promisify'); &#125;&#125; 3.4. wepy.config.js&nbsp;&nbsp;wepy项目编译的配置文件 属性名 含义 target wepy编译后的生成目录 wpyExt wepy组件的后缀名，默认为wepy，可以指定为vue eslint 是否开启eslint的验证 cliLogs 开启控制台打印 compilers 编译sass，js等文件的配置 plugins 插件 appConfig 全局变量，可以在组件中通过 wepy.$appConfig访问 4. 小程序页面结构和wepy组件结构对比4.1. wepy组件的编译图解wepy组件编译的流程如图所示，我们在学习wepy组件前，最好提前了解一下。 4.2. 小程序页面结构小程序页面结构分为4个部分 wxml 标签文件 wxss 样式文件 JavaScript 逻辑文件 json 配置文件 4.3. wepy组件结构wepy组件默认后缀名为 .wpy,该文件里面包含有了 样式、标签和逻辑部分 如 12345678910111213141516171819202122/* 样式 */&lt;style lang="less"&gt;&lt;/style&gt;/* 标签 */&lt;template&gt; &lt;view class="container"&gt; Hello world &lt;/view&gt;&lt;/template&gt; /* 逻辑 */&lt;script&gt;import wepy from 'wepy';export default class Index extends wepy.page &#123; config = &#123; navigationBarTitleText: 'test' &#125;; onLoad() &#123; console.log('onLoad'); &#125;&#125;&lt;/script&gt; 5. app.wpy文件wpy文件分为3个部分，分别是 样式 style，标签 template，还有 脚本 javascript。下面挨个来讲解 5.1. style在app.wpy 文件的style中，控制的是全局的样式。它有如下特点 设置的样式可以在所有的页面文件中使用 通过lang关键字可以设置 css,less,scss 等预处理器 123&lt;style lang="less"&gt;&lt;/style&gt; 可以使用 //等作为注释（小程序中的wxss中直接写//是不支持的）。 123view &#123; // color: yellow;&#125; 可以通过style标签中的src关键字导入另外的第三方样式文件 1&lt;style src="./styles/base.css"&gt; &lt;/style&gt; 5.2. template template为标签部分，由于app.wpy最终是要编译为小程序中的app.js文件的，因此该template无特别用法 5.3. JavaScript app.wpy中的javascript为脚本部分，继承自wepy.app 它经过编译后，最终会生成两个文件，分别是 app.js 和 app.json。 主要有以下特点 代码风格类似vue，es6的语法。 继承自 wepy.app 1234567891011121314export default class extends wepy.app &#123; config = &#123; pages: ['pages/index'], window: &#123; backgroundTextStyle: 'light', navigationBarBackgroundColor: '#fff', navigationBarTitleText: 'WeChat', navigationBarTextStyle: 'black' &#125; &#125;; onLaunch() &#123; console.log('on launch'); &#125;&#125; 在 default class内，config字段对应的是小程序中 app.json的内容 全局配置 123456789config = &#123; pages: ['pages/index'], window: &#123; backgroundTextStyle: 'light', navigationBarBackgroundColor: '#fff', navigationBarTitleText: 'WeChat', navigationBarTextStyle: 'black' &#125;&#125;; 和config同层级，可以定义小程序的App注册事件 和全局变量 globalData等 123456789config = &#123;... &#125;;onLaunch() &#123; console.log('on launch');&#125;onShow()&#123; console.log("on show");&#125;globalData=&#123;&#125;; 6. index.wpy6.1. 介绍页面组件wpy的文件结构类似 app.wpy结构，也是由三个部分组成 标签 template ，样式 style和脚本javascript 继承自 wepy.page。其中 脚本 javascript经过编译后，也是会生成两个文件。分别是小程序中的页面javascript和页面json 1234567891011121314&lt;style lang="less"&gt;&lt;/style&gt;&lt;template&gt;&lt;/template&gt;&lt;script&gt;import wepy from 'wepy';export default class Index extends wepy.page &#123;&#125;&lt;/script&gt; 属性 说明 config 页面配置对象，对应于原生的page.json文件，类似于app.wpy中的config data 页面渲染数据对象，存放可用于页面模板绑定的渲染数据 methods wxml事件处理函数对象，存放响应wxml中所捕获到的事件的函数，如bindtap、bindchange 生命周期函数 小程序页面生命周期函数，如onLoad、onReady等，以及其它自定义的方法与属性 computed 计算属性 watch 监控数据 自定义数据 可以自定义内部使用的数据 自定义函数 可以自定义内部需要使用的函数 components 页面组件列表对象，声明页面所引入的组件列表 events WePY组件事件处理函数对象，存放响应组件之间通过$broadcast、$emit、$invoke所传递的事件的函数 mixins 声明页面引入的Minxin 6.2. 数据绑定在wepy中，数据绑定的类似vue的风格，也是通过 来绑定，this.mydata=&#39;hello wepy&#39;来修改。 注意，如在异步里修改数据，需要手动调用 this.$apply(); 来触发数据更新 代码： 1234567891011121314&lt;template&gt; &lt;view&gt;&#123;&#123;mydata&#125;&#125;&lt;/view&gt;&lt;/template&gt;&lt;script&gt;import wepy from 'wepy';export default class Index extends wepy.page &#123; data=&#123; mydata:"hello wepy" &#125;; onLoad() &#123; this.mytitle = '你好wepy'; &#125;&#125;&lt;/script&gt; 6.3. 事件页面中，绑定事件的方式变为更为简单了。并且，可以实现在事件中传递参数。通过@来绑定，可以省略小程序中的关键字 bind。如 bindtap 变为 @tap。 而且，可以通过添加事件后缀来指定对应的事件类型，如： .default: 绑定小程序冒泡型事件，如bindtap，.default后缀可省略不写； .stop: 绑定小程序捕获型事件，如catchtap； .user: 绑定用户自定义组件事件，通过$emit触发。注意，如果用了自定义事件，则events中对应的监听函数不会再执行。 123456789101112131415&lt;template&gt; &lt;view class="container" @tap="myTap(123)"&gt; Hello world &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import wepy from 'wepy';export default class Index extends wepy.page &#123; methods = &#123; myTap(data) &#123; console.log(data); &#125; &#125;;&#125;&lt;/script&gt; 7. component.wpy组件文件，结构上大体和页面.wpy类似，区别在于组件是继承自 wepy.component,并且它拥有自己的属性设置，插槽等。关于一些小程序自身的组件基本属性，可以通过 小程序组件 来进行查阅。这里主要讲解如何使用自定义组件和组件传参。 7.1. 使用自定义组件7.1.1. 声明组件 新建组件 Myheader.wpy 编辑组件 1234567891011121314&lt;template&gt; &lt;view @tap="myTap" &gt;组件中的文字&lt;/view&gt;&lt;/template&gt;&lt;script&gt;import wepy from "wepy";export default class MyHeader extends wepy.component &#123; methods=&#123; myTap()&#123; console.log("组件被点击了"); this.$emit("parentEvent",&#123;&#125;); &#125; &#125;&#125;&lt;/script&gt; 7.1.2. 使用组件 在页面文件中引入组件 1import MyHeader from '../components/MyHeader'; 在 class中声明引入的组件 123components = &#123; MyHeader &#125;; template中使用组件 12345&lt;template&gt; &lt;view class=&quot;container&quot; &gt; &lt;MyHeader&gt;&lt;/MyHeader&gt; &lt;/view&gt;&lt;/template&gt; 7.2. props组件传值页面和组件之间的传值可以通过 props实现。分为三种： 静态传值 父组件传递到子组件的值，不会再被父组件改变。只能传递字符串 动态传值 使用 .sync修饰符来将父组件的数据绑定到子组件上，单向绑定。父 -&gt; 子 动态传值 使用 .sync 和 子组件中的twoWay: true 实现双向绑定 父 &lt;-&gt; 子 7.2.1. 静态传值组件 MyHeader 12345678&lt;template&gt; &lt;view &gt;&#123;&#123;parentTitle&#125;&#125;&lt;/view&gt;&lt;/template&gt;&lt;script&gt; // .... props=&#123; parentTitle:String // 静态传值&lt;/script&gt; 父组件 12345&lt;template&gt; &lt;view class="container" &gt; &lt;MyHeader parentTitle="父组件中的title" &gt;&lt;/MyHeader&gt; &lt;/view&gt;&lt;/template&gt; 7.2.2. 单向绑定组件 MyHeader 123456789101112&lt;template&gt; &lt;view &gt;&#123;&#123;parentTitle&#125;&#125;&lt;/view&gt;&lt;/template&gt;&lt;script&gt; // .... props=&#123; parentTitle:&#123; type:String, default:null &#125; &#125;&lt;/script&gt; 父组件 使用 .sync 修饰符 1234567891011121314151617181920&lt;template&gt; &lt;view class="container" &gt; &lt;MyHeader :parentTitle.sync="父组件中的title" &gt;&lt;/MyHeader&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import MyHeader from '../components/MyHeader';import wepy from 'wepy';export default class Index extends wepy.page &#123; data=&#123; title:"父中的组件" &#125; onLoad() &#123; setTimeout(() =&gt; &#123; this.title="被修改了"; this.$apply(); &#125;, 2000); &#125;&#125;&lt;/script&gt; 7.2.3. 双向绑定父组件和子组件上同时加上配置便可实现 组件中的数据双向绑定。 组件 MyHeader 加上配置 twoWay: true 1234567891011121314151617181920&lt;template&gt; &lt;view @tap="myTap" &gt;子组件 &#123;&#123;parentTitle&#125;&#125;&lt;/view&gt;&lt;/template&gt;&lt;script&gt;import wepy from "wepy";export default class MyHeader extends wepy.component &#123; props=&#123; parentTitle:&#123; type:String, default:null, twoWay:true &#125; &#125; methods=&#123; myTap()&#123; this.parentTitle="组件中修改了"; &#125; &#125;&#125;&lt;/script&gt; 父组件 中继续使用 .sync 修饰符 1234567891011121314151617181920212223242526&lt;template&gt; &lt;view class="container" &gt; &lt;view&gt; 父组件上的数据： &#123;&#123;title&#125;&#125; &lt;/view&gt; &lt;MyHeader:parentTitle.sync="title" &gt;&lt;/MyHeader&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import MyHeader from '../components/MyHeader';import wepy from 'wepy';export default class Index extends wepy.page &#123; components = &#123; MyHeader &#125;; data=&#123; title:"父中的组件" &#125; onLoad() &#123; setTimeout(() =&gt; &#123; this.title="父组件中修改了"; this.$apply(); &#125;, 2000); &#125;&#125;&lt;/script&gt; 7.3. 组件通信组件之间的通信，都通过事件触发的形式来实现。主要有以下三种 父组件向子组件通信 $broadcast 子组件向父组件通信 $emit 页面或组件对另一个组件中的方法的直接调用 $invoke 7.3.1. $broadcast$broadcast 负责由父组件向子组件传播事件。 流程如下 使用方式： 父组件中 触发 1this.$broadcast("子组件中的事件名",..参数) 子组件中，在events字段内监听 12345events=&#123; 事件名(...args)&#123; // 执行逻辑 &#125;&#125; 7.3.2. $emit$emit 负责由子组件向父组件触发事件 。 流程如下 方向和 $broadcast 相反 使用方式 子组件中触发 1this.$emit(&quot;parentFn&quot;,1,3,4,5); 父组件 events 字段中监听 12345events = &#123; parentFn(...args)&#123; console.log("父组件事件触发"); &#125;&#125;; 7.3.3. $invoke$invoke是一个页面或组件对另一个组件中的方法的直接调用 1234// 页面中的调用this.$invoke('ComA', 'someMethod', 'someArgs');// 组件中的调用this.$invoke('./../ComB/ComG', 'someMethod', 'someArgs'); 如同文件夹下，在页面index中，A 组件想要调用B组件内的方法 index.wpy 12&lt;A&gt;&lt;/A&gt;&lt;B&gt;&lt;/B&gt; A.wpy 1234567891011121314151617&lt;template lang="wxml"&gt; &lt;view @tap="myTap"&gt;组件1&lt;/view&gt;&lt;/template&gt;&lt;script&gt;import wepy from 'wepy';import B from './B';export default class A extends wepy.component &#123; methods = &#123; myTap() &#123; this.$invoke('B', 'show', 'A的呼叫'); &#125; &#125;; components=&#123; B &#125;&#125;&lt;/script&gt; B.wpy 12345678910111213&lt;template lang="wxml"&gt; &lt;view &gt;组件0&lt;/view&gt;&lt;/template&gt;&lt;script&gt;import wepy from 'wepy';export default class B extends wepy.component &#123; methods = &#123; show(msg) &#123; console.log("触发 " +msg); &#125; &#125;;&#125;&lt;/script&gt; 7.3.3.1. 组件自定义事件可以通过使用.user修饰符为自定义组件绑定事件，如：`@customEvent.user=”myFn”` 其中，@表示事件修饰符，customEvent 表示事件名称，.user表示事件后缀。 目前总共有三种事件后缀： .default: 绑定小程序冒泡型事件，如bindtap，.default后缀可省略不写； .stop: 绑定小程序捕获型事件，如catchtap； .user: 绑定用户自定义组件事件，通过$emit触发。注意，如果用了自定义事件，则events中对应的监听函数不会再执行。 7.4. 插槽slot插槽slot可以允许我们在页面中往组件的内部动态的插入标签结构 slot有两种使用方式，单个slot和多个slot 当使用多个slot时，只需要指定唯一的name属性即可。 在Panel组件中有以下模板： 1234&lt;view class="panel"&gt; &lt;slot name="title"&gt;默认标题&lt;/slot&gt; &lt;slot name="content"&gt;默认内容&lt;/slot&gt;&lt;/view&gt; 在父组件中使用Panel子组件时，可以这样使用： 123456&lt;panel&gt; &lt;view slot="title"&gt;新的标题&lt;/view&gt; &lt;view slot="content"&gt; &lt;text&gt;新的内容&lt;/text&gt; &lt;/view&gt;&lt;/panel&gt; 8. 拦截器可以使用WePY提供的全局拦截器对原生API的请求进行拦截。 8.1. 在app.wpy中定义全局拦截器123456789101112131415161718192021222324252627282930313233343536373839import wepy from 'wepy';export default class extends wepy.app &#123; constructor () &#123; // this is not allowed before super() super(); // 拦截request请求 this.intercept('request', &#123; // 发出请求时的回调函数 config (p) &#123; // 对所有request请求中的OBJECT参数对象统一附加时间戳属性 p.timestamp = +new Date(); console.log('config request: ', p); // 必须返回OBJECT参数对象，否则无法发送请求到服务端 return p; &#125;, // 请求成功后的回调函数 success (p) &#123; // 可以在这里对收到的响应数据对象进行加工处理 console.log('request success: ', p); // 必须返回响应数据对象，否则后续无法对响应数据进行处理 return p; &#125;, //请求失败后的回调函数 fail (p) &#123; console.log('request fail: ', p); // 必须返回响应数据对象，否则后续无法对响应数据进行处理 return p; &#125;, // 请求完成时的回调函数(请求成功或失败都会被执行) complete (p) &#123; console.log('request complete: ', p); &#125; &#125;); &#125;&#125; 8.2. 使用内置的wepy发送请求通过 wepy.request的方式来发送请求 如： 记得要先开启 wepy对promise 和 async 方法的支持。 12let movies = await wepy.request(&#123; url: "http://api.apiopen.top/searchAuthors?name=李白" &#125;);console.log(movies); 9. 循环标签repeat当需要循环渲染WePY组件时，必须使用WePY定义的辅助标签&lt;repeat&gt; 默认项为 item 索引为 index 12&lt;repeat for="&#123;&#123;list&#125;&#125;" key="index" index="index" item="item"&gt;&lt;/repeat&gt;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Ne</tag>
        <tag>MVVM</tag>
        <tag>Wepy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVVM框架进阶与实现--解析版]]></title>
    <url>%2F2018%2F11%2F28%2Fn_h_vue%2F</url>
    <content type="text"><![CDATA[Vue基本思路 创建vue对象：构造函数或者class类 声明data层数据（data,methods） 创建dom对象（#app）（告诉vue解析那一部分的dom对象）（view层） 创建compile：解析view层 解析指令：v-text等 解析文本 创建observer对象:劫持data层; 创建watcher层 连接compile和observer作用 compile创建文本碎片 所有操作dom在文本碎片中进行 处理结束之后放到body里面，再由浏览器进行解析； 可以避免一定程度的回流和重绘 compile方法解析node节点 注意区分元素节点和文本节点 进行递归操作：解析下一层的node 元素节点 主要解析指令 是在元素节点处进行递归解析 主要解析有”v-“开头指令 需要尤其注意v-on:click绑定事件特殊处理 文本节点 主要解析文本中包含此种形式的数据 正则分组参考文件 解析完毕解析完毕之后要将文本碎片放回body中 observer 主要作用通过Object.defineProperty检测data中所有的属性 此处依旧注意递归操作; watcher连接observer和compile 如果需要使页面更新,需要在compile中的指令解析的时候; 如果需要检测数据改变,需要在observer中的数据劫持的set中进行; 所以就需要 在更改dom对象值的时候使用watcher检测:声明watcher对象； 1234567if (type === 'text') &#123; node.textContent = this.getVmValue(expr) new Watcher(this.$vm, expr, (newAalue, oldValue) =&gt; &#123; node.textContent = newAalue; &#125;)&#125; 如果需要更改调用回调：在watcher内部需要一个方法来调用callback； 12345678update() &#123; let oldValue = this.oldValue; let newValue = this.getVMValue(this.vm, this.expr) if (oldValue !== newValue) &#123; this.cb(newValue, oldValue) &#125; &#125; 需要知道在什么时候调用update：数据改变的时候-也就是observer中的set方法调用的时候 问题： 我们是在compile中实例化的watcher，需要在observer中调用watcher中的updata方法 而且每一个数据在compile过程中，可能不只有一个watcher对象 data.msg==&gt;=&gt;v-test=&gt;v-html; data中的每一个key，都需要一个对象挂载上他自己的watcher对象 实现步骤需要在observer中劫持data中的每一个属性的时候，声明一个Dep（挂载此属性下watcher）对象1234let dep = new Dep();Object.defineProperty(obj, key, &#123; configurable: true, enumerable: true, 需要每个watcher在实例化的时候把自己放到Dep中的一个属性里面：；1234class Dep &#123; constructor() &#123; this.subs = [];//就是这个 &#125; 先把watcher挂载到一个对象上面，要求在observer中也能拿到：window可以，此处用的是dep本身； 12Dep.target = this;//此处的this就是watcher实例化之后的对象 在wathcer中调用获取oldValue的时候就会触发get方法，此时把我们挂载到Dep中的watcher放到dep中的subs数组中 1Dep.target &amp;&amp; dep.addSub(Dep.target) 解析总结整个完成之后data中的每一个属性都会有自己一个Dep,Dep中的subs包含着凡是用到过此属性的所有watcher； 在data发生改变之后 首先触发的是observer中的set方法； 调用dep中的发布函数：notify 发布函数会通知subs中的所有watcher调用自身的update函数 watcher中的updata会触发回调，改变元素的值；]]></content>
      <categories>
        <category>JavaScript进阶</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Ne</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpvue基本使用]]></title>
    <url>%2F2018%2F11%2F27%2Fn_wcmyvue%2F</url>
    <content type="text"><![CDATA[1. mpvue-介绍mpvue 是美团团队开发的语法类似 Vue.js 的小程序的前端框架 官网 开发文档 1.1. 主要特性主要有以下特性 彻底的组件化开发能力：提高代码复用性 完整的 Vue.js 开发体验 方便的 Vuex 数据管理方案：方便构建复杂应用 快捷的 webpack 构建机制：自定义构建策略、开发阶段 hotReload 支持使用 npm 外部依赖 使用 Vue.js 命令行工具 vue-cli 快速初始化项目 H5 代码转换编译成小程序目标代码的能力 1.2. 优秀案例 1.3. 前置知识 前端基本功 html + css + javascript nodejs es6 webpack vue 微信小程序 1.3.1. 代码示例12345678910111213new Vue(&#123; data: &#123; a: 1 &#125;, created () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a) &#125;, onShow () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a, '小程序触发的 onshow') &#125;&#125;) 2. 启动项目2.1. 全局安装vue脚手架工具1npm install --global vue-cli 2.2. 创建项目mpvue 提供了开发企业级的模板 quickstart 和 页面级的模板 simple。 1vue init mpvue/mpvue-quickstart my-project 2.3. 安装依赖12cd my-projectnpm install 2.4. 修改微信入口地址由于 mpvue中的 小程序入口路径和打包编译后的路劲 对应不上，因此需要我们手动的修改下 入口路径。 修改 project.config.json 文件 12345// 源代码&quot;miniprogramRoot&quot;: &quot;./dist/&quot;,// 修改为&quot;miniprogramRoot&quot;: &quot;./dist/wx/&quot;, 2.5. 启动项目1npm run dev 2.6. 使用小程序开发者工具打开编译成功后，可以看到在 dist/wx内有我们熟悉的小程序代码文件，此时，使用小程序开发者工具直接打开 项目的根目录(因为直接在配置文件中配置过 /dist/wx/入口路径 ) 3. 项目目录结构编译成功后，可以看到如下的项目结构 123456789101112131415├─build 打包构建相关配置文件├─config 用于打包的一些变量文件├─dist 小程序页面文件├─src mpvue源代码├─static 一些静态资源└─test 测试相关│ .babelrc js的编译配置│ .editorconfig 编辑器风格│ .gitignore git文件忽略清单│ .postcssrc.js 转换css到wxss的│ index.html 入口模板│ package-lock.json node包版本说明文件│ package.json 项目描述文件│ project.config.json 小程序开发者工具配置文件│ README.md 项目说明文档 4. 生命周期图示mpvue的生命周期结合了 vue和小程序的生命周期 4.1. vue 生命周期 beforeCreate 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用 created 在实例创建完成后被立即调用，$el 属性目前不可见，data中的数据可以使用 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted 示例和对应的dom都被创建后开始调用，子组件不一定全部被挂载，如要确保，使用 vm.$nextTick 来代替。$el可用。 beforeUpdate 数据更新时调用,这里适合在更新之前访问现有的 DOM，data中的数据更新了，但是视图还没有更新 updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁时会被调用，data中的数据更新了，视图也更新了 activated keep-alive 组件激活时调用 deactivated keep-alive 组件停用时调用 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用 destroyed Vue 实例销毁后调用，Vue 实例指示的所有东西都会解绑定，所有的事件监听器和所有的子实例都会被销毁 4.2. 小程序生命周期app 部分： onLaunch 小程序初始化时被调用 onShow 当小程序启动，或从后台进入前台显示被调用 onHide 当小程序从前台进入后台 page 部分： onLoad 页面加载完毕被调用 onShow 页面开始显示时被调用 onReady， 页面初次渲染完成被调用 onHide 页面隐藏时被调用 onUnload 页面卸载被调用 onPullDownRefresh 用户下拉动作开始时被调用 onReachBottom 页面上拉触底时被调用 onShareAppMessage 用户点击右上角分享时被调用 onPageScroll 页面滚动时被调用 onTabItemTap, 当前是 tab 页时，点击 tab 时触发 4.3. mpvue-生命周期图示 mpvue会在小程序 onReady 后，再去触发 vue mounted 生命周期 不建议使用小程序的生命周期钩子 5. mpvue 标签映射由于web中的标签和小程序中的标签存在差异，因此 mpvue内部提供了对应的标签转换，可以让开发者专注于业务本身，省去了记忆新标签的成本。 web标签 小程序标签 备注 div view[_div] p view[_p] span label a navigator 属性参照小程序的navigator img image 属性参照小程序的image ul view[_ul] ol view[_ol] 6. mpvue 语法6.1. 数据绑定mpvue绑定数据的方式大部分和vue一样。 6.1.1. 支持的语法 Mustache(双大括号) 文本插值 v-text属性的方式绑定 标签内属性方式绑定 :attr=&quot;value&quot; v-model也是支持的 6.1.2. 不支持的语法 v-html 因为小程序内部不支持动态标签 （会被解释为rich-text标签） v-once 暂时不支持 6.1.3. 代码示例12345678910111213&lt;!-- 1.0 支持的语法 --&gt;&lt;!-- 双括号 --&gt;&#123;&#123;msg&#125;&#125;&lt;!-- v-text --&gt;&lt;view v-text="msg"&gt;&lt;/view&gt;&lt;!-- :hidden --&gt;&lt;view :hidden="false" &gt;显示与隐藏&lt;/view&gt;&lt;!-- 2.0 不支持的错误 --&gt;&lt;!-- v-html --&gt;&lt;view v-html="htmlmsg"&gt;&lt;/view&gt;&lt;!-- v-once --&gt;&lt;view v-once="msg"&gt;&lt;/view&gt; 6.2. JavaScript 渲染表达式目前可以使用的有 + - * % ?: ! == === &gt; &lt; [] .，剩下的还待完善。 但写在 @event 里面的表达式是都支持的，因为这部分的计算放在了 vdom 里面 123456789&lt;!-- 这种就不支持，建议写 computed --&gt;&lt;p&gt;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/p&gt;&lt;!-- 但写在 @event 里面的表达式是都支持的，因为这部分的计算放在了 vdom 里面 --&gt;&lt;ul&gt; &lt;li v-for="item in list"&gt; &lt;div @click="clickHandle(item, index, $event)"&gt;&#123;&#123; item.value &#125;&#125;&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 6.3. computed 和 watch6.3.1. computed对于任何复杂逻辑，都应当使用计算属性 使用方式和vue中一样 12345computed:&#123;reversedMessage: function () &#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)&#125;&#125; 6.3.2. watchwatch相比于computed可以让我们做更多的事情。 使用方式和vue中一样 12345watch: &#123; msg(newValue, oldValue) &#123; console.log(&quot;watch被触发了&quot;); &#125;&#125; 6.4. 条件渲染6.4.1. v-if支持 v-if v-else 和 v-else if指令。 v-if 指令的显示和隐藏是通过 增加和删除节点实现。频繁操作性能损耗大。 123&lt;div v-if="false"&gt;if&lt;/div&gt;&lt;div v-else-if="true"&gt; v-else-if&lt;/div&gt;&lt;div v-else&gt;v-else&lt;/div&gt; 6.4.2. v-show用法大致一样 1&lt;div v-show="true"&gt;v-show&lt;/div&gt; 6.5. 列表渲染6.5.1. v-for v-for 可以循环 数组和对象等可迭代的对象。 mpvue中，嵌套列表渲染，必须指定不同的索引！ 数组 12345&lt;ul v-for="(card, index) in list"&gt; &lt;li v-for="(item, itemIndex) in card"&gt; &#123;&#123;item.value&#125;&#125; &lt;/li&gt; &lt;/ul&gt; 对象 123&lt;div v-for="(value, key) in object"&gt; &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; 嵌套列表渲染 12345&lt;ul v-for="(card, index) in list"&gt; &lt;li v-for="(item, itemIndex) in card"&gt; &#123;&#123;item.value&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 6.6. Class 与 Style 绑定动态设置样式 6.6.1. class 支持的语法:12345&lt;p :class="&#123; active: isActive &#125;"&gt;111&lt;/p&gt;&lt;p class="static" v-bind:class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt;222&lt;/p&gt;&lt;p class="static" :class="[activeClass, errorClass]"&gt;333&lt;/p&gt;&lt;p class="static" v-bind:class="[isActive ? activeClass : '', errorClass]"&gt;444&lt;/p&gt;&lt;p class="static" v-bind:class="[&#123; active: isActive &#125;, errorClass]"&gt;555&lt;/p&gt; 6.6.2. style 支持的语法:12&lt;p v-bind:style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;666&lt;/p&gt;&lt;p v-bind:style="[&#123; color: activeColor, fontSize: fontSize + 'px' &#125;]"&gt;777&lt;/p&gt; 6.6.3. 不支持的语法 不支持 官方文档：Class 与 Style 绑定 中的 classObject 和 styleObject 语法。 不支持在组件上使用 Class 与 Style 绑定 7. 事件几乎全支持 vue中的事件处理器 7.1. 绑定方式使用v-bind或者@关键字来执行绑定 12345// v-bind&lt;view v-bind:click="clickHandle3"&gt;点我&lt;/view&gt;// @ &lt;view @click="clickHandle3"&gt;点我&lt;/view&gt; 7.2. 事件映射表 WEB 事件 小程序 事件 备注 click tap touchstart touchstart touchmove touchmove touchcancel touchcancel touchend touchend tap tap longtap longtap input input change change submit submit blur blur focus focus reset reset confirm confirm columnchange columnchange linechange linechange error error scrolltoupper scrolltoupper scrolltolower scrolltolower scroll scroll 7.3. 踩坑注意 列表中没有的原生事件也可以使用例如 bindregionchange 事件直接在 dom 上将bind改为@ 小程序能力所致，bind 和 catch 事件同时绑定时候，只会触发 bind ,catch 不会被触发，要避免踩坑。 事件修饰符 .stop 的使用会阻止冒泡，但是同时绑定了一个非冒泡事件，会导致该元素上的 catchEventName 失效！ .prevent 可以直接干掉，因为小程序里没有什么默认事件，比如submit并不会跳转页面 .capture 支持 1.0.9 .self 没有可以判断的标识 .once 也不能做，因为小程序没有 removeEventListener, 虽然可以直接在 handleProxy 中处理，但非常的不优雅，违背了原意，暂不考虑 其他 键值修饰符 等在小程序中压根没键盘，所以。。。 @regionchange,同时这个事件也非常特殊，它的 event type 有 begin 和 end 两个，导致我们无法在handleProxy 中区分到底是什么事件，所以你在监听此类事件的时候同时监听事件名和事件类型既 &lt;map @regionchange=&quot;functionName&quot; @end=&quot;functionName&quot; @begin=&quot;functionName&quot;&gt;&lt;map&gt; 8. 表单控件绑定建议开发过程中直接使用 微信小程序：表单组件 如： select 组件用 picker 组件进行代替 表单元素 radio 用 radio-group 组件进行代替 9. 组件有且只能使用单文件组件（.vue 组件）的形式进行支持。详细的使用方式，参照vue中的组件文档 9.1. 定义组件新建组件文件 card.vue 组件也是分为3个部分。 标签 template 脚本 script 和 样式 style 编辑内容 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;p class="card"&gt; &#123;&#123;text&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; text: "卡片组件" &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;.card &#123; padding: 10px;&#125;&lt;/style&gt; 9.2. 使用组件在某个页面文件中使用组件 card.vue 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;card&gt;&lt;/card&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import card from '@/components/card'export default &#123; components: &#123; card &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 9.3. 组件传值父组件通过prop来向子组件传递数据。 9.3.1. 父组件在data中定义数据同时在标签上通过属性的方式传递 123456789&lt;!-- template --&gt;&lt;card :text="msg"&gt;&lt;/card&gt;&lt;!-- script --&gt; data () &#123; return &#123; msg: "mpvue" &#125;&#125; 9.3.2. 子组件通过props进行接收 123export default &#123; props: ['text']&#125; 9.4. 组件通信主要有三种方式 子向父 通过$emit 所有的组件之间 通过事件总线 EventBus 企业级的组件通信，建议使用 vuex状态管理方案 来实现，更好维护数据。 9.4.1. 子向父通信通过 $emit关键字触发 父组件中 1234567891011121314151617&lt;template&gt; &lt;card2 @parentEvent="parentHd"&gt;&lt;/card2&gt;&lt;/template&gt;&lt;script&gt; import card2 from "@/components/card2.vue"; export default &#123; components: &#123; card2 &#125;, methods: &#123; parentHd(...args) &#123; console.log(args); console.log("父组件打印纸"); &#125; &#125; &#125;&lt;/script&gt; 子组件中 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['text'], mounted()&#123; setTimeout(() =&gt; &#123; this.$emit("parentEvent",1,2,3,4); &#125;, 5000); &#125;&#125;&lt;/script&gt; 9.4.2. 事件总线 EventBusEventBus 又称为事件总线。它是组件共用的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件。使用起来很方便，但是容器导致代码混乱，不好维护。 新建总线文件 在 utils/中新建 js文件 event-bus.js 12import Vue from 'vue'export default new Vue() 组件中开始触发事件 123456789101112131415161718 &lt;!-- template --&gt; &lt;div&gt; &lt;p class="card" @click="clickHd"&gt; 组件3 &lt;/p&gt; &lt;/div&gt;&lt;script&gt; /* script */ import &#123; EventBus &#125; from "../utils/event-bus.js"; export default &#123; methods: &#123; clickHd() &#123; EventBus.$emit("incremented", &#123; num: 111, deg: 222 &#125;); &#125; &#125; &#125;&lt;/script&gt; 其他页面监听 12345678910import &#123; EventBus &#125; from "@/utils/event-bus.js"; mounted() &#123; EventBus.$on("incremented", (&#123; num, deg &#125;) =&gt; &#123; console.log(num, deg); &#125;); &#125;, 9.5. 不支持的功能 暂不支持在组件引用时，在组件上定义 click 等原生事件、v-show（可用 v-if 代替）和 class style 等样式属性(例：&lt;card class=&quot;class-name&quot;&gt; &lt;/card&gt; 样式是不会生效的)，因为编译到 wxml，小程序不会生成节点，建议写在内部顶级元素上。 Slot（scoped 暂时还没做支持） 动态组件 异步组件 inline-template X-Templates keep-alive transition class style]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Ne</tag>
        <tag>MVVM</tag>
        <tag>MpVue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发]]></title>
    <url>%2F2018%2F11%2F27%2Fn_weChat%2F</url>
    <content type="text"><![CDATA[1. 小程序介绍微信小程序 ( Mini Program ) ，微信创始人 张小龙 ，在2017年1月9日宣布的微信小程序正式上线 1.1. 特点 触手可及，用完即走 拥有和原生APP的体验 用户量大 面向所有用户开放（企业，组织，个人均可以发布自己的小程序） 小程序就是套在 微信里面的原生APP 1.2. 小程序的运行环境1.2.1. 传统原生APP 1.2.2. 微信运行环境 1.2.3. 微信小程序运行环境 1.2.4. 小结问： 微信小程序和原生APP、微信有什么联系？ 答： 微信小程序就是套在微信里的原生APP 2. 开发环境的准备2.1. 注册账号访问注册页面，耐心完成注册即可。 2.2. 获取APPID由于后期调用微信小程序的接口等功能，需要索取开发者的小程序中的APPID，所以在注册成功后，可登录，然后获取APPID。 登录，成功后可看到如下界面 然后复制你的APPID,悄悄的保存起来，不要给别人看到😄。 2.3. 开发工具严格来说，微信小程序支持所有的开发工具，但是从效率和便利性来说，推荐如下 vs code 下载地址 推荐vs code 代码插件 wechat-snippet 文件图标主题 file-icons 微信自己的微信小程序开发工具 下载地址 3. 我的第一个微信小程序下面开始演示如何创建我的第一个微信小程序 3.1. 安装微信小程序开发者工具下载好微信小程序开发者工具后，直接双击安装，一直点击下一步即可。 安装好后，界面如下 3.2. 选择小程序项目 3.3. 新建项目 3.4. 创建项目 3.5. 成功 4. 微信开发工具深入介绍工具介绍 5. mina框架小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。 框架提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。 官网 5.1. 小程序文件结构和传统web对比 结构 传统web 微信小程序 结构 HTML WXML 样式 CSS WXSS 逻辑 Javascript Javascript 配置 无 JSON 通过以上对比得出，传统web 是三层结构。而微信小程序 是四层结构，多了一层 配置.json 5.2. 基本的项目目录 6. 配置介绍一个小程序应用程序会包括最基本的两种配置文件。一种是全局的 app.json 和 页面自己的 page.json 注意：配置文件中不能出现注释 6.1. 全局配置app.jsonapp.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。普通快速启动项目里边的 app.json 配置 123456789101112&#123; &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;:&#123; &quot;backgroundTextStyle&quot;:&quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;, &quot;navigationBarTextStyle&quot;:&quot;black&quot; &#125;&#125; 字段的含义 pages字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。 window字段 —— 定义小程序所有页面的顶部背景颜色，文字颜色定义等。 完整的配置信息请参考 app.json配置 6.2. page.json这里的 page.json 其实用来表示页面目录下的 page.json 这类和小程序页面相关的配置。 开发者可以独立定义每个页面的一些属性，如顶部颜色、是否允许下拉刷新等等。 页面的配置只能设置 app.json 中部分 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。 属性 类型 默认值 描述 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如 #000000 navigationBarTextStyle String white 导航栏标题颜色，仅支持 black / white navigationBarTitleText String 导航栏标题文字内容 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark / light enablePullDownRefresh Boolean false 是否全局开启下拉刷新。 详见 Page.onPullDownRefresh onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px。 详见 Page.onReachBottom disableScroll Boolean false 设置为 true 则页面整体不能上下滚动；只在页面配置中有效，无法在 app.json 中设置该项 7. 视图层WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。 7.1. 数据绑定7.1.1. 普通写法1&lt;view&gt; &#123;&#123; message &#125;&#125; &lt;/view&gt; 12345Page(&#123; data: &#123; message: 'Hello MINA!' &#125;&#125;) 7.1.2. 组件属性1&lt;view id="item-&#123;&#123;id&#125;&#125;"&gt; &lt;/view&gt; 12345Page(&#123; data: &#123; id: 0 &#125;&#125;) 7.1.3. bool类型不要直接写 checked=”false”，其计算结果是一个字符串 1&lt;checkbox checked="&#123;&#123;false&#125;&#125;"&gt; &lt;/checkbox&gt; 7.2. 运算7.2.1. 三元运算1&lt;view hidden="&#123;&#123;flag ? true : false&#125;&#125;"&gt; Hidden &lt;/view&gt; 7.2.2. 算数运算1&lt;view&gt; &#123;&#123;a + b&#125;&#125; + &#123;&#123;c&#125;&#125; + d &lt;/view&gt; 1234567Page(&#123; data: &#123; a: 1, b: 2, c: 3 &#125;&#125;) 7.2.3. 逻辑判断1&lt;view wx:if="&#123;&#123;length &gt; 5&#125;&#125;"&gt; &lt;/view&gt; 7.2.4. 字符串运算1&lt;view&gt;&#123;&#123;"hello" + name&#125;&#125;&lt;/view&gt; 12345Page(&#123; data:&#123; name: 'MINA' &#125;&#125;) 7.2.5. 注意 花括号和引号之间如果有空格，将最终被解析成为字符串 7.3. 列表渲染7.3.1. wx:for项的变量名默认为 item wx:for-item 可以指定数组当前元素的变量名 下标变量名默认为 index wx:for-index 可以指定数组当前下标的变量名 123&lt;view wx:for="&#123;&#123;array&#125;&#125;"&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;&lt;/view&gt; 123456789Page(&#123; data: &#123; array: [&#123; message: 'foo', &#125;, &#123; message: 'bar' &#125;] &#125;&#125;) 7.3.2. wx:for渲染一个包含多节点的结构块 block最终不会变成真正的dom元素 1234&lt;block wx:for="&#123;&#123;[1, 2, 3]&#125;&#125;"&gt; &lt;view&gt; &#123;&#123;index&#125;&#125;: &lt;/view&gt; &lt;view&gt; &#123;&#123;item&#125;&#125; &lt;/view&gt;&lt;/block&gt; 7.3.3. wx:key提高效率使用的 7.4. 条件渲染7.4.1. wx:if在框架中，使用 wx:if=&quot;&quot; 来判断是否需要渲染该代码块： 1&lt;view wx:if="&#123;&#123;condition&#125;&#125;"&gt; True &lt;/view&gt; 7.4.2. hidden1&lt;view hidden="&#123;&#123;condition&#125;&#125;"&gt; True &lt;/view&gt; 类似 wx:if 频繁切换 用 hidden 不常使用 用 wx:if 8. WXSSWXSS(WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。 与 CSS 相比，WXSS 扩展的特性有： 尺寸单位 样式导入 8.1. 尺寸单位 rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。 设备 rpx换算px (屏幕宽度/750) px换算rpx (750/屏幕宽度) iPhone5 1rpx = 0.42px 1px = 2.34rpx iPhone6 1rpx = 0.5px 1px = 2rpx iPhone6 Plus 1rpx = 0.552px 1px = 1.81rpx 建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。 注意： 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。 8.2. 样式导入使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。 示例代码： 1234/** common.wxss **/.small-p &#123; padding:5px;&#125; 12345/** app.wxss **/@import "common.wxss";.middle-p &#123; padding:15px;&#125; 8.3. 内联样式框架组件上支持使用 style、class 属性来控制组件的样式。 style：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。 1&lt;view style="color:&#123;&#123;color&#125;&#125;;" /&gt; class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上.，样式类名之间用空格分隔。 1&lt;view class="normal_view" /&gt; 8.3.1. 选择器目前支持的选择器有： 选择器 样例 样例描述 .class .intro 选择所有拥有 class=”intro” 的组件 #id #firstname 选择拥有 id=”firstname” 的组件 element view 选择所有 view 组件 element, element view, checkbox 选择所有文档的 view 组件和所有的 checkbox 组件 ::after view::after 在 view 组件后边插入内容 ::before view::before 在 view 组件前边插入内容 8.3.2. 全局样式与局部样式定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。 9. 基本组件 小程序提供了常用的标签组件用于构建页面 组件 9.1. view 类似 div 属性名 类型 默认值 说明 hover-class String none 指定按下去的样式类。当 hover-class=&quot;none&quot; 时，没有点击态效果 9.1.1. 代码1234567&lt;view hover-class="h-class"&gt;点击我试试&lt;/view&gt;&lt;!-- wxss --&gt;.h-class&#123; background-color: yellow;&#125; 9.2. text 显示普通的文本 text只能嵌套text 属性名 类型 默认值 说明 selectable Boolean false 文本是否可选 decode Boolean false 是否解码 9.2.1. 代码123&lt;text selectable="&#123;&#123;false&#125;&#125;" decode="&#123;&#123;false&#125;&#125;"&gt; 普&amp;nbsp;通&lt;/text&gt; 9.3. image 图片标签，image组件默认宽度320px、高度240px 注意：该标签 其实是 web中的 图片标签 和 背景图片的结合！！！ 并且不支持以前的web中的背景图片的写法！！！ 属性名 类型 默认值 说明 src String 图片资源地址，支持云文件ID（2.2.3起） mode String ‘scaleToFill’ 图片裁剪、缩放的模式 lazy-load Boolean false 图片懒加载。只针对page与scroll-view下的image有效 mode 有效值： mode 有 13 种模式，其中 4 种是缩放模式，9 种是裁剪模式。 模式 值 说明 缩放 scaleToFill 不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素 缩放 aspectFit 保持纵横比缩放图片，使图片的长边能完全显示出来。 缩放 aspectFill 保持纵横比缩放图片，只保证图片的短边能完全显示出来。 缩放 widthFix 宽度不变，高度自动变化，保持原图宽高比不变 裁剪 top 不缩放图片，只显示图片的顶部区域 裁剪 bottom 不缩放图片，只显示图片的底部区域 裁剪 center 不缩放图片，只显示图片的中间区域 裁剪 left 不缩放图片，只显示图片的左边区域 裁剪 right 不缩放图片，只显示图片的右边区域 裁剪 top left 不缩放图片，只显示图片的左上边区域 裁剪 top right 不缩放图片，只显示图片的右上边区域 裁剪 bottom left 不缩放图片，只显示图片的左下边区域 裁剪 bottom right 不缩放图片，只显示图片的右下边区域 9.4. swiper 微信内置有轮播图组件 默认宽度 100% 高度 150px 属性名 类型 默认值 说明 indicator-dots Boolean false 是否显示面板指示点 indicator-color Color rgba(0, 0, 0, .3) 指示点颜色 indicator-active-color Color #000000 当前选中的指示点颜色 autoplay Boolean false 是否自动切换 interval Number 5000 自动切换时间间隔 9.4.1. swiper滑块视图容器。 9.4.2. swiper-item 滑块 默认宽度和高度都是100% 9.5. navigator 导航组件 类似超链接标签 属性名 类型 默认值 说明 target String self 在哪个目标上发生跳转，默认当前小程序，可选值self/miniProgram url String 当前小程序内的跳转链接 open-type String navigate 跳转方式 open-type 有效值： 值 说明 navigate 保留当前页面，跳转到应用内的某个页面，但是不能跳到 tabbar 页面 redirect 关闭当前页面，跳转到应用内的某个页面，但是不允许跳转到 tabbar 页面。 switchTab 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 reLaunch 关闭所有页面，打开到应用内的某个页面 navigateBack 关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层 exit 退出小程序，target=”miniProgram”时生效 10. 自定义组件小程序允许我们使用自定义组件的方式来构建页面。 自定义组件 10.1. 创建自定义组件 类似于页面，一个自定义组件由 json wxml wxss js 4个文件组成 10.1.1. 声明组件首先需要在 json 文件中进行自定义组件声明 123&#123; &quot;component&quot;: true&#125; 10.1.2. 编辑组件同时，还要在 wxml 文件中编写组件模板，在 wxss 文件中加入组件样式 注意：在组件wxss中不应使用ID选择器、属性选择器和标签名选择器。 12345&lt;!-- 这是自定义组件的内部WXML结构 --&gt;&lt;view class="inner"&gt; &#123;&#123;innerText&#125;&#125;&lt;/view&gt;&lt;slot&gt;&lt;/slot&gt; 1234/* 这里的样式只应用于这个自定义组件 */.inner &#123; color: red;&#125; 10.1.3. 注册组件在自定义组件的 js 文件中，需要使用 Component() 来注册组件，并提供组件的属性定义、内部数据和自定义方法 1234567891011121314151617Component(&#123; properties: &#123; // 这里定义了innerText属性，属性值可以在组件使用时指定 innerText: &#123; type: String, value: &apos;default value&apos;, &#125; &#125;, data: &#123; // 这里是一些组件内部数据 someData: &#123;&#125; &#125;, methods: &#123; // 这里是一个自定义方法 customMethod: function()&#123;&#125; &#125;&#125;) 10.2. 使用自定义组件首先要在页面的 json 文件中进行引用声明。还要提供对应的组件名和组件路径 1234567&#123; // 引用声明 &quot;usingComponents&quot;: &#123; // 要使用的组件的名称 // 组件的路径 &quot;component-tag-name&quot;: &quot;path/to/the/custom/component&quot; &#125;&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Ne</tag>
        <tag>weChat</tag>
        <tag>mina</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVVM框架进阶与实现]]></title>
    <url>%2F2018%2F11%2F14%2Fn_myVue%2F</url>
    <content type="text"><![CDATA[MVVM框架介绍介绍 M ：Modal 模型层 V ：View 视图层 VM ： ViewModal 视图模型，V和M的桥梁 MVVM框架实现了数据双向绑定 当M层数据进行修改时，VM层会检测到变化，并且通知V层进行相应的修改； 修改V层则会通知M层数据进行修改 MVVM框架实现了视图和模型层的相互解耦 几种双向数据绑定的方式 发布-订阅者模式（backbone.js）一般通过pub、sub的方式来实现数据和视图的绑定，但是使用比较麻烦 脏值检查（anjular.js）angular.js是通过脏值检测的方式对数据是否有变更，来决定是否更新视图。类似于通过定时器轮训检测数据是否发生了改变； 数据劫持vue.js是通过数据劫持结合发布者-订阅者的方式。通过Object.defineProperty()来劫持各个属性的setter、getter，在数据发生变动的时候发布消息给订阅者，触发相应的监听回调 Vue实现思路 实现一个Compile模板解析器，能够对模板中的指令和插值表达式进行解析，并且赋予不同的操作 实现一个Observe数据监听器，能够对数据对象的所有属性进行监听 实现一个Watcher观察者，将Compile的解析结果，与Observer所观察的对象链接起来，建立关系，在Observer观察对象到对象数据变化时，接受通知，同时更新DOM 创建一个公共的入口对象，接受初始化的配置并且协调上面三个模块，也就是Vue Compile实现逻辑创建文件 需要基本的html文件，vue.js文件，并且引入并且实例化vue对象 123456789101112131415161718192021&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p v-text="msg"&gt;&lt;/p&gt; &lt;p v-html="msg"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="./src/compile.js"&gt;&lt;/script&gt;&lt;script src="./src/vue.js"&gt;&lt;/script&gt;&lt;script&gt; var el = new Vue(&#123; el: '#app', data: &#123; msg: "hello vue" &#125; &#125;) console.log(el)&lt;/script&gt;&lt;/html&gt; 创建vue对象 123456789101112class Vue &#123; constructor(option = &#123;&#125;) &#123; this.$el = option.el; this.$data = option.data; if (this.$el) &#123; //compile负责解析模板的内容 new Compile(this.$el, this) &#125; &#125;&#125; 创建Compile模板解析器、 123456789class Compile &#123; constructor(el, vm) &#123; //允许用户传递的dom对象可以是真实Dom或者是选择器 this.el = typeof el === 'string' ? document.querySelector(el) : el; this.vm = vm; &#125;&#125; 创建文本碎片DocumentFragments 是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。 因为文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。 关于createDocumentFragment方法 12345678910111213141516171819202122232425if (this.el) &#123; let fragment = this.node2fragment(this.el)&#125; /** * 核心方法-生成文档碎片 * @param &#123;根Dom对象&#125; node */ node2fragment(node) &#123; let fragment = document.createDocumentFragment(); let childNodes = node.childNodes; this.toArray(childNodes).forEach(node =&gt; &#123; fragment.appendChild(node); &#125;); &#125; /** * 工具方法-类数组转化数组 * @param &#123;类数组&#125; likeArray */ toArray(likeArray) &#123; return [].slice.call(likeArray) &#125; 根据类型解析节点 区分是文本节点还是元素节点来分别解析 使用递归层层解析 123456789101112131415/** * 工具方法-类数组转化数组 * @param &#123;类数组&#125; likeArray */toArray(likeArray) &#123; return [].slice.call(likeArray)&#125;/** * 判断是否是元素节点 * @param &#123;node&#125; node */isElementNode(node) &#123; return node.nodeType === 1;&#125; 解析元素节点 需要分别解析v-text v-html v-modal指令 v-on指令因为类型原因需要特别解析 1234567891011121314151617181920212223242526272829/** * 解析元素节点 * @param &#123;节点&#125; node */compileElement(node) &#123; // 1.获取所有当前节点下的属性 let attributes = node.attributes; this.toArray(attributes).forEach((attr) =&gt; &#123; let attrName = attr.name; if (this.isDirective(attrName)) &#123; let type = attrName.slice(2); let attrValue = attr.value; if (type === 'text') &#123; node.textContent = this.vm.$data[attrValue]; &#125; if (type === 'html') &#123; node.textContent = this.vm.$data[attrValue]; &#125; if (type === 'modal') &#123; node.value = this.vm.$data[attrValue]; &#125; if (this.isEventDirective(type)) &#123; let eventType = attrName.split(':')[1]; node.addEventListener(eventType, this.vm.$methods[attrValue].bind(this.vm)) &#125; &#125; &#125;)&#125; 解析文本节点12345678910111213141516171819//解析文本节点mustache(node, vm) &#123; let txt = node.textContent; let reg = /\&#123;\&#123;(.+)\&#125;\&#125;/; if (reg.test(txt)) &#123; let expr = RegExp.$1; node.textContent = txt.replace(reg, this.getVMValue(vm, expr)) &#125;&#125;, //获取VM中的数据getVMValue(vm, expr) &#123; let data = vm.$data; expr.split('.').forEach(key =&gt; &#123; data = data[key] &#125;) return data;&#125; Observer实现逻辑关于数据劫持关于Object.defineProperty方法 configurable当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。 enumerable当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。 get一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为 undefined。 set一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为 undefined。 简单案例12345678910111213141516171819var obj = &#123; name: 12,&#125;var temp = obj.name;Object.defineProperty(obj, 'name', &#123; configurable: true, enumerable: true, get() &#123; console.log(obj) return temp; &#125;, set(newValue) &#123; console.log(newValue) temp = newValue console.log(obj) &#125;&#125;) observer实现 观察者目的是使用数据劫持检测$data下的所有数据（为什么天赐还没成大佬） 1new Observer(this.vm.$data); 使用Object.keys(data)方法获取所有key，并通过Object.defineProperty为所有数据添加绑定（为什么天赐还没成大佬） 为了绑定复杂数据，需要进行递归操作（为什么天赐还没成大佬） 在set函数中，设置了新的数据，也需要进行监控（为什么天赐还没成大佬） 123456789101112131415161718192021222324252627282930313233constructor(data) &#123; this.walk(data);&#125;walk(data) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; Object.keys(data).forEach((key) =&gt; &#123; this.defineReactive(data, key, data[key]) this.walk(data[key]) &#125;)&#125;defineReactive(obj, key, value) &#123; const self = this; Object.defineProperty(obj, key, &#123; configurable: true, enumerable: true, get() &#123; console.log('获取了', value) return value; &#125;, set(newvalue) &#123; if (newvalue === value) &#123; return &#125; console.log('设置了', newvalue) value = newvalue; self.walk(value) &#125; &#125;)&#125; Wacher实现逻辑已经实现了页面渲染compile以及数据监听observer，接下来是将数据和页面做一个连接，即是，数据发生改变之后通知compile重新渲染，compile发生改变之后通知observer更改数据，接下来的watcher作为一个连接中心，实现这一部分的功能； 创建watcher对象初始化需要传递三个变量 vm:vue对象实例 expr:数据对象 cb:callback回调函数 123456constructor(vm, expr, cb) &#123; this.vm = vm; this.expr = expr; this.cb = cb; this.oldValue = this.getVMValue(vm, expr);&#125; 创建更新数据函数12345678update() &#123; let oldValue = this.oldValue; let newValue = this.getVMValue(this.vm, this.expr) if (oldValue !== newValue) &#123; this.cb(newValue, oldValue) &#125;&#125; 实例化watcher对象12345678//解析v-text指令text(node, vm, expr) &#123; node.textContent = this.getVMValue(vm, expr) window.Watcher = new Watcher(vm, expr, (newVlaue, oldValue) =&gt; &#123; console.log(newVlaue, '打印newValue') node.textContent = newVlaue &#125;)&#125;, 获取新值调用update123456789set(newvalue) &#123; if (newvalue === value) &#123; return &#125; console.log('设置了', newvalue) value = newvalue; window.Watcher.update(); self.walk(value)&#125; 使用订阅发布者模式检测数值改变 声明发布者构造函数 订阅检测对象 实例化检测data中的每一个属性 12345678910111213141516class Dep &#123; constructor() &#123; this.subs = []; &#125; addSub(watcher) &#123; this.subs.push(watcher) &#125; notify() &#123; this.subs.forEach(sub =&gt; &#123; sub.update(); &#125;) &#125;&#125; 12345678910111213141516171819202122232425262728Dep.target = this;this.oldValue = this.getVMValue(vm, expr);Dep.target = null;//observer.jsdefineReactive(obj, key, value) &#123; const self = this; let dep = new Dep(); Object.defineProperty(obj, key, &#123; configurable: true, enumerable: true, get() &#123; Dep.target &amp;&amp; dep.addSub(Dep.target) return value; &#125;, set(newvalue) &#123; if (newvalue === value) &#123; return &#125; value = newvalue; dep.notify(); self.walk(value) &#125; &#125;)&#125; 实现双向数据绑定123456789101112 node.addEventListener('input', function() &#123; var arr = expr.split('.'); var data = vm.$data; arr.forEach((v, i) =&gt; &#123; if (i == arr.length - 1) &#123; data[v] = this.value; &#125; else &#123; data = data[v]; &#125; console.log(data); &#125;)&#125;) 将数据挂载到vue对象中12345678910111213141516171819202122232425262728293031class Vue &#123; constructor(option = &#123;&#125;) &#123; this.$el = option.el; this.$data = option.data; this.$methods = option.methods; new Observer(this.$data); this.porxy(this.$data) this.porxy(this.$methods) if (this.$el) &#123; //compile负责解析模板的内容 let c = new Compile(this.$el, this); &#125; &#125; porxy(data) &#123; Object.keys(data).forEach((key) =&gt; &#123; Object.defineProperty(this, key, &#123; configurable: true, enumerable: true, get() &#123; return data[key] &#125;, set(newvalue) &#123; if (data[key] === newvalue) &#123; return &#125; data[key] = newvalue; &#125; &#125;) &#125;) &#125;&#125;]]></content>
      <categories>
        <category>JavaScript进阶</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Ne</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flow&TypeScript]]></title>
    <url>%2F2018%2F10%2F29%2Fn_flow_typeScript%2F</url>
    <content type="text"><![CDATA[Javscript语言特征介绍JavaScript是一种弱类型，动态类型检查的语言 弱类型和强类型弱类型在定义变量的时候，我们可以为变量赋值任何数值，变量的数据类型不是固定死的，这样的类型叫做弱类型 强类型在声明变量的时候，一旦给变量赋值，那么变零的数据类型已经确定，之后如果要给该变量赋值其他类型的数据，需要进行强制数据类型转换； 动态类型和静态类型动态类型和静态类型的核心区别：动态类型的类型检查会在代码运行的时候进行，而静态类型检查则是在编译时候进行； FlowFlow官网 安装步骤12npm init -y npm i flow-bin -D 使用步骤声明flow需要给文件添加@flow 标记，否则flow不会对文件进行类型检测 1//@flow 书写方式 通过注释的方式进行添加（不会改写js） 123var a /*:number */ = 12;a = "111";console.log(a) 通过直接给数据添加类型，改写js代码，如果需要正常运行，需要进行babel进行转码 123var a: number = 12;a = 1;console.log(a); 使用flow进行检查 在package.json中添加命令 1"flow": "flow" 创建flow配置文件.flowconfig1npm run flow init 使用babel对flow进行转码如果给数据添加类型声明通过第二种方式，直接修改js代码，那么代码是不能正常运行的； 我们需要通过babel对代码进行转码之后才能正常进行 安装bebel以及persets 1npm i babel-cli babel-preset-flow -D 新建 .babelrc文件并添加配置 12345&#123; &quot;presets&quot;: [ &quot;flow&quot; ]&#125; 配置package.json 添加build命令调用babel 12&quot;build&quot;:&quot;babel ./src -d ./dist&quot; 执行build命令进行转换 Flow的数据类型类型说明 类型 说明 number 数字、NaN、Infinity都是number类型的数据 string 字符串 null 只有null是null类型的 void undefined在flow中类型就是void Array 数组类型，定义的时候需要使用 Array这种形式，T为指定的类型，说的是特定类型的数据组成的数组 Object 对象类型，由于对象比较自由，可以规定对象类型的时候有多中写法 any 表示任意类型，这个尽量少用，但是有时有很有用 Functions 函数类型 Maybe Maybe类型允许我们声明一个包含null和undefined两个潜在类型的值 或操作 或操作可以设置一个变量为多种可能的类型 类型判断 flow会常识自行腿短某个数据的类型 部分案例12345678910111213141516171819202122232425262728293031323334353637383940//@flow//1.数组let a: Array &lt; number &gt; = [1, 2, 3];//2.函数function test(a: number, b: number): number &#123; return a + b;&#125;;test(1, 2);//3.maybefunction test2(a: ? number) &#123; a = a || 0; console.log(a)&#125;test2()test2(1)//3.或 |let b: number | string = 1;b = 1;b = '1'//4.Objectfunction greet(obj: &#123; sayHello: () =&gt; void, name: string &#125;) &#123; obj.sayHello();&#125; TypeScript介绍TypeScript是微软公司开发的一种开源的JavaScript超集语言 JavaScript超集：当前任何JavaScript都是合法的TypeScript代码 TypeScript主要是为JavaScript提供了类型系统和ES6的语法支持； Flow是一个类型检查工具，而TypeScript是一种开发语言 TypeScript有自己的编译工具，我们写好的TypeScript代码最终通过编译器编译成JavaScript代码进行运行 安装TypeScriptTypeScript代码最终要运行起来，我们需要编译成JavaScript代码，那么TypeScript的命令工具就可以帮我们完成；TypeScript命令行工具安装方法如下： 1npm install -g typescript 以上命令会在全局安装typescript命令，完成之后可以在任何地方执行tsc命令 1tsc index.js TypeScript配置文件生成tsconfig.json文件1tsc --init 设置配置项 targe：指的就是将ts代码要转换成那个版本的es5，es3 module：指的就是将ts代码转换成js代码之后，使用的模块化的标准是什么 outDir：指的就是ts代码转成js之后，js代码存放的文件夹路径 rootDir：指的就是要将哪个目录的ts代码进行转换；ts代码的存放路径 strict：是否要将ts代码转换成严格模式的js代码 使用配置文件1tsc -p ./tsconfig.js 数据类型数字（Number）数字类型可以是普通数字、NaN、Infinity,包括可以赋值二进制，八进制，16进制等（0x:16进制、0b:2进制、0o:8进制） 12345let b: number = Infinity;let n2: number = 0xA12;let n3: number = 0b1010;let n4: number = 0o75; 字符串（String）字符串类型可以使用单引号、双引号以及ES6的模板字符串； 123let str:string = "abc";let str2:string = "$&#123;str&#125;def" 数组（Array）数组可以使用两种方式声明 123let arr :Array&lt;number&gt; = [2,3,4];let arr2:number[] = [1,2,3] 元祖（Tuple）12let arr2 = [number,string] = [1,'a]; 空值 （void）1let res:void = undefined; 对象（Object）123let o:object =&#123;&#125;;let o2 Nevernever类型表示的是永不存在的值，例如，never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式；变量也可能是never类型，当它们被永不为真的类型保护所约束时 1234567891011121314function error(message:string):never&#123; throw new Error(message)&#125;function fail(message:string)&#123; return error(message)&#125;function infinitloop():never &#123; while(true)&#123;&#125;&#125; 枚举（enum）enum类型是对JavaScript标准类型的一个补充。可以未一组数值赋予友好的名字 1234enum Color &#123; Red, Green,&#125; 默认情况下，从0开始为元素编号，也可以手动为指定成员赋值 12345enum Color &#123; Red = 1, Green = 2,&#125; 类型断言有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息，通常这会发生在你清除的知道一个实体具有比他现有类型更确切的类型。 通过类型断言这种方式可以告诉浏览器，类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。 123456let someVal:any = 'this is a string';// 断言1let someLen:number =(&lt;string&gt;someVal).length;// 断言2let someLe2:number =(someVal as string).length; 两种方式是等价的，但是当在TypeScript中使用JSX时，只有as语法断言是被允许的； TypeScript中的类基本使用 和ES6不同的是，TS中属性必须声明，需要指定类型 声明好属性之后，属性必须赋值一个默认值或者在构造函数中进行初始化 12345678class Person &#123; name: string age: number = 12 constructor(name: string) &#123; this.name = name; &#125;&#125; 继承 继承类的时候在constructor调用super方法； 子类中如果出现和父类同名的方法，则会进行覆盖，调用的会后调用的是子类的方法； 1234567class Teacher extends Person &#123; type: string constructor(type: string) &#123; super('12') this.type = type &#125;&#125; 访问修饰符 public ：公共，默认 private：私有的，只能在当前类中进行访问 protected：受保护的，这能在当前类或者子类中进行访问 readonly修饰符可以使用readonly关键字将属性设置为只读，只读属性必须在声明时活构造函数里面被初始化 参数属性可以方便的让我们在一个地方定义并初始化一个成员 12345class Anmial &#123; constructor(private name:string)&#123;&#125; &#125; 类成员的存取器在set的时候可以根据需求判断是否执行操作； 123456789class People&#123; private _name:string = ""; get name():string&#123; return this._name &#125; set name(value:string)&#123; this._name = value; &#125;&#125; TypeScript的接口基本使用接口可以理解为一个约定或者一种规范 12345678910111213141516171819interface AjaxOptins&#123; url:string type:string data:object success(data:object):void;&#125;function ajax(options:AjaxOptins)&#123;&#125;ajax(&#123; url:"http", type:'post', data:&#123;&#125;, success(data:object)&#123; &#125;&#125;) 接口的可选属性以及只读属性可选属性：?1234567891011121314151617181920interface AjaxOptins&#123; url:string //type加了可选属性，代表，type不是必须的值，是可选的 type?:string data:object success(data:object):void;&#125;function ajax(options:AjaxOptins)&#123;&#125;ajax(&#123; url:"http", data:&#123;&#125;, success(data:object)&#123; &#125;&#125;) 只读属性123456789101112interface Point&#123; readonly x:number y:number&#125;let poi:Point = &#123; x:10, y:10,&#125;//x为只读属性，重新赋值就会报错poi.x =100; 接口的额外属性检查可以在指定范围以外设置其他属性 1234567891011121314interface Point&#123; readonly x:number y:number, //设置了额外的属性检查才可以为下面的增加z属性 [propName:string]:any,&#125;let poi:Point = &#123; x:10, y:10, z:19,&#125; 函数类型接口12345678interface SumInterface&#123; (a:number,b:number):number&#125;let sum:SumInterface = function(a:number,b:number)&#123; return a+b&#125; 类类型12345678910interface ClockInterFace&#123; currentTime:Date,&#125;class Clock implements ClockInterFace&#123; currentTime:Date = new Date() constructor(h:number,m:number)&#123; &#125;&#125; 接口继承接口123456789101112131415interface TwoPointP &#123; x: number, y: number,&#125;interface ThreePointP extends TwoPointP &#123; z: number&#125;//必须指定x,y,z三项内容才可以let poi2: ThreePointP = &#123; z: 100, x: 100, y: 100&#125; 接口继承类当接口继承一个类类型，他会继承类的成员但是不包括其实现。就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。接口同样会继承到类的private和protected成员。这意味着当你创建了一个接口继承了一个拥有私有或者被保护的成员的类时，这个接口类型只能被这个类或其子类所实现implement。 当你有一个庞大的继承结构这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用，除了继承自基类，子类之间不必相关联。 1234567891011121314class Animal &#123; name:string ="" eat()&#123;&#125;&#125;interface AnimalInterFace extends Animal&#123;&#125;class Bird implements AnimalInterFace &#123; name:string = "12" eat()&#123;&#125;&#125;]]></content>
      <categories>
        <category>JavaScript进阶</category>
      </categories>
      <tags>
        <tag>Ne</tag>
        <tag>TypeScript</tag>
        <tag>Flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架原理与进阶]]></title>
    <url>%2F2018%2F10%2F25%2Fn_framework%2F</url>
    <content type="text"><![CDATA[前端工程化工具模块化关于模块化模块化是一种将系统分离成独立功能部分的方法，可将系统分割成独立的功能部分，严格定义模块接口、模块间具有透明性。 优点 灵活架构，焦点分离 方便模块间组合、分解 方便单个模块功能调试、升级 多人协作互不干扰 发展历程 script标签 ComonJS AMD CMD UMD ES6 工具Webpackhttps://webpack.js.org 基本概念: 1Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 优势: 123451、代码拆分2、Loader3、智能解析4、插件系统5、快速运行 实战之基本演练: 12345678910111213141516171819202122232425262728293031323334353637383940414243打包单个js文件 1、新建一个项目的入口文件entry.js并且在里面写好内容 2、一定要切换到项目根目录，使用 webpack entry.js bundle.js 3、在项目根目录，创建index.html，导入bundle.js文件 4、运行 打包具有依赖关系的两个js文件 1、新建两个文件 entry.js module.js ，并且在里面写好导出 导入的代码 2、一定要切换到项目根目录，使用 webpack entry.js bundle.js 3、在项目根目录，创建index.html，导入bundle.js文件 4、运行 打包非js(以后css)文件 1、新建一个site.css文件，里面写上内容 2、一定要切换到项目根目录，使用 webpack entry.js bundle.js 3、我们需要安装两个load来打包css文件 npm i style-loader css-loader -D 4、使用style-loader &amp; css-loader 来打包css文件 4.1、再导入css的时候，使用style-loader css-loader 4.2、在终端里面对css结尾的文件统一处理 webpack.config.js的使用 作用:简化在终端里面输入的很长的打包指令 1、项目根目录下创建webpack.config.js 2、在webpack.config.js中配置 entry output loader github案例 实战之和VueJS结合使用 1234567891011121314151617181920212223242526272829303132333435webpack + vue 构建项目【实现热更新，看到Hello Vue】#### 新建基本的文件和文件夹 1、创建一个项目的根目录 szhmqd18 |--src 项目的源代码目录 |--main.js 项目的入口文件 |--App.vue 根组件【项目启动之后看到的第一个组件】 |--package.json 项目配置文件 npm init -y |--webpack.config.dev.js 项目开发阶段的配置文件#### 在新建的文件中写代码 App.vue 写上hello Vue main.js 导入根组件【使用es6的语法】，渲染根组件【利用Vue】 webpack.config.dev.js entry #### 利用 webpack-dev-server + html-webpack-plugin 运行我们的项目 webpack-dev-server【只是打包生成了bundle.js】 webpack-dev-server --progress --config webpack.config.dev.js --open --hot 把上面的指令，放在package.json的scripts中 "dev":"webpack-dev-server --progress --config webpack.config.dev.js --open --hot" html-webpack-plugin【帮我们生成index.html并且自动导入bundle.js】 安装包 在 webapck.config.dev.js 中配置 Parcelhttps://parceljs.org/ 基本概念: 1极速零配置Web应用打包工具 优势: 1234561、极速打包2、将你所有的资源打包3、自动转换4、零配置代码分拆5、热模块替换6、友好的错误日志 实战之基本使用 1234567891、首先通过 Yarn 或者 npm 安装 Parcel npm install -g parcel-bundler2、创建一个 index.html 和 index.js 文件，并且写好代码3、打包 parcel index.html4、打开浏览器 parcel index.html --open 实战之和VueJS结合使用 1234567891、首先，我们需要安装 Vue 的依赖关系。 npm install --save vue npm install --save-dev parcel-bundler2、向 package.json 的 scripts 中添加 start 脚本。 // package.json "scripts": &#123; "start": "parcel index.html" &#125; Rolluphttps://www.rollupjs.com/guide/zh 基本概念: 1Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。 优势: 1231、静态分析2、小巧而专一 实战之打包流行库 1231、写一个js库2、使用rollup打包]]></content>
      <categories>
        <category>JavaScript进阶</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Webpack</tag>
        <tag>Vue</tag>
        <tag>Ne</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初步实现Axios]]></title>
    <url>%2F2018%2F09%2F11%2Fmy-axios%2F</url>
    <content type="text"><![CDATA[关于Axiosaxios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止CSRF/XSRF 本次主要实现浏览器的XMLHttpRequest请求，使用原生方法，使用promise封装实现； 关于原生Ajax初步认识ajax12345678var xhr = new XMLHttpRequest();xhr.open('get', 'http://localhost:3002/login', true);xhr.send();xhr.onreadystatechange = function() &#123; console.log(xhr.readyState) console.log(xhr.responseText) console.log(xhr.status)&#125;; 详细解析构建对象使用XMLHttpRequest构造函数构造ajax对象，注意此方法在IE有兼容行兼容写法 1234567var xhr = null;if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest();&#125; else &#123; // xhr = new ActiveXObject('Microsoft.XMLHTTP'); xhr = new ActiveXObject('Microsoft.XMLHTTP');&#125; 参数open方法参数： type（post、get） url：路径 async：是否异步：true、false如果是同步情况下，获得文本内容不用使用回调函数，直接xhr.responseText就可以 发送参数send方法 get请求默认null； post请求根据请求数据格式设置不同的请求头 1json:xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); 处理响应处理相应方法为onreadystatechange回调函数 关于readyState： 0：xhr对象初始化 1：执行发送动作 2：服务端数据已经完全返回 3：数据正在解析 4：数据解析完成，可以使用了 原生封装123456789101112131415161718192021222324252627282930function myAjax(type, url, param, callback) &#123; //Ajax语法结构 var xhr = null; if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123; // xhr = new ActiveXObject('Microsoft.XMLHTTP'); xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; if (type == 'get') &#123; url += '?' + encodeURI(param); &#125; xhr.open(type, url); var data = null; if (type == 'post') &#123; //如果是post提交，需要将参数传给send； data = param; //设置请求头 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); &#125; xhr.send(data); //处理响应 xhr.onreadystatechange = function() &#123; if (xhr.status == 200 &amp;&amp; xhr.readyState == 4) &#123; var result = xhr.responseText; result = JSON.parse(result) callback(result); &#125; &#125;;&#125;]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解闭包、作用域]]></title>
    <url>%2F2018%2F08%2F22%2Fclosure2%2F</url>
    <content type="text"><![CDATA[局部作用域和垃圾回收机制1234567891011function a() &#123; var b = 12;&#125;// a();function c() &#123; d = 12;&#125;c();// delete window.d;console.dir(window.d) js的垃圾回收机制(GC:Garbage Collecation)会定期清除无用的变量，释放内存空间，首先释放的就是生命周期结束的变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，所以，在函数执行完之后打印b是会报错的此处说明一下函数c内部的情况，声明变量不加var，为隐式声明，可以理解为window.d = 12；注意虽然是叫隐式声明，但是b此时并不是一个变量，而是window的一个属性，下面会专门找时间把变量和属性的区别描述清楚； 全局对象的属性和函数声明（这个属于插一曲）12345678var e = 123;window.f = 1213console.log(f)delete window.edelete window.fconsole.dir(e)console.log(window); 全局函数声明虽然也是挂载到window下的一个属性，但是函数声明和属性的区别是，函数声明拥有不可删除性，通过delect方法无法删除 局部作用域和闭包1234567891011//闭包案例function z() &#123; var num = 0; return function() &#123; return num++ &#125;&#125;var y = z();console.dir(z)console.log(y())console.log(y()) 调用一次返回值+1；正常函数调用完之后，局部作用域内声明的变量会被清除，但是如果在局部作用域函数有函数引用变量，形成闭包环境，该变量则不会清除，就会挂载到该局部作用域；所以函数调用一次就会增加一次形成一个缓存的作用，这也是为什么闭包会容易造成内存溢出的原因；//即使是局部作用域的函数未清除，全局作用域仍然无法获取该变量；所以这也是自执行函数IFEE能够形成自己独立区域的原因，防止变量污染； 块级作用域1234567891011121314//所谓的块级作用域就是&#123;&#125;&#123; var aa = 1&#125;console.log(aa) //1;//使用var声明变量没有块级作用域，常见的还有for循环中的变量i值&#123; let bb = 1; console.log(bb) //1;&#125;console.log(bb) //: bb is not defined// 使用es6的let和const可以生成一个块级作用域，所以之前的自调用函数，可以使用&#123;&#125;代替]]></content>
      <categories>
        <category>JavaScript进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的jQuery]]></title>
    <url>%2F2018%2F08%2F18%2Fmine-jQuery%2F</url>
    <content type="text"><![CDATA[序这个可能是一篇长博客，打算模拟jQuery的写法已经很长时间了，也看过jQuery的源码，当时看的时候晦涩难懂，基础实在不好，近一年时间一直用框架开发，忽然看到了一条新闻：2018年7月25日，Mislav Marohnić发了一条推文，宣布GitHub.com前端已经前端已经彻底删除了jQuery。而且，还自问自答地解释（低调炫耀），删除jQuery之后也没用其他框架，而是全部依赖原生API。突然才发现，原来jQuery已经距离我也越来越遥远了，这个也算是一种缅怀吧； 模拟主要思路模拟jquery首先看他的主要用法：12345$("#btn1") //获取元素$("#btn1").click(function()&#123;&#125;); //绑定事件$("#btn1").css() //设置css样式$("#btn1").text() //设置或返回所选元素的文本内容$("#btn1").html() //设置或返回所选元素的内容（包括 HTML 标记） 主要思路 $是一个方法，参数是id，css，tagName都可以，返回值为dom元素； jQuery内部隐式迭代，所以返回值是一个dom集合； css，html，click都是方法，挂在到$方法的返回值；综上所述，所谓的$以及调用之后的样子应该是 1234567891011121314151617181920212223// 第一 $是一个函数function $()&#123; return doms //dom集合&#125;// 第二 实现所有方法在一个集合内部var obj =&#123; css:function()&#123;&#125;, text:function()&#123;&#125;,&#125;//第三实现将$函数返回值继承obj，//继承方法又很多，常用原型链继承的方法function init()&#123;&#125;init.prototype = obj;function $()&#123; return new init() //dom集合&#125;// 第四实现返回值内部为所有dom对象的操作// 借助call和apply特殊的方法function init()&#123; [].push.apply(this, document.querySelectorAll(select))&#125; 实现主要逻辑代码123456789101112131415161718192021222324(function(w) &#123; //为了以后能方便借用数组的各种方法，提前存到变量中，全局都是用这一个数组，节约空间 function jQuery(select) &#123; return new init(select) &#125; //模拟jQuery中的Sizzle引擎，利用选择器获取元素 function Sizzle(select) &#123; return document.querySelectorAll(select); &#125; function init(select) &#123; [].push.apply(this, Sizzle(select)); return this; &#125; init.prototype = &#123; css: function() &#123; &#125; &#125; window.jQuery = window.$ = jQuery;&#125;)(window) 写完之后基本就可以使用了，下次将方法逐个实现；]]></content>
      <categories>
        <category>HTML/CSS进阶</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于递归-树状结构]]></title>
    <url>%2F2018%2F08%2F17%2Fabout-recursion%2F</url>
    <content type="text"><![CDATA[关于需求树状结构数据，需要为每一层增加一个索引值，第一层数据1，第二层2，以此类推；123456789101112131415161718var tree = [&#123; a: 1, children: [&#123; a: 1, children: [&#123; a: 1, &#125;] &#125;]&#125;, &#123; a: 1, children: [&#123; a: 1, children: [&#123; a: 1, &#125;] &#125;]&#125;] 具体结果看下代码1234567891011121314151617181920212223var tree = [ &#123; count:1, a: 1, children: [&#123; count:2, a: 1, children: [&#123; a: 1, count:3, &#125;] &#125;]&#125;, &#123; count:1, a: 1, children: [&#123; count:2, a: 1, children: [&#123; a: 1, count:3, &#125;] &#125;]&#125;] 关于解决思路思路1树状结构需要层层设置，一般想到的就是递归，关于count设置一个全局变量，递归一层，加一次；1234567891011121314var count = 0;function fn1(arr) &#123; count++ for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].count = count; if (arr[i].children) &#123; fn1(arr[i].children) &#125; &#125;&#125;fn1(arr)console.log(arr) 但是递归的顺序并非我们想要的那种，count++执行的时间和想要的不一致 思路2模拟for循环实现结构，考虑再次更改为递归 123456789for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].count = 1; if (arr[i].children) &#123; for (var k = 0; k &lt; arr[i].children.length; k++) &#123; // console.log(arr) arr[i].children[k].count = 2; &#125; &#125;&#125; 这是实现的基本思路，里面赋值的count可以理解为在for循环这个作用域内，是不改变的，每次递归一次，增加1,通过自执行函数缓存count，每次递归加1 更改版本12345678910function fn(arr, c) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].c = c; if (arr[i].children) &#123; (function(c) &#123; fn(arr[i].children, c += 1) &#125;)(c) &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[循环结构]]></title>
    <url>%2F2018%2F08%2F01%2Floop-sructure%2F</url>
    <content type="text"><![CDATA[while循环语法while (条件){ 需要执行的代码} 案例12345while (i&lt;5) &#123; x=x + "The number is " + i + "&lt;br&gt;"; i++; &#125; do/while 循环do/while 循环是 while 循环的变体。该循环会执行一次代码块，在检查条件是否为真之前，然后如果条件为真的话，就会重复这个循环。 语法do { 需要执行的代码 }while (条件); 案例下面的例子使用 do/while 循环。该循环至少会执行一次，即使条件是 false，隐藏代码块会在条件被测试前执行：123456do &#123; x=x + "The number is " + i + "&lt;br&gt;"; i++; &#125;while (i&lt;5); break和continuebreak 语句跳出循环后，会继续执行该循环之后的代码（如果有的话）： 1234567for (i = 0; i &lt; 10; i++) &#123; if (i == 3) &#123; break; &#125; console.log(i)&#125;//0 1 2 continue 语句中断循环中的迭代，如果出现了指定的条件，然后继续循环中的下一个迭代。12345for (i = 0; i &lt;= 10; i++) &#123; if (i == 3) continue; console.log(i)&#125;// 0 1 2 4 5 6 7 8 9 10 for和for in在遍历数组上的异同for循环和for in循环都可以遍历获取到数组的内容； for循环获取数组下标的typeof类型为number； for in 循环获取数组下标的typeof类型为string；1234567891011var arr = ['a','b','c'];for(var i = 0;i &lt; arr.length;i++)&#123; console.log(typeof(i));//number console.log(arr[i]);//a,b,c&#125; var att = ['a','b','c'];for(var j in att)&#123; console.log(typeof(j));//string console.log(att[j]);//a,b,c&#125; 在遍历对象上的异同for循环不能用于循环对象，因为for循环无法获取obj.length，所以for循环只能用于数组操作；for in 循环可以获取对象的键值，可以操作数组，还可操作对象；12345678910111213141516var obj = new Object(&#123; name:"Simon", age:"16", city:"BJ"&#125;); console.log(obj.length);//undefinedfor(var i = 0;i &lt; obj.length;i++)&#123; console.log(i);//空的 console.log(obj[i]);//空的&#125; for(var j in obj)&#123; console.log(j);//name,age,city console.log(obj[j]);//simon,16,BJ&#125; 为什么不建议for in 循环数组 如果原生Array类被其他的js脚本库进行了原型扩展，那么用for in遍历扩展后的Array对象的逻辑将与遍历原生Array对象的逻辑发生差异。 12345678var arr = [1]Array.prototype.test = function() &#123;&#125;console.dir(arr)for (const key in arr) &#123; console.log(key) //i test&#125;]]></content>
      <categories>
        <category>HTML/CSS基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数值类型]]></title>
    <url>%2F2018%2F08%2F01%2FtoNumber%2F</url>
    <content type="text"><![CDATA[Number()：概述：Number 对象由 Number() 构造器创建，是经过封装的能让你处理数字值的对象。在非构造器上下文中 (如：没有 new 操作符)，Number 能被用来执行类型转换。 特点： 1、如果是Boolean值，true和false值将分别被转换为1和0。 2、如果是数字值，只是简单的传入和返回。 3、如果是null值，返回0。 4、如果是undefined，返回NaN。 5、如果是字符串： a. 如果字符串中只包含数字时，将其转换为十进制数值，忽略前导0 b. 如果字符串中包含有效浮点格式，如“1.1”，将其转换为对应的浮点数字，忽略前导0 c. 如果字符串中包含有效的十六进制格式，如“0xf”，将其转换为相同大小的十进制数值 d. 如果字符串为空，将其转换为0 e. 如果字符串中包含除上述格式之外的字符，则将其转换为NaN 如果是对象，则调用对象的valueOf（）方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString（）方法，然后再依照前面的规则转换返回的字符串值。 12345var num1 = Number("Hello world"); ·//NaNvar num2 = Number(""); //0var num3 = Number("0000011"); //11var num4 = Number(3.14fasdasf); //Uncaught SyntaxError: Invalid or unexpected tokenvar num5 = Number("3.14fasdasf"); //NaN parseInt():概述：parseInt() 函数将给定的字符串以指定基数（radix/base）解析成为整数。 语法：parseInt(string, radix); 参数：string：要被解析的值。如果参数不是一个字符串，则将其转换为字符串。字符串开头的空白符将会被忽略。 radix：一个2到36之间的整数值，用于指定转换中采用的基数。比如参数”10”表示使用我们通常使用的十进制数值系统。总是指定该参数可以消除阅读该代码时的困惑并且保证转换结果可预测。当忽略该参数时，不同的实现环境可能产生不同的结果。 特点： 1、如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN。转换空字符串也会返回NaN。 2、开头和结尾的空白符允许存在，会被忽略，直到找到第一个非空格字符。 3、如果第一个字符是数字字符，parseInt() 会继续解析第二个字符，直到解析完所有后续字符串或者遇到了一个非数字字符。遇到不能解析的字符和其后的字符都将被忽略。接着返回已经解析的整数部分。 4、parseInt()方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。 5、基是由parseInt()方法的第二个参数指定的，所以要解析十六进制的值，当然，对二进制、八进制，甚至十进制（默认模式），都可以这样调用parseInt()方法。 实例：12345parseInt(101010, 2); //42var num1 = parseInt("AF",16); //175var num2 = parseInt("AF"); //NaNvar num3 = parseInt("10",2); //2 (按照二进制解析)var num4 = parseInt("sdasdad"); //NaN parseFloat():概述：parseFloat()方法将参数中指定的字符串解析成为一个浮点数字并返回. 语法：parseFloat(string) 特点： 1、parseFloat是个全局函数,不属于任何对象。 2、如果在解析过程中遇到了正负号(+或-),数字(0-9),小数点,或者科学记数法中的指数(e或E)以外的字符,则它会忽略该字符以及之后的所有字符,返回当前已经解析到的浮点数. 3、字符串首位的空白符会被忽略.如果参数字符串的第一个字符不能被解析成为数字,则parseFloat返回NaN. 4、字符串中第一个小数点是有效的，而第二个小数点就是无效的了，它后面的字符串将被忽略。 5、parseFloat() 只解析十进制，因此它没有第二个参数指定基数的用法 6、如果字符串中包含的是一个可解析为正数的数（没有小数点，或者小数点后都是零），parseFloat() 会返回整数。 实例：123456var num1 = parseFloat("123AF"); //123var num2 = parseFloat("0xA"); //0var num3 = parseFloat("22.5"); //22.5var num4 = parseFloat("22.3.56"); //22.3var num5 = parseFloat("0908.5"); //908.5 区别Number()、parseInt() 和parseFloat() 的区别： Number()的强制类型转换与parseInt()和parseFloat()方法的处理方式相似，只是它转换的是整个值，而不是部分值。如“3.4.5”，用Number()进行强制类型转换将返回NAN, 如果确定字符串值能被完整地转换，Number()将判断是调用parseInt()还是parseFloat()。 parseFloat() 所解析的字符串中第一个小数点是有效的，而parseInt() 遇到小数点会停止解析，因为小数点并不是有效的数字字符。 parseFloat() 始终会忽略前导的零，十六进制格式的字符串始终会被转换成0，而parseInt() 第二个参数可以设置基数，按照这个基数的进制来转换。]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逻辑运算符]]></title>
    <url>%2F2018%2F07%2F31%2ForAndFo%2F</url>
    <content type="text"><![CDATA[简介 运算符 描述 &amp;&amp; and ll or ! not 这个傻子都知道 关于true和false在javascript中，数据类型可以分为“真值”和“假值”。真值转换为bool时值为true；假值转换为bool时值为false 12345678console.log(Boolean("")) //falseconsole.log(Boolean(0)) //falseconsole.log(Boolean(1)) //trueconsole.log(Boolean(null)) //falseconsole.log(Boolean(undefined)) //falseconsole.log(Boolean([])) //trueconsole.log(Boolean(&#123;&#125;)) //trueconsole.log(Boolean(function() &#123;&#125;)) //true 关于短路 如果&amp;&amp;左侧表达式的值为真值，则返回右侧表达式的值；否则返回左侧表达式的值。 如果||左侧表达式的值为真值，则返回左侧表达式的值；否则返回右侧表达式的值。 1234console.log('' &amp;&amp; '1')console.log(2 &amp;&amp; 0)console.log('' || '1')console.log(2 || 0) 关于应用场景1假设对成长速度显示规定如下： 成长速度为5显示1个箭头； 成长速度为10显示2个箭头； 成长速度为12显示3个箭头； 成长速度为15显示4个箭头； 其他都显示都显示0各箭头。 使用分支结构：if、switch123456789101112131415161718192021222324252627282930var add_level = 0; if(add_step == 5)&#123; add_level = 1; &#125; else if(add_step == 10)&#123; add_level = 2; &#125; else if(add_step == 12)&#123; add_level = 3; &#125; else if(add_step == 15)&#123; add_level = 4; &#125; else &#123; add_level = 0; &#125;var add_level = 0; switch(add_step)&#123; case 5 : add_level = 1; break; case 10 : add_level = 2; break; case 12 : add_level = 3; break; case 15 : add_level = 4; break; default : add_level = 0; break;&#125; 使用运算符 123add_level = (add_step==5 &amp;&amp; 1) || (add_step==10 &amp;&amp; 2) || (add_step==12 &amp;&amp; 3) || (add_step==15 &amp;&amp; 4) || 0;// 或者var add_level=&#123;'5':1,'10':2,'12':3,'15':4&#125;[add_step] || 0; 场景2 成长速度为&gt;12显示4个箭头； 成长速度为&gt;10显示3个箭头； 成长速度为&gt;5显示2个箭头； 成长速度为&gt;0显示1个箭头； 成长速度为&lt;=0显示0个箭头。 那么用switch实现起来也很麻烦了，而且使用对象也没办法了，现在就到了展现真实实力的机会了1var add_level = (add_step&gt;12 &amp;&amp; 4) || (add_step&gt;10 &amp;&amp; 3) || (add_step&gt;5 &amp;&amp; 2) || (add_step&gt;0 &amp;&amp; 1) || 0; 场景3短路的应用12345678910a=a||"defaultValue"; if(!a)&#123; a="defaultValue"; &#125; if(a==null||a==""||a==undefined)&#123; a="defaultValue"; &#125;//防止回调函数未传报错callback&amp;&amp;callback()]]></content>
      <categories>
        <category>HTML/CSS基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>闭包</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型&数据类型检测]]></title>
    <url>%2F2018%2F07%2F27%2Fdata-type%2F</url>
    <content type="text"><![CDATA[1.数据类型分类1.1基本类型和复杂类型 5个基本类型：undefined，null，number，string，boolean 1个复杂类型：object1.2值类型和引用类型 值类型：字符串（string）、数值（number）、布尔值（null）、none、undefined 引用类型：对象（Object）、数组（Array）、函数（Function）值类型： 1、占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。） 2、保存与复制的是值本身 3、使用typeof检测数据的类型 4、基本类型数据是值类型引用类型： 1、占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。） 2、保存与复制的是指向对象的一个指针 3、使用instanceof检测数据类型 4、使用new()方法构造出的对象是引用型1.3 symbol已经有的6种数据类型: Undefined,Null,布尔值,字符串,数值,对象，现在ES6新加入一种数据类型——Symbol. 我们先来看看它的最大特点: 独一无二。 有这样一种场景，我们想区分两个属性，其实我们并不在意，这两个属性值究竟是什么，我们在意的是，这两个属性绝对要区分开来！ 2.数据类型判断2.1typeOf12345678910111213var a = 123;console.log(typeof a == "number"); //truevar a = '123';console.log(typeof a == "string"); //truevar a = true;console.log(typeof a == "boolean"); //truevar a = undefined;console.log(typeof a == "undefined"); //truevar a = null;console.log(a == null); //true/*复杂类型*/var a = function()&#123;&#125;;console.log(typeof a == "function"); //true 对于其他引用类型的对象，typeof不能检测区分，都会返回Object，如日期类型，正则表达式类型等，因此我们不能区分到底检测的是什么（用下文其他方法检测） typeof 方法函数封装123function typeOf(obj)&#123; return (obj === &apos;null&apos;) ? &apos;null&apos; : (typeof obj)&#125; 在这最后，补充一个特殊的NaN 1console.log(typeof NaN === &quot;number&quot;); //true 2.2 instanceofinstanceof 运算符可以用来检测一个对象是不是另一个对象的实例 语法：object1 instanceof object2 参数：object1-一个对象，constructor-另一个对象 返回值类型： 布尔值Boolean 也就是说，通过实例对象的原型链可以访问构造函数对象的原型对象上，这也就是instanceof的工作原理，这也说明了，instanceof并不关心对象的本身结构，只是关心对象与构造函数的关系。 1234567891011121314var a = new Date();console.log(a instanceof Date); //trueconsole.log(a instanceof Object); //truevar a = new RegExp('123');console.log(a instanceof RegExp); //trueconsole.log(a instanceof Object); //truevar a = function()&#123;&#125;;console.log(a instanceof Function); //trueconsole.log(a instanceof Object); //truevar a = [];console.log(a instanceof Array); //trueconsole.log(a instanceof Object); //truevar a = &#123;&#125;;console.log(a instanceof Object); //true 这里我列出了比较常用的实例，如果大家真的对instanceof比较关心的话，点击这里MDN文档 2.3 constructor属性constructor 属性返回对创建此对象的构造函数的引用。返回值类型： 对象Object这里说明一点的是，我们平时创建的，如： var a = 1, var b = ‘123’…，其实都是引用他们相对应的构造函数从而创建出来他们对于的类型，而不是表面我们看到的直接创建。各个类型检验方法如下： 12345678910111213141516171819202122232425262728/*5大基本类型*/var a = 123;console.log(a.constructor == Number); //truevar a = '123';console.log(a.constructor == String); //truevar a = true;console.log(a.constructor == Boolean); //truevar a = undefined;console.log(a &amp;&amp; a.constructor); //undefinedvar a = null;console.log(a &amp;&amp; a.constructor); //null /*复杂类型*/var a = function()&#123;&#125;;console.log(a.constructor == Function); //truevar a = new Date();console.log(a.constructor == Date); //truevar a = new Object();console.log(a.constructor == Object); //truevar a = &#123;&#125;;console.log(a.constructor == Object); //truevar a = new Array();console.log(a.constructor == Array); //truevar a = [];console.log(a.constructor == Array); //truevar a = new RegExp('abc');console.log(a.constructor == RegExp); //truevar a = /^abc$/;console.log(a.constructor == RegExp); //true 2.4 toString()方法这个方法检测对象类型最安全，最准确的方法。返回值类型：字符串String 1234567891011121314151617181920212223242526272829303132/*toString 检测类型函数*/function toStringType(obj)&#123; return Object.prototype.toString.call(obj).slice(8, -1);&#125;/*5大基本类型*/var a = 123;console.log(toStringType(a)); //"Number"var a = '123';console.log(toStringType(a)); //"String"var a = true;console.log(toStringType(a)); //"Boolean"var a = undefined;console.log(toStringType(a)); //"Undefined"var a = null;console.log(toStringType(a)); //"Null" /*复杂类型*/var a = function()&#123;&#125;;console.log(toStringType(a)); //"Function"var a = new Date();console.log(toStringType(a)); //"Date"var a = new Object();console.log(toStringType(a)); //"Object"var a = &#123;&#125;;console.log(toStringType(a)); //"Object"var a = new Array();console.log(toStringType(a)); //"Array"var a = [];console.log(toStringType(a)); //"Array"var a = new RegExp('abc');console.log(toStringType(a)); //"RegExp"var a = /^abc$/;console.log(toStringType(a)); //"RegExp" 如果你觉得返回的字符串大小写比较麻烦的话，你可以全部转化成小写代码如下： 123function toStringType(obj)&#123; return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();&#125;]]></content>
      <categories>
        <category>HTML/CSS基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高阶函数]]></title>
    <url>%2F2018%2F07%2F27%2Fhigher-function%2F</url>
    <content type="text"><![CDATA[1.概念 作为参数的函数 作为返回值的函数 都可以称为高阶函数 2.回调函数回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。 3.函数柯里化Currying把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术 12345678function currying(fn) &#123; var slice = Array.prototype.slice, __args = slice.call(arguments, 1); return function () &#123; var __inargs = slice.call(arguments); return fn.apply(null, __args.concat(__inargs)); &#125;;&#125; 柯里化特性决定了它这应用场景。提前把易变因素，传参固定下来，生成一个更明确的应用函数。最典型的代表应用，是bind函数用以固定this这个易变对象。 1234567Function.prototype.bind = function(context) &#123; var _this = this, _args = Array.prototype.slice.call(arguments, 1); return function() &#123; return _this.apply(context, _args.concat(Array.prototype.slice.call(arguments))) &#125;&#125; 4.案例1234567891011121314151617181920212223242526function currying(fn) &#123; var slice = Array.prototype.slice, __args = slice.call(arguments, 1); console.log(__args) return function () &#123; var __inargs = slice.call(arguments); console.log(__inargs) console.log(__args.concat(__inargs)) return fn.apply(null, __args.concat(__inargs)); &#125;;&#125;function square(i) &#123; console.log(i) return i * i;&#125;function dubble(i) &#123; return i *= 2;&#125;function map(handeler, list) &#123; return list.map(handeler);&#125;var mapSQ = currying(map, square);console.log(mapSQ([1, 2, 3, 4, 5]));]]></content>
      <categories>
        <category>JavaScript进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>高阶函数</tag>
        <tag>回调函数</tag>
        <tag>函数柯理化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流&函数防抖]]></title>
    <url>%2F2018%2F07%2F24%2Fdebounce%2F</url>
    <content type="text"><![CDATA[1.函数防抖说函数防抖，debounce。其概念其实是从机械开关和继电器的“去弹跳”（debounce）衍生 出来的，基本思路就是把多个信号合并为一个信号。 单反也有相似的概念，在拍照的时候手如果拿不稳晃的时候拍照一般手机是拍不出好照片的，因此智能手机是在你按一下时连续拍许多张， 能过合成手段，生成一张。翻译成JS就是，事件内的N个动作会变忽略，只有事件后由程序触发的动作只是有效。 12345678910111213141516171819202122// 函数防抖function debounce(func, delay) &#123; var timeout; return function (e) &#123; console.log("清除", timeout, e.target.value) clearTimeout(timeout); // console.log(arguments) var context = this, args = arguments console.log("新的", timeout, e.target.value) timeout = setTimeout(function () &#123; console.log("----") func.apply(context, args); &#125;, delay) &#125;;&#125;;var validate = debounce(function (e) &#123; console.log("change", e.target.value, new Date - 0)&#125;, 1000);// 绑定监听document.querySelector("input").addEventListener('input', validate); 实现思路如下，将目标方法（动作）包装在setTimeout里面，然后这个方法是一个事件的回调函数，如果这个回调一直执行，那么这些动作就一直不执行。为什么不执行呢，我们搞了一个clearTimeout，这样setTimeout里的方法就不会执行！ 为什么要clearTimeout呢，我们就需要将事件内的连续动作删掉嘛！待到用户不触发这事件了。那么setTimeout就自然会执行这个方法。 那么这个方法用在什么地方呢，就是用于input输入框架的格式验证，假如只是验证都是字母也罢了，太简单了，不怎么耗性能，如果是验证是否身份证，这性能消耗大，你可以隔170ms才验证一次。这时就需要这个东西。或者你这个是自动完全，需要将已有的输入数据往后端拉一个列表，频繁的交互，后端肯定耗不起，这时也需要这个，如隔350ms。 2.函数节流节流的概念可以想象一下水坝，你建了水坝在河道中，不能让水流动不了，你只能让水流慢些。换言之，你不能让用户的方法都不执行。如果这样干，就是debounce了。为了让用户的方法在某个时间段内只执行一次，我们需要保存上次执行的时间点与定时器。函数节流会用在比input, keyup更频繁触发的事件中，如resize, touchmove, mousemove, scroll。throttle 会强制函数以固定的速率执行。因此这个方法比较适合应用于动画相关的场景。 区别：函数防抖可以理解为在规定时间内如果屏蔽掉所有的行为操作，最后执行一次；函数节流可以理解为你触发操作后，隔一段时间执行一次，减少执行的频率，防止页面假死； 12345678910111213141516171819202122232425262728293031// 函数节流function throttle(fn, threshhold) &#123; var timeout var start = new Date; var threshhold = threshhold || 160 return function () &#123; var context = this, args = arguments, curr = new Date() - 0 clearTimeout(timeout)//总是干掉事件回调 if (curr - start &gt;= threshhold) &#123; console.log("now", curr, curr - start)//注意这里相减的结果，都差不多是160左右 fn.apply(context, args) //只执行一部分方法，这些方法是在某个时间段内执行一次 start = curr &#125; else &#123; //让方法在脱离事件后也能执行一次 timeout = setTimeout(function () &#123; fn.apply(context, args) &#125;, threshhold); &#125; &#125;&#125;var mousemove = throttle(function (e) &#123; console.log(e.pageX, e.pageY)&#125;,1000);// 绑定监听document.querySelector("#panel").addEventListener('mousemove', mousemove);function test (a,b,c)&#123; console.log(arguments)&#125;test(4,2,3)]]></content>
      <categories>
        <category>HTML/CSS进阶</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>闭包</tag>
        <tag>函数节流</tag>
        <tag>函数防抖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析闭包]]></title>
    <url>%2F2018%2F07%2F24%2Fclosure%2F</url>
    <content type="text"><![CDATA[闭包的概念：函数的闭包形成闭包；封闭的区域（可以调用其他作用域变量的函数）；闭包的组成：内层函数本身；内层函数所处的作用域； 闭包作用：1. 形成隔离的封闭空间；123456//函数里面的num不会影响外面num的值；var num = 100;(function()&#123; var num = 1000;&#125;)()console.log(num) 2. 延长变量的声明周期；3. 匿名自制行环境–沙箱 插件常用的内部变量外放的操作，将window和document作为实参放入沙箱之内，防止内部变量对于外部的影响 减少作用域链； 1234(function(window, doc)&#123; if (typeof exports !== 'undefined') exports.touchScroll = iScroll; else window.touchScroll = iScroll;&#125;)(window, document); 4. 缓存变量123456789var arr = []; for(var i=0;i&lt;10;i++)&#123; arr[i] = (function (n)&#123; return function()&#123; console.log(n) &#125; &#125;)(i) &#125;; arr[3](); //结果是3； 5.实现类和继承123456789101112131415161718192021222324252627function Person()&#123; var name = "default"; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125; &#125;; var p = new Person(); p.setName("Tom"); alert(p.getName()); var Jack = function()&#123;&#125;; //继承自Person Jack.prototype = new Person(); //添加私有方法 Jack.prototype.Say = function()&#123; alert("Hello,my name is Jack"); &#125;; var j = new Jack(); j.setName("Jack"); j.Say(); alert(j.getName()); 6.大量封装函数12345678910111213141516171819var person = function()&#123; // var num = '0'; return &#123; sum : function (num) &#123; var sum = 0; for(var i=0;i&lt;=num;i++)&#123; sum+=i; &#125; return sum; &#125;, mul : function (num) &#123; var mul = 1; for(var i = 1;i&lt;=num;i++)&#123; mul*=i; &#125; return mul; &#125; &#125;&#125;(); 7.案例1234567var arr=[]; for(var i=0;i&lt;3;i++)&#123; arr[i]=(function(j)&#123;return function()&#123;console.log(j)&#125;&#125;)(i) &#125; arr[0](); arr[1](); arr[2](); 1234567//生成随机数 function getNum()&#123; var num=parseInt(Math.random()*10+1); return function()&#123; return num; &#125; &#125;;]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量提升]]></title>
    <url>%2F2018%2F07%2F20%2Fvariable-lifting%2F</url>
    <content type="text"><![CDATA[变量提升是JS在非严格模式下，JS解析的时候出现的一种情况 JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。 JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。 1.变量提升 12345console.log(first) //undefinedvar first = 124;/*正常var变量声明之后会被提升到最顶端，但是是声明提前，赋值不提前，所以为undefined*/ 2.函数提升 12345678second(); //123function second() &#123; console.log(123)&#125;/*征程通过function声明之后函数会被提升到最顶端，可以直接在声明之前调用*/ 3.函数提升 1234567// third(); //14-变量提升.html:28 Uncaught TypeError: third is not a functionvar third = function () &#123;console.log('第三种')&#125;/*页面报错，因为var声明变量，声明提前，赋值不提前，所以trird为undefined，所以报错；*/ 4.函数和变量提升对比 1234567891011121314151617181920console.log(fifth) //ƒ fifth()&#123;// console.log(123)// &#125;var fifth = 123;function fifth() &#123;console.log(123)&#125;/*函数和变量同时声明，函数覆盖变量，在进行变量提升；*/console.log(six) //ƒ six()&#123;// console.log(123)// &#125;function six() &#123;console.log(123)&#125;var six = 123;/*函数和变量同时声明，函数覆盖变量，在进行变量提升；*/]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>变量提升</tag>
      </tags>
  </entry>
</search>
